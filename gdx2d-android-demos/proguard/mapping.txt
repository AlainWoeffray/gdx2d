android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat -> android.support.v4.a.a:
    android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl IMPL -> b
    int FEEDBACK_ALL_MASK -> a
    java.lang.String getId(android.accessibilityservice.AccessibilityServiceInfo) -> a
    android.content.pm.ResolveInfo getResolveInfo(android.accessibilityservice.AccessibilityServiceInfo) -> b
    java.lang.String getSettingsActivityName(android.accessibilityservice.AccessibilityServiceInfo) -> c
    boolean getCanRetrieveWindowContent(android.accessibilityservice.AccessibilityServiceInfo) -> d
    java.lang.String getDescription(android.accessibilityservice.AccessibilityServiceInfo) -> e
    java.lang.String feedbackTypeToString(int) -> a
    java.lang.String flagToString(int) -> b
android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat$AccessibilityServiceInfoIcsImpl -> android.support.v4.a.b:
    boolean getCanRetrieveWindowContent(android.accessibilityservice.AccessibilityServiceInfo) -> a
    java.lang.String getDescription(android.accessibilityservice.AccessibilityServiceInfo) -> b
    java.lang.String getId(android.accessibilityservice.AccessibilityServiceInfo) -> c
    android.content.pm.ResolveInfo getResolveInfo(android.accessibilityservice.AccessibilityServiceInfo) -> d
    java.lang.String getSettingsActivityName(android.accessibilityservice.AccessibilityServiceInfo) -> e
android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat$AccessibilityServiceInfoStubImpl -> android.support.v4.a.c:
    boolean getCanRetrieveWindowContent(android.accessibilityservice.AccessibilityServiceInfo) -> a
    java.lang.String getDescription(android.accessibilityservice.AccessibilityServiceInfo) -> b
    java.lang.String getId(android.accessibilityservice.AccessibilityServiceInfo) -> c
    android.content.pm.ResolveInfo getResolveInfo(android.accessibilityservice.AccessibilityServiceInfo) -> d
    java.lang.String getSettingsActivityName(android.accessibilityservice.AccessibilityServiceInfo) -> e
android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl -> android.support.v4.a.d:
    java.lang.String getId(android.accessibilityservice.AccessibilityServiceInfo) -> c
    android.content.pm.ResolveInfo getResolveInfo(android.accessibilityservice.AccessibilityServiceInfo) -> d
    boolean getCanRetrieveWindowContent(android.accessibilityservice.AccessibilityServiceInfo) -> a
    java.lang.String getDescription(android.accessibilityservice.AccessibilityServiceInfo) -> b
    java.lang.String getSettingsActivityName(android.accessibilityservice.AccessibilityServiceInfo) -> e
android.support.v4.accessibilityservice.AccessibilityServiceInfoCompatIcs -> android.support.v4.a.e:
    boolean getCanRetrieveWindowContent(android.accessibilityservice.AccessibilityServiceInfo) -> a
    java.lang.String getDescription(android.accessibilityservice.AccessibilityServiceInfo) -> b
    java.lang.String getId(android.accessibilityservice.AccessibilityServiceInfo) -> c
    android.content.pm.ResolveInfo getResolveInfo(android.accessibilityservice.AccessibilityServiceInfo) -> d
    java.lang.String getSettingsActivityName(android.accessibilityservice.AccessibilityServiceInfo) -> e
android.support.v4.app.ActionBarDrawerToggle -> android.support.v4.app.a:
    android.support.v4.app.ActionBarDrawerToggle$ActionBarDrawerToggleImpl IMPL -> a
    int ID_HOME -> b
    android.app.Activity mActivity -> c
    android.support.v4.widget.DrawerLayout mDrawerLayout -> d
    boolean mDrawerIndicatorEnabled -> e
    android.graphics.drawable.Drawable mThemeImage -> f
    android.graphics.drawable.Drawable mDrawerImage -> g
    android.support.v4.app.ActionBarDrawerToggle$SlideDrawable mSlider -> h
    int mDrawerImageResource -> i
    int mOpenDrawerContentDescRes -> j
    int mCloseDrawerContentDescRes -> k
    java.lang.Object mSetIndicatorInfo -> l
    void syncState() -> a
    void setDrawerIndicatorEnabled(boolean) -> a
    boolean isDrawerIndicatorEnabled() -> b
    void onConfigurationChanged(android.content.res.Configuration) -> a
    boolean onOptionsItemSelected(android.view.MenuItem) -> a
    void onDrawerSlide(android.view.View,float) -> a
    void onDrawerOpened(android.view.View) -> a
    void onDrawerClosed(android.view.View) -> b
    void onDrawerStateChanged(int) -> a
android.support.v4.app.ActionBarDrawerToggle$1 -> android.support.v4.app.b:
android.support.v4.app.ActionBarDrawerToggle$ActionBarDrawerToggleImpl -> android.support.v4.app.c:
    android.graphics.drawable.Drawable getThemeUpIndicator(android.app.Activity) -> a
    java.lang.Object setActionBarUpIndicator(java.lang.Object,android.app.Activity,android.graphics.drawable.Drawable,int) -> a
    java.lang.Object setActionBarDescription(java.lang.Object,android.app.Activity,int) -> a
android.support.v4.app.ActionBarDrawerToggle$ActionBarDrawerToggleImplBase -> android.support.v4.app.d:
    android.graphics.drawable.Drawable getThemeUpIndicator(android.app.Activity) -> a
    java.lang.Object setActionBarUpIndicator(java.lang.Object,android.app.Activity,android.graphics.drawable.Drawable,int) -> a
    java.lang.Object setActionBarDescription(java.lang.Object,android.app.Activity,int) -> a
android.support.v4.app.ActionBarDrawerToggle$ActionBarDrawerToggleImplHC -> android.support.v4.app.e:
    android.graphics.drawable.Drawable getThemeUpIndicator(android.app.Activity) -> a
    java.lang.Object setActionBarUpIndicator(java.lang.Object,android.app.Activity,android.graphics.drawable.Drawable,int) -> a
    java.lang.Object setActionBarDescription(java.lang.Object,android.app.Activity,int) -> a
android.support.v4.app.ActionBarDrawerToggle$SlideDrawable -> android.support.v4.app.f:
    android.graphics.drawable.Drawable mWrapped -> a
    float mOffset -> b
    float mOffsetBy -> c
    android.graphics.Rect mTmpRect -> d
    void setOffset(float) -> a
    float getOffset() -> a
    void setOffsetBy(float) -> b
    void draw(android.graphics.Canvas) -> draw
    void setChangingConfigurations(int) -> setChangingConfigurations
    int getChangingConfigurations() -> getChangingConfigurations
    void setDither(boolean) -> setDither
    void setFilterBitmap(boolean) -> setFilterBitmap
    void setAlpha(int) -> setAlpha
    void setColorFilter(android.graphics.ColorFilter) -> setColorFilter
    void setColorFilter(int,android.graphics.PorterDuff$Mode) -> setColorFilter
    void clearColorFilter() -> clearColorFilter
    boolean isStateful() -> isStateful
    boolean setState(int[]) -> setState
    int[] getState() -> getState
    android.graphics.drawable.Drawable getCurrent() -> getCurrent
    boolean setVisible(boolean,boolean) -> setVisible
    int getOpacity() -> getOpacity
    android.graphics.Region getTransparentRegion() -> getTransparentRegion
    boolean onStateChange(int[]) -> onStateChange
    void onBoundsChange(android.graphics.Rect) -> onBoundsChange
    int getIntrinsicWidth() -> getIntrinsicWidth
    int getIntrinsicHeight() -> getIntrinsicHeight
    int getMinimumWidth() -> getMinimumWidth
    int getMinimumHeight() -> getMinimumHeight
    boolean getPadding(android.graphics.Rect) -> getPadding
    android.graphics.drawable.Drawable$ConstantState getConstantState() -> getConstantState
    void invalidateDrawable(android.graphics.drawable.Drawable) -> invalidateDrawable
    void scheduleDrawable(android.graphics.drawable.Drawable,java.lang.Runnable,long) -> scheduleDrawable
    void unscheduleDrawable(android.graphics.drawable.Drawable,java.lang.Runnable) -> unscheduleDrawable
android.support.v4.app.ActionBarDrawerToggleHoneycomb -> android.support.v4.app.g:
    java.lang.String TAG -> a
    int[] THEME_ATTRS -> b
    java.lang.Object setActionBarUpIndicator(java.lang.Object,android.app.Activity,android.graphics.drawable.Drawable,int) -> a
    java.lang.Object setActionBarDescription(java.lang.Object,android.app.Activity,int) -> a
    android.graphics.drawable.Drawable getThemeUpIndicator(android.app.Activity) -> a
android.support.v4.app.ActionBarDrawerToggleHoneycomb$SetIndicatorInfo -> android.support.v4.app.h:
    java.lang.reflect.Method setHomeAsUpIndicator -> a
    java.lang.reflect.Method setHomeActionContentDescription -> b
    android.widget.ImageView upIndicatorView -> c
android.support.v4.app.ActivityCompat -> android.support.v4.app.i:
    boolean invalidateOptionsMenu(android.app.Activity) -> a
    void startActivity(android.app.Activity,android.content.Intent,android.os.Bundle) -> a
    void startActivityForResult(android.app.Activity,android.content.Intent,int,android.os.Bundle) -> a
android.support.v4.app.ActivityCompatHoneycomb -> android.support.v4.app.j:
    void invalidateOptionsMenu(android.app.Activity) -> a
    void dump(android.app.Activity,java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.app.ActivityCompatJB -> android.support.v4.app.k:
    void startActivity(android.content.Context,android.content.Intent,android.os.Bundle) -> a
    void startActivityForResult(android.app.Activity,android.content.Intent,int,android.os.Bundle) -> a
android.support.v4.app.ActivityOptionsCompat -> android.support.v4.app.l:
    android.support.v4.app.ActivityOptionsCompat makeCustomAnimation(android.content.Context,int,int) -> a
    android.support.v4.app.ActivityOptionsCompat makeScaleUpAnimation(android.view.View,int,int,int,int) -> a
    android.support.v4.app.ActivityOptionsCompat makeThumbnailScaleUpAnimation(android.view.View,android.graphics.Bitmap,int,int) -> a
    android.os.Bundle toBundle() -> a
    void update(android.support.v4.app.ActivityOptionsCompat) -> a
android.support.v4.app.ActivityOptionsCompat$ActivityOptionsImplJB -> android.support.v4.app.m:
    android.support.v4.app.ActivityOptionsCompatJB mImpl -> a
    android.os.Bundle toBundle() -> a
    void update(android.support.v4.app.ActivityOptionsCompat) -> a
android.support.v4.app.ActivityOptionsCompatJB -> android.support.v4.app.n:
    android.app.ActivityOptions mActivityOptions -> a
    android.support.v4.app.ActivityOptionsCompatJB makeCustomAnimation(android.content.Context,int,int) -> a
    android.support.v4.app.ActivityOptionsCompatJB makeScaleUpAnimation(android.view.View,int,int,int,int) -> a
    android.support.v4.app.ActivityOptionsCompatJB makeThumbnailScaleUpAnimation(android.view.View,android.graphics.Bitmap,int,int) -> a
    android.os.Bundle toBundle() -> a
    void update(android.support.v4.app.ActivityOptionsCompatJB) -> a
android.support.v4.app.BackStackRecord -> android.support.v4.app.o:
    java.lang.String TAG -> a
    android.support.v4.app.FragmentManagerImpl mManager -> b
    int OP_NULL -> c
    int OP_ADD -> d
    int OP_REPLACE -> e
    int OP_REMOVE -> f
    int OP_HIDE -> g
    int OP_SHOW -> h
    int OP_DETACH -> i
    int OP_ATTACH -> j
    android.support.v4.app.BackStackRecord$Op mHead -> k
    android.support.v4.app.BackStackRecord$Op mTail -> l
    int mNumOp -> m
    int mEnterAnim -> n
    int mExitAnim -> o
    int mPopEnterAnim -> p
    int mPopExitAnim -> q
    int mTransition -> r
    int mTransitionStyle -> s
    boolean mAddToBackStack -> t
    boolean mAllowAddToBackStack -> u
    java.lang.String mName -> v
    boolean mCommitted -> w
    int mIndex -> x
    int mBreadCrumbTitleRes -> y
    java.lang.CharSequence mBreadCrumbTitleText -> z
    int mBreadCrumbShortTitleRes -> A
    java.lang.CharSequence mBreadCrumbShortTitleText -> B
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void dump(java.lang.String,java.io.PrintWriter,boolean) -> a
    int getId() -> a
    int getBreadCrumbTitleRes() -> b
    int getBreadCrumbShortTitleRes() -> c
    java.lang.CharSequence getBreadCrumbTitle() -> d
    java.lang.CharSequence getBreadCrumbShortTitle() -> e
    void addOp(android.support.v4.app.BackStackRecord$Op) -> a
    android.support.v4.app.FragmentTransaction add(android.support.v4.app.Fragment,java.lang.String) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    void doAddOp(int,android.support.v4.app.Fragment,java.lang.String,int) -> a
    android.support.v4.app.FragmentTransaction replace(int,android.support.v4.app.Fragment) -> b
    android.support.v4.app.FragmentTransaction replace(int,android.support.v4.app.Fragment,java.lang.String) -> b
    android.support.v4.app.FragmentTransaction remove(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction hide(android.support.v4.app.Fragment) -> b
    android.support.v4.app.FragmentTransaction show(android.support.v4.app.Fragment) -> c
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> d
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> e
    android.support.v4.app.FragmentTransaction setCustomAnimations(int,int) -> a
    android.support.v4.app.FragmentTransaction setCustomAnimations(int,int,int,int) -> a
    android.support.v4.app.FragmentTransaction setTransition(int) -> a
    android.support.v4.app.FragmentTransaction setTransitionStyle(int) -> b
    android.support.v4.app.FragmentTransaction addToBackStack(java.lang.String) -> a
    boolean isAddToBackStackAllowed() -> f
    android.support.v4.app.FragmentTransaction disallowAddToBackStack() -> g
    android.support.v4.app.FragmentTransaction setBreadCrumbTitle(int) -> c
    android.support.v4.app.FragmentTransaction setBreadCrumbTitle(java.lang.CharSequence) -> a
    android.support.v4.app.FragmentTransaction setBreadCrumbShortTitle(int) -> d
    android.support.v4.app.FragmentTransaction setBreadCrumbShortTitle(java.lang.CharSequence) -> b
    void bumpBackStackNesting(int) -> e
    int commit() -> h
    int commitAllowingStateLoss() -> i
    int commitInternal(boolean) -> a
    void run() -> run
    void popFromBackStack(boolean) -> b
    java.lang.String getName() -> j
    int getTransition() -> k
    int getTransitionStyle() -> l
    boolean isEmpty() -> m
android.support.v4.app.BackStackRecord$Op -> android.support.v4.app.p:
    android.support.v4.app.BackStackRecord$Op next -> a
    android.support.v4.app.BackStackRecord$Op prev -> b
    int cmd -> c
    android.support.v4.app.Fragment fragment -> d
    int enterAnim -> e
    int exitAnim -> f
    int popEnterAnim -> g
    int popExitAnim -> h
    java.util.ArrayList removed -> i
android.support.v4.app.BackStackState -> android.support.v4.app.BackStackState:
    int[] mOps -> a
    int mTransition -> b
    int mTransitionStyle -> c
    java.lang.String mName -> d
    int mIndex -> e
    int mBreadCrumbTitleRes -> f
    java.lang.CharSequence mBreadCrumbTitleText -> g
    int mBreadCrumbShortTitleRes -> h
    java.lang.CharSequence mBreadCrumbShortTitleText -> i
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.BackStackRecord instantiate(android.support.v4.app.FragmentManagerImpl) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.BackStackState$1 -> android.support.v4.app.q:
    android.support.v4.app.BackStackState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.BackStackState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.DialogFragment -> android.support.v4.app.r:
    int STYLE_NORMAL -> a
    int STYLE_NO_TITLE -> b
    int STYLE_NO_FRAME -> c
    int STYLE_NO_INPUT -> d
    java.lang.String SAVED_DIALOG_STATE_TAG -> ai
    java.lang.String SAVED_STYLE -> aj
    java.lang.String SAVED_THEME -> ak
    java.lang.String SAVED_CANCELABLE -> al
    java.lang.String SAVED_SHOWS_DIALOG -> am
    java.lang.String SAVED_BACK_STACK_ID -> an
    int mStyle -> e
    int mTheme -> f
    boolean mCancelable -> g
    boolean mShowsDialog -> h
    int mBackStackId -> i
    android.app.Dialog mDialog -> j
    boolean mViewDestroyed -> k
    boolean mDismissed -> l
    boolean mShownByMe -> m
    void setStyle(int,int) -> a
    void show(android.support.v4.app.FragmentManager,java.lang.String) -> a
    int show(android.support.v4.app.FragmentTransaction,java.lang.String) -> a
    void dismiss() -> a
    void dismissAllowingStateLoss() -> b
    void dismissInternal(boolean) -> a
    android.app.Dialog getDialog() -> c
    int getTheme() -> d
    void setCancelable(boolean) -> b
    boolean isCancelable() -> e
    void setShowsDialog(boolean) -> c
    boolean getShowsDialog() -> f
    void onAttach(android.app.Activity) -> a
    void onDetach() -> g
    void onCreate(android.os.Bundle) -> a
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> b
    android.app.Dialog onCreateDialog(android.os.Bundle) -> c
    void onCancel(android.content.DialogInterface) -> onCancel
    void onDismiss(android.content.DialogInterface) -> onDismiss
    void onActivityCreated(android.os.Bundle) -> d
    void onStart() -> h
    void onSaveInstanceState(android.os.Bundle) -> e
    void onStop() -> i
    void onDestroyView() -> j
android.support.v4.app.Fragment -> android.support.v4.app.Fragment:
    java.util.HashMap sClassMap -> a
    int INITIALIZING -> n
    int CREATED -> o
    int ACTIVITY_CREATED -> p
    int STOPPED -> q
    int STARTED -> r
    int RESUMED -> s
    int mState -> t
    android.view.View mAnimatingAway -> u
    int mStateAfterAnimating -> v
    android.os.Bundle mSavedFragmentState -> w
    android.util.SparseArray mSavedViewState -> x
    int mIndex -> y
    java.lang.String mWho -> z
    android.os.Bundle mArguments -> A
    android.support.v4.app.Fragment mTarget -> B
    int mTargetIndex -> C
    int mTargetRequestCode -> D
    boolean mAdded -> E
    boolean mRemoving -> F
    boolean mResumed -> G
    boolean mFromLayout -> H
    boolean mInLayout -> I
    boolean mRestored -> J
    int mBackStackNesting -> K
    android.support.v4.app.FragmentManagerImpl mFragmentManager -> L
    android.support.v4.app.FragmentActivity mActivity -> M
    android.support.v4.app.FragmentManagerImpl mChildFragmentManager -> N
    android.support.v4.app.Fragment mParentFragment -> O
    int mFragmentId -> P
    int mContainerId -> Q
    java.lang.String mTag -> R
    boolean mHidden -> S
    boolean mDetached -> T
    boolean mRetainInstance -> U
    boolean mRetaining -> V
    boolean mHasMenu -> W
    boolean mMenuVisible -> X
    boolean mCalled -> Y
    int mNextAnim -> Z
    android.view.ViewGroup mContainer -> aa
    android.view.View mView -> ab
    android.view.View mInnerView -> ac
    boolean mDeferStart -> ad
    boolean mUserVisibleHint -> ae
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> af
    boolean mLoadersStarted -> ag
    boolean mCheckedForLoaderManager -> ah
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String) -> a
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    void restoreViewState(android.os.Bundle) -> f
    void setIndex(int,android.support.v4.app.Fragment) -> a
    boolean isInBackStack() -> k
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int getId() -> l
    java.lang.String getTag() -> m
    void setArguments(android.os.Bundle) -> g
    android.os.Bundle getArguments() -> n
    void setInitialSavedState(android.support.v4.app.Fragment$SavedState) -> a
    void setTargetFragment(android.support.v4.app.Fragment,int) -> a
    android.support.v4.app.Fragment getTargetFragment() -> o
    int getTargetRequestCode() -> p
    android.support.v4.app.FragmentActivity getActivity() -> q
    android.content.res.Resources getResources() -> r
    java.lang.CharSequence getText(int) -> a
    java.lang.String getString(int) -> b
    java.lang.String getString(int,java.lang.Object[]) -> a
    android.support.v4.app.FragmentManager getFragmentManager() -> s
    android.support.v4.app.FragmentManager getChildFragmentManager() -> t
    android.support.v4.app.Fragment getParentFragment() -> u
    boolean isAdded() -> v
    boolean isDetached() -> w
    boolean isRemoving() -> x
    boolean isInLayout() -> y
    boolean isResumed() -> z
    boolean isVisible() -> A
    boolean isHidden() -> B
    void onHiddenChanged(boolean) -> d
    void setRetainInstance(boolean) -> e
    boolean getRetainInstance() -> C
    void setHasOptionsMenu(boolean) -> f
    void setMenuVisibility(boolean) -> g
    void setUserVisibleHint(boolean) -> h
    boolean getUserVisibleHint() -> D
    android.support.v4.app.LoaderManager getLoaderManager() -> E
    void startActivity(android.content.Intent) -> a
    void startActivityForResult(android.content.Intent,int) -> a
    void onActivityResult(int,int,android.content.Intent) -> a
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> b
    void onInflate(android.app.Activity,android.util.AttributeSet,android.os.Bundle) -> a
    void onAttach(android.app.Activity) -> a
    android.view.animation.Animation onCreateAnimation(int,boolean,int) -> a
    void onCreate(android.os.Bundle) -> a
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> a
    void onViewCreated(android.view.View,android.os.Bundle) -> a
    android.view.View getView() -> F
    void onActivityCreated(android.os.Bundle) -> d
    void onViewStateRestored(android.os.Bundle) -> h
    void onStart() -> h
    void onResume() -> G
    void onSaveInstanceState(android.os.Bundle) -> e
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onPause() -> H
    void onStop() -> i
    void onLowMemory() -> onLowMemory
    void onDestroyView() -> j
    void onDestroy() -> I
    void initState() -> J
    void onDetach() -> g
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    void onPrepareOptionsMenu(android.view.Menu) -> a
    void onDestroyOptionsMenu() -> K
    boolean onOptionsItemSelected(android.view.MenuItem) -> a
    void onOptionsMenuClosed(android.view.Menu) -> b
    void onCreateContextMenu(android.view.ContextMenu,android.view.View,android.view.ContextMenu$ContextMenuInfo) -> onCreateContextMenu
    void registerForContextMenu(android.view.View) -> a
    void unregisterForContextMenu(android.view.View) -> b
    boolean onContextItemSelected(android.view.MenuItem) -> b
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.support.v4.app.Fragment findFragmentByWho(java.lang.String) -> a
    void instantiateChildFragmentManager() -> L
    void performCreate(android.os.Bundle) -> i
    android.view.View performCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> b
    void performActivityCreated(android.os.Bundle) -> j
    void performStart() -> M
    void performResume() -> N
    void performConfigurationChanged(android.content.res.Configuration) -> a
    void performLowMemory() -> O
    boolean performCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> b
    boolean performPrepareOptionsMenu(android.view.Menu) -> c
    boolean performOptionsItemSelected(android.view.MenuItem) -> c
    boolean performContextItemSelected(android.view.MenuItem) -> d
    void performOptionsMenuClosed(android.view.Menu) -> d
    void performSaveInstanceState(android.os.Bundle) -> k
    void performPause() -> P
    void performStop() -> Q
    void performReallyStop() -> R
    void performDestroyView() -> S
    void performDestroy() -> T
android.support.v4.app.Fragment$1 -> android.support.v4.app.s:
    android.support.v4.app.Fragment this$0 -> a
    android.view.View findViewById(int) -> a
android.support.v4.app.Fragment$InstantiationException -> android.support.v4.app.t:
android.support.v4.app.Fragment$SavedState -> android.support.v4.app.Fragment$SavedState:
    android.os.Bundle mState -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.Fragment$SavedState$1 -> android.support.v4.app.u:
    android.support.v4.app.Fragment$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.Fragment$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentActivity -> android.support.v4.app.v:
    java.lang.String TAG -> q
    java.lang.String FRAGMENTS_TAG -> a
    int HONEYCOMB -> r
    int MSG_REALLY_STOPPED -> b
    int MSG_RESUME_PENDING -> c
    android.os.Handler mHandler -> d
    android.support.v4.app.FragmentManagerImpl mFragments -> e
    android.support.v4.app.FragmentContainer mContainer -> f
    boolean mCreated -> g
    boolean mResumed -> h
    boolean mStopped -> i
    boolean mReallyStopped -> j
    boolean mRetaining -> k
    boolean mOptionsMenuInvalidated -> l
    boolean mCheckedForLoaderManager -> m
    boolean mLoadersStarted -> n
    java.util.HashMap mAllLoaderManagers -> o
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> p
    void onActivityResult(int,int,android.content.Intent) -> onActivityResult
    void onBackPressed() -> onBackPressed
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onCreate(android.os.Bundle) -> onCreate
    boolean onCreatePanelMenu(int,android.view.Menu) -> onCreatePanelMenu
    android.view.View onCreateView(java.lang.String,android.content.Context,android.util.AttributeSet) -> onCreateView
    void onDestroy() -> onDestroy
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    void onLowMemory() -> onLowMemory
    boolean onMenuItemSelected(int,android.view.MenuItem) -> onMenuItemSelected
    void onPanelClosed(int,android.view.Menu) -> onPanelClosed
    void onPause() -> onPause
    void onNewIntent(android.content.Intent) -> onNewIntent
    void onResume() -> onResume
    void onPostResume() -> onPostResume
    void onResumeFragments() -> a
    boolean onPreparePanel(int,android.view.View,android.view.Menu) -> onPreparePanel
    java.lang.Object onRetainNonConfigurationInstance() -> onRetainNonConfigurationInstance
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onStart() -> onStart
    void onStop() -> onStop
    java.lang.Object onRetainCustomNonConfigurationInstance() -> b
    java.lang.Object getLastCustomNonConfigurationInstance() -> c
    void supportInvalidateOptionsMenu() -> d
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> dump
    java.lang.String viewToString(android.view.View) -> a
    void dumpViewHierarchy(java.lang.String,java.io.PrintWriter,android.view.View) -> a
    void doReallyStop(boolean) -> a
    void onReallyStop() -> e
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentManager getSupportFragmentManager() -> f
    void startActivityForResult(android.content.Intent,int) -> startActivityForResult
    void startActivityFromFragment(android.support.v4.app.Fragment,android.content.Intent,int) -> a
    void invalidateSupportFragment(java.lang.String) -> a
    android.support.v4.app.LoaderManager getSupportLoaderManager() -> g
    android.support.v4.app.LoaderManagerImpl getLoaderManager(java.lang.String,boolean,boolean) -> a
android.support.v4.app.FragmentActivity$1 -> android.support.v4.app.w:
    android.support.v4.app.FragmentActivity this$0 -> a
    void handleMessage(android.os.Message) -> handleMessage
android.support.v4.app.FragmentActivity$2 -> android.support.v4.app.x:
    android.support.v4.app.FragmentActivity this$0 -> a
    android.view.View findViewById(int) -> a
android.support.v4.app.FragmentActivity$FragmentTag -> android.support.v4.app.y:
    int[] Fragment -> a
    int Fragment_id -> b
    int Fragment_name -> c
    int Fragment_tag -> d
android.support.v4.app.FragmentActivity$NonConfigurationInstances -> android.support.v4.app.z:
    java.lang.Object activity -> a
    java.lang.Object custom -> b
    java.util.HashMap children -> c
    java.util.ArrayList fragments -> d
    java.util.HashMap loaders -> e
android.support.v4.app.FragmentContainer -> android.support.v4.app.aa:
    android.view.View findViewById(int) -> a
android.support.v4.app.FragmentManager -> android.support.v4.app.ab:
    int POP_BACK_STACK_INCLUSIVE -> a
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    android.support.v4.app.FragmentTransaction openTransaction() -> b
    boolean executePendingTransactions() -> c
    android.support.v4.app.Fragment findFragmentById(int) -> a
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
    void popBackStack() -> d
    boolean popBackStackImmediate() -> e
    void popBackStack(java.lang.String,int) -> a
    boolean popBackStackImmediate(java.lang.String,int) -> b
    void popBackStack(int,int) -> a
    boolean popBackStackImmediate(int,int) -> b
    int getBackStackEntryCount() -> f
    android.support.v4.app.FragmentManager$BackStackEntry getBackStackEntryAt(int) -> b
    void addOnBackStackChangedListener(android.support.v4.app.FragmentManager$OnBackStackChangedListener) -> a
    void removeOnBackStackChangedListener(android.support.v4.app.FragmentManager$OnBackStackChangedListener) -> b
    void putFragment(android.os.Bundle,java.lang.String,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> a
    android.support.v4.app.Fragment$SavedState saveFragmentInstanceState(android.support.v4.app.Fragment) -> a
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void enableDebugLogging(boolean) -> a
android.support.v4.app.FragmentManager$BackStackEntry -> android.support.v4.app.ac:
    int getId() -> a
    java.lang.String getName() -> j
    int getBreadCrumbTitleRes() -> b
    int getBreadCrumbShortTitleRes() -> c
    java.lang.CharSequence getBreadCrumbTitle() -> d
    java.lang.CharSequence getBreadCrumbShortTitle() -> e
android.support.v4.app.FragmentManager$OnBackStackChangedListener -> android.support.v4.app.ad:
    void onBackStackChanged() -> a
android.support.v4.app.FragmentManagerImpl -> android.support.v4.app.ae:
    boolean DEBUG -> b
    java.lang.String TAG -> c
    boolean HONEYCOMB -> d
    java.lang.String TARGET_REQUEST_CODE_STATE_TAG -> e
    java.lang.String TARGET_STATE_TAG -> f
    java.lang.String VIEW_STATE_TAG -> g
    java.lang.String USER_VISIBLE_HINT_TAG -> h
    java.util.ArrayList mPendingActions -> i
    java.lang.Runnable[] mTmpActions -> j
    boolean mExecutingActions -> k
    java.util.ArrayList mActive -> l
    java.util.ArrayList mAdded -> m
    java.util.ArrayList mAvailIndices -> n
    java.util.ArrayList mBackStack -> o
    java.util.ArrayList mCreatedMenus -> p
    java.util.ArrayList mBackStackIndices -> q
    java.util.ArrayList mAvailBackStackIndices -> r
    java.util.ArrayList mBackStackChangeListeners -> s
    int mCurState -> t
    android.support.v4.app.FragmentActivity mActivity -> u
    android.support.v4.app.FragmentContainer mContainer -> v
    android.support.v4.app.Fragment mParent -> w
    boolean mNeedMenuInvalidate -> x
    boolean mStateSaved -> y
    boolean mDestroyed -> z
    java.lang.String mNoTransactionsBecause -> A
    boolean mHavePendingDeferredStart -> B
    android.os.Bundle mStateBundle -> C
    android.util.SparseArray mStateArray -> D
    java.lang.Runnable mExecCommit -> E
    android.view.animation.Interpolator DECELERATE_QUINT -> F
    android.view.animation.Interpolator DECELERATE_CUBIC -> G
    android.view.animation.Interpolator ACCELERATE_QUINT -> H
    android.view.animation.Interpolator ACCELERATE_CUBIC -> I
    int ANIM_DUR -> J
    int ANIM_STYLE_OPEN_ENTER -> K
    int ANIM_STYLE_OPEN_EXIT -> L
    int ANIM_STYLE_CLOSE_ENTER -> M
    int ANIM_STYLE_CLOSE_EXIT -> N
    int ANIM_STYLE_FADE_ENTER -> O
    int ANIM_STYLE_FADE_EXIT -> P
    void throwException(java.lang.RuntimeException) -> a
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    boolean executePendingTransactions() -> c
    void popBackStack() -> d
    boolean popBackStackImmediate() -> e
    void popBackStack(java.lang.String,int) -> a
    boolean popBackStackImmediate(java.lang.String,int) -> b
    void popBackStack(int,int) -> a
    boolean popBackStackImmediate(int,int) -> b
    int getBackStackEntryCount() -> f
    android.support.v4.app.FragmentManager$BackStackEntry getBackStackEntryAt(int) -> b
    void addOnBackStackChangedListener(android.support.v4.app.FragmentManager$OnBackStackChangedListener) -> a
    void removeOnBackStackChangedListener(android.support.v4.app.FragmentManager$OnBackStackChangedListener) -> b
    void putFragment(android.os.Bundle,java.lang.String,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> a
    android.support.v4.app.Fragment$SavedState saveFragmentInstanceState(android.support.v4.app.Fragment) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.view.animation.Animation makeOpenCloseAnimation(android.content.Context,float,float,float,float) -> a
    android.view.animation.Animation makeFadeAnimation(android.content.Context,float,float) -> a
    android.view.animation.Animation loadAnimation(android.support.v4.app.Fragment,int,boolean,int) -> a
    void performPendingDeferredStart(android.support.v4.app.Fragment) -> b
    void moveToState(android.support.v4.app.Fragment,int,int,int,boolean) -> a
    void moveToState(android.support.v4.app.Fragment) -> c
    void moveToState(int,boolean) -> a
    void moveToState(int,int,int,boolean) -> a
    void startPendingDeferredFragments() -> g
    void makeActive(android.support.v4.app.Fragment) -> d
    void makeInactive(android.support.v4.app.Fragment) -> e
    void addFragment(android.support.v4.app.Fragment,boolean) -> a
    void removeFragment(android.support.v4.app.Fragment,int,int) -> a
    void hideFragment(android.support.v4.app.Fragment,int,int) -> b
    void showFragment(android.support.v4.app.Fragment,int,int) -> c
    void detachFragment(android.support.v4.app.Fragment,int,int) -> d
    void attachFragment(android.support.v4.app.Fragment,int,int) -> e
    android.support.v4.app.Fragment findFragmentById(int) -> a
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
    android.support.v4.app.Fragment findFragmentByWho(java.lang.String) -> b
    void checkStateLoss() -> w
    void enqueueAction(java.lang.Runnable,boolean) -> a
    int allocBackStackIndex(android.support.v4.app.BackStackRecord) -> a
    void setBackStackIndex(int,android.support.v4.app.BackStackRecord) -> a
    void freeBackStackIndex(int) -> c
    boolean execPendingActions() -> h
    void reportBackStackChanged() -> i
    void addBackStackState(android.support.v4.app.BackStackRecord) -> b
    boolean popBackStackState(android.os.Handler,java.lang.String,int,int) -> a
    java.util.ArrayList retainNonConfig() -> j
    void saveFragmentViewState(android.support.v4.app.Fragment) -> f
    android.os.Bundle saveFragmentBasicState(android.support.v4.app.Fragment) -> g
    android.os.Parcelable saveAllState() -> k
    void restoreAllState(android.os.Parcelable,java.util.ArrayList) -> a
    void attachActivity(android.support.v4.app.FragmentActivity,android.support.v4.app.FragmentContainer,android.support.v4.app.Fragment) -> a
    void noteStateNotSaved() -> l
    void dispatchCreate() -> m
    void dispatchActivityCreated() -> n
    void dispatchStart() -> o
    void dispatchResume() -> p
    void dispatchPause() -> q
    void dispatchStop() -> r
    void dispatchReallyStop() -> s
    void dispatchDestroyView() -> t
    void dispatchDestroy() -> u
    void dispatchConfigurationChanged(android.content.res.Configuration) -> a
    void dispatchLowMemory() -> v
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> a
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> a
    boolean dispatchContextItemSelected(android.view.MenuItem) -> b
    void dispatchOptionsMenuClosed(android.view.Menu) -> b
    int reverseTransit(int) -> d
    int transitToStyleIndex(int,boolean) -> b
android.support.v4.app.FragmentManagerImpl$1 -> android.support.v4.app.af:
    android.support.v4.app.FragmentManagerImpl this$0 -> a
    void run() -> run
android.support.v4.app.FragmentManagerImpl$2 -> android.support.v4.app.ag:
    android.support.v4.app.FragmentManagerImpl this$0 -> a
    void run() -> run
android.support.v4.app.FragmentManagerImpl$3 -> android.support.v4.app.ah:
    java.lang.String val$name -> a
    int val$flags -> b
    android.support.v4.app.FragmentManagerImpl this$0 -> c
    void run() -> run
android.support.v4.app.FragmentManagerImpl$4 -> android.support.v4.app.ai:
    int val$id -> a
    int val$flags -> b
    android.support.v4.app.FragmentManagerImpl this$0 -> c
    void run() -> run
android.support.v4.app.FragmentManagerImpl$5 -> android.support.v4.app.aj:
    android.support.v4.app.Fragment val$fragment -> a
    android.support.v4.app.FragmentManagerImpl this$0 -> b
    void onAnimationEnd(android.view.animation.Animation) -> onAnimationEnd
    void onAnimationRepeat(android.view.animation.Animation) -> onAnimationRepeat
    void onAnimationStart(android.view.animation.Animation) -> onAnimationStart
android.support.v4.app.FragmentManagerState -> android.support.v4.app.FragmentManagerState:
    android.support.v4.app.FragmentState[] mActive -> a
    int[] mAdded -> b
    android.support.v4.app.BackStackState[] mBackStack -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentManagerState$1 -> android.support.v4.app.ak:
    android.support.v4.app.FragmentManagerState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentManagerState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentPagerAdapter -> android.support.v4.app.al:
    java.lang.String TAG -> c
    boolean DEBUG -> d
    android.support.v4.app.FragmentManager mFragmentManager -> e
    android.support.v4.app.FragmentTransaction mCurTransaction -> f
    android.support.v4.app.Fragment mCurrentPrimaryItem -> g
    android.support.v4.app.Fragment getItem(int) -> a
    void startUpdate(android.view.ViewGroup) -> a
    java.lang.Object instantiateItem(android.view.ViewGroup,int) -> a
    void destroyItem(android.view.ViewGroup,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.ViewGroup,int,java.lang.Object) -> b
    void finishUpdate(android.view.ViewGroup) -> b
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    android.os.Parcelable saveState() -> a
    void restoreState(android.os.Parcelable,java.lang.ClassLoader) -> a
    long getItemId(int) -> b
    java.lang.String makeFragmentName(int,long) -> a
android.support.v4.app.FragmentState -> android.support.v4.app.FragmentState:
    java.lang.String mClassName -> a
    int mIndex -> b
    boolean mFromLayout -> c
    int mFragmentId -> d
    int mContainerId -> e
    java.lang.String mTag -> f
    boolean mRetainInstance -> g
    boolean mDetached -> h
    android.os.Bundle mArguments -> i
    android.os.Bundle mSavedFragmentState -> j
    android.support.v4.app.Fragment mInstance -> k
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.Fragment instantiate(android.support.v4.app.FragmentActivity,android.support.v4.app.Fragment) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentState$1 -> android.support.v4.app.am:
    android.support.v4.app.FragmentState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentStatePagerAdapter -> android.support.v4.app.an:
    java.lang.String TAG -> c
    boolean DEBUG -> d
    android.support.v4.app.FragmentManager mFragmentManager -> e
    android.support.v4.app.FragmentTransaction mCurTransaction -> f
    java.util.ArrayList mSavedState -> g
    java.util.ArrayList mFragments -> h
    android.support.v4.app.Fragment mCurrentPrimaryItem -> i
    android.support.v4.app.Fragment getItem(int) -> a
    void startUpdate(android.view.ViewGroup) -> a
    java.lang.Object instantiateItem(android.view.ViewGroup,int) -> a
    void destroyItem(android.view.ViewGroup,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.ViewGroup,int,java.lang.Object) -> b
    void finishUpdate(android.view.ViewGroup) -> b
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    android.os.Parcelable saveState() -> a
    void restoreState(android.os.Parcelable,java.lang.ClassLoader) -> a
android.support.v4.app.FragmentTabHost -> android.support.v4.app.FragmentTabHost:
    java.util.ArrayList mTabs -> a
    android.widget.FrameLayout mRealTabContent -> b
    android.content.Context mContext -> c
    android.support.v4.app.FragmentManager mFragmentManager -> d
    int mContainerId -> e
    android.widget.TabHost$OnTabChangeListener mOnTabChangeListener -> f
    android.support.v4.app.FragmentTabHost$TabInfo mLastTab -> g
    boolean mAttached -> h
    void initFragmentTabHost(android.content.Context,android.util.AttributeSet) -> a
    void setup() -> setup
    void setup(android.content.Context,android.support.v4.app.FragmentManager) -> a
    void setup(android.content.Context,android.support.v4.app.FragmentManager,int) -> a
    void ensureContent() -> a
    void setOnTabChangedListener(android.widget.TabHost$OnTabChangeListener) -> setOnTabChangedListener
    void addTab(android.widget.TabHost$TabSpec,java.lang.Class,android.os.Bundle) -> a
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void onTabChanged(java.lang.String) -> onTabChanged
    android.support.v4.app.FragmentTransaction doTabChanged(java.lang.String,android.support.v4.app.FragmentTransaction) -> a
android.support.v4.app.FragmentTabHost$1 -> android.support.v4.app.ao:
android.support.v4.app.FragmentTabHost$DummyTabFactory -> android.support.v4.app.ap:
    android.content.Context mContext -> a
    android.view.View createTabContent(java.lang.String) -> createTabContent
android.support.v4.app.FragmentTabHost$SavedState -> android.support.v4.app.FragmentTabHost$SavedState:
    java.lang.String curTab -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.app.FragmentTabHost$SavedState$1 -> android.support.v4.app.aq:
    android.support.v4.app.FragmentTabHost$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentTabHost$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentTabHost$TabInfo -> android.support.v4.app.ar:
    java.lang.String tag -> a
    java.lang.Class clss -> b
    android.os.Bundle args -> c
    android.support.v4.app.Fragment fragment -> d
    android.support.v4.app.Fragment access$102(android.support.v4.app.FragmentTabHost$TabInfo,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment access$100(android.support.v4.app.FragmentTabHost$TabInfo) -> a
    java.lang.String access$200(android.support.v4.app.FragmentTabHost$TabInfo) -> b
    java.lang.Class access$300(android.support.v4.app.FragmentTabHost$TabInfo) -> c
    android.os.Bundle access$400(android.support.v4.app.FragmentTabHost$TabInfo) -> d
android.support.v4.app.FragmentTransaction -> android.support.v4.app.as:
    int TRANSIT_ENTER_MASK -> C
    int TRANSIT_EXIT_MASK -> D
    int TRANSIT_UNSET -> E
    int TRANSIT_NONE -> F
    int TRANSIT_FRAGMENT_OPEN -> G
    int TRANSIT_FRAGMENT_CLOSE -> H
    int TRANSIT_FRAGMENT_FADE -> I
    android.support.v4.app.FragmentTransaction add(android.support.v4.app.Fragment,java.lang.String) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    android.support.v4.app.FragmentTransaction replace(int,android.support.v4.app.Fragment) -> b
    android.support.v4.app.FragmentTransaction replace(int,android.support.v4.app.Fragment,java.lang.String) -> b
    android.support.v4.app.FragmentTransaction remove(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction hide(android.support.v4.app.Fragment) -> b
    android.support.v4.app.FragmentTransaction show(android.support.v4.app.Fragment) -> c
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> d
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> e
    boolean isEmpty() -> m
    android.support.v4.app.FragmentTransaction setCustomAnimations(int,int) -> a
    android.support.v4.app.FragmentTransaction setCustomAnimations(int,int,int,int) -> a
    android.support.v4.app.FragmentTransaction setTransition(int) -> a
    android.support.v4.app.FragmentTransaction setTransitionStyle(int) -> b
    android.support.v4.app.FragmentTransaction addToBackStack(java.lang.String) -> a
    boolean isAddToBackStackAllowed() -> f
    android.support.v4.app.FragmentTransaction disallowAddToBackStack() -> g
    android.support.v4.app.FragmentTransaction setBreadCrumbTitle(int) -> c
    android.support.v4.app.FragmentTransaction setBreadCrumbTitle(java.lang.CharSequence) -> a
    android.support.v4.app.FragmentTransaction setBreadCrumbShortTitle(int) -> d
    android.support.v4.app.FragmentTransaction setBreadCrumbShortTitle(java.lang.CharSequence) -> b
    int commit() -> h
    int commitAllowingStateLoss() -> i
android.support.v4.app.ListFragment -> android.support.v4.app.at:
    int INTERNAL_EMPTY_ID -> a
    int INTERNAL_PROGRESS_CONTAINER_ID -> b
    int INTERNAL_LIST_CONTAINER_ID -> c
    android.os.Handler mHandler -> l
    java.lang.Runnable mRequestFocus -> m
    android.widget.AdapterView$OnItemClickListener mOnClickListener -> ai
    android.widget.ListAdapter mAdapter -> d
    android.widget.ListView mList -> e
    android.view.View mEmptyView -> f
    android.widget.TextView mStandardEmptyView -> g
    android.view.View mProgressContainer -> h
    android.view.View mListContainer -> i
    java.lang.CharSequence mEmptyText -> j
    boolean mListShown -> k
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> a
    void onViewCreated(android.view.View,android.os.Bundle) -> a
    void onDestroyView() -> j
    void onListItemClick(android.widget.ListView,android.view.View,int,long) -> a
    void setListAdapter(android.widget.ListAdapter) -> a
    void setSelection(int) -> c
    int getSelectedItemPosition() -> a
    long getSelectedItemId() -> b
    android.widget.ListView getListView() -> c
    void setEmptyText(java.lang.CharSequence) -> a
    void setListShown(boolean) -> a
    void setListShownNoAnimation(boolean) -> b
    void setListShown(boolean,boolean) -> a
    android.widget.ListAdapter getListAdapter() -> d
    void ensureList() -> e
android.support.v4.app.ListFragment$1 -> android.support.v4.app.au:
    android.support.v4.app.ListFragment this$0 -> a
    void run() -> run
android.support.v4.app.ListFragment$2 -> android.support.v4.app.av:
    android.support.v4.app.ListFragment this$0 -> a
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
android.support.v4.app.LoaderManager -> android.support.v4.app.aw:
    android.support.v4.content.Loader initLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> a
    android.support.v4.content.Loader restartLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> b
    void destroyLoader(int) -> a
    android.support.v4.content.Loader getLoader(int) -> b
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void enableDebugLogging(boolean) -> a
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManager$LoaderCallbacks -> android.support.v4.app.ax:
    android.support.v4.content.Loader onCreateLoader(int,android.os.Bundle) -> a
    void onLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    void onLoaderReset(android.support.v4.content.Loader) -> a
android.support.v4.app.LoaderManagerImpl -> android.support.v4.app.ay:
    java.lang.String TAG -> a
    boolean DEBUG -> b
    android.support.v4.util.SparseArrayCompat mLoaders -> c
    android.support.v4.util.SparseArrayCompat mInactiveLoaders -> d
    java.lang.String mWho -> e
    android.support.v4.app.FragmentActivity mActivity -> f
    boolean mStarted -> g
    boolean mRetaining -> h
    boolean mRetainingStarted -> i
    boolean mCreatingLoader -> j
    void updateActivity(android.support.v4.app.FragmentActivity) -> a
    android.support.v4.app.LoaderManagerImpl$LoaderInfo createLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> c
    android.support.v4.app.LoaderManagerImpl$LoaderInfo createAndInstallLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> d
    void installLoader(android.support.v4.app.LoaderManagerImpl$LoaderInfo) -> a
    android.support.v4.content.Loader initLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> a
    android.support.v4.content.Loader restartLoader(int,android.os.Bundle,android.support.v4.app.LoaderManager$LoaderCallbacks) -> b
    void destroyLoader(int) -> a
    android.support.v4.content.Loader getLoader(int) -> b
    void doStart() -> b
    void doStop() -> c
    void doRetain() -> d
    void finishRetain() -> e
    void doReportNextStart() -> f
    void doReportStart() -> g
    void doDestroy() -> h
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManagerImpl$LoaderInfo -> android.support.v4.app.az:
    int mId -> a
    android.os.Bundle mArgs -> b
    android.support.v4.app.LoaderManager$LoaderCallbacks mCallbacks -> c
    android.support.v4.content.Loader mLoader -> d
    boolean mHaveData -> e
    boolean mDeliveredData -> f
    java.lang.Object mData -> g
    boolean mStarted -> h
    boolean mRetaining -> i
    boolean mRetainingStarted -> j
    boolean mReportNextStart -> k
    boolean mDestroyed -> l
    boolean mListenerRegistered -> m
    android.support.v4.app.LoaderManagerImpl$LoaderInfo mPendingLoader -> n
    android.support.v4.app.LoaderManagerImpl this$0 -> o
    void start() -> a
    void retain() -> b
    void finishRetain() -> c
    void reportStart() -> d
    void stop() -> e
    void destroy() -> f
    void onLoadComplete(android.support.v4.content.Loader,java.lang.Object) -> a
    void callOnLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> b
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.app.NavUtils -> android.support.v4.app.ba:
    java.lang.String TAG -> b
    java.lang.String PARENT_ACTIVITY -> a
    android.support.v4.app.NavUtils$NavUtilsImpl IMPL -> c
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> a
    void navigateUpFromSameTask(android.app.Activity) -> a
    void navigateUpTo(android.app.Activity,android.content.Intent) -> b
    android.content.Intent getParentActivityIntent(android.app.Activity) -> b
    android.content.Intent getParentActivityIntent(android.content.Context,java.lang.Class) -> a
    android.content.Intent getParentActivityIntent(android.content.Context,android.content.ComponentName) -> a
    java.lang.String getParentActivityName(android.app.Activity) -> c
    java.lang.String getParentActivityName(android.content.Context,android.content.ComponentName) -> b
android.support.v4.app.NavUtils$NavUtilsImpl -> android.support.v4.app.bb:
    android.content.Intent getParentActivityIntent(android.app.Activity) -> a
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> a
    void navigateUpTo(android.app.Activity,android.content.Intent) -> b
    java.lang.String getParentActivityName(android.content.Context,android.content.pm.ActivityInfo) -> a
android.support.v4.app.NavUtils$NavUtilsImplBase -> android.support.v4.app.bc:
    android.content.Intent getParentActivityIntent(android.app.Activity) -> a
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> a
    void navigateUpTo(android.app.Activity,android.content.Intent) -> b
    java.lang.String getParentActivityName(android.content.Context,android.content.pm.ActivityInfo) -> a
android.support.v4.app.NavUtils$NavUtilsImplJB -> android.support.v4.app.bd:
    android.content.Intent getParentActivityIntent(android.app.Activity) -> a
    android.content.Intent superGetParentActivityIntent(android.app.Activity) -> b
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> a
    void navigateUpTo(android.app.Activity,android.content.Intent) -> b
    java.lang.String getParentActivityName(android.content.Context,android.content.pm.ActivityInfo) -> a
android.support.v4.app.NavUtilsJB -> android.support.v4.app.be:
    android.content.Intent getParentActivityIntent(android.app.Activity) -> a
    boolean shouldUpRecreateTask(android.app.Activity,android.content.Intent) -> a
    void navigateUpTo(android.app.Activity,android.content.Intent) -> b
    java.lang.String getParentActivityName(android.content.pm.ActivityInfo) -> a
android.support.v4.app.NoSaveStateFrameLayout -> android.support.v4.app.bf:
    android.view.ViewGroup wrap(android.view.View) -> a
    void dispatchSaveInstanceState(android.util.SparseArray) -> dispatchSaveInstanceState
    void dispatchRestoreInstanceState(android.util.SparseArray) -> dispatchRestoreInstanceState
android.support.v4.app.NotificationCompat -> android.support.v4.app.bg:
    int FLAG_HIGH_PRIORITY -> a
    int PRIORITY_DEFAULT -> b
    int PRIORITY_LOW -> c
    int PRIORITY_MIN -> d
    int PRIORITY_HIGH -> e
    int PRIORITY_MAX -> f
    android.support.v4.app.NotificationCompat$NotificationCompatImpl IMPL -> g
    android.support.v4.app.NotificationCompat$NotificationCompatImpl access$000() -> a
android.support.v4.app.NotificationCompat$Action -> android.support.v4.app.bh:
    int icon -> a
    java.lang.CharSequence title -> b
    android.app.PendingIntent actionIntent -> c
android.support.v4.app.NotificationCompat$BigPictureStyle -> android.support.v4.app.bi:
    android.graphics.Bitmap mPicture -> a
    android.graphics.Bitmap mBigLargeIcon -> b
    boolean mBigLargeIconSet -> c
    android.support.v4.app.NotificationCompat$BigPictureStyle setBigContentTitle(java.lang.CharSequence) -> a
    android.support.v4.app.NotificationCompat$BigPictureStyle setSummaryText(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$BigPictureStyle bigPicture(android.graphics.Bitmap) -> a
    android.support.v4.app.NotificationCompat$BigPictureStyle bigLargeIcon(android.graphics.Bitmap) -> b
android.support.v4.app.NotificationCompat$BigTextStyle -> android.support.v4.app.bj:
    java.lang.CharSequence mBigText -> a
    android.support.v4.app.NotificationCompat$BigTextStyle setBigContentTitle(java.lang.CharSequence) -> a
    android.support.v4.app.NotificationCompat$BigTextStyle setSummaryText(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$BigTextStyle bigText(java.lang.CharSequence) -> c
android.support.v4.app.NotificationCompat$Builder -> android.support.v4.app.bk:
    android.content.Context mContext -> a
    java.lang.CharSequence mContentTitle -> b
    java.lang.CharSequence mContentText -> c
    android.app.PendingIntent mContentIntent -> d
    android.app.PendingIntent mFullScreenIntent -> e
    android.widget.RemoteViews mTickerView -> f
    android.graphics.Bitmap mLargeIcon -> g
    java.lang.CharSequence mContentInfo -> h
    int mNumber -> i
    int mPriority -> j
    boolean mUseChronometer -> k
    android.support.v4.app.NotificationCompat$Style mStyle -> l
    java.lang.CharSequence mSubText -> m
    int mProgressMax -> n
    int mProgress -> o
    boolean mProgressIndeterminate -> p
    java.util.ArrayList mActions -> q
    android.app.Notification mNotification -> r
    android.support.v4.app.NotificationCompat$Builder setWhen(long) -> a
    android.support.v4.app.NotificationCompat$Builder setUsesChronometer(boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setSmallIcon(int) -> a
    android.support.v4.app.NotificationCompat$Builder setSmallIcon(int,int) -> a
    android.support.v4.app.NotificationCompat$Builder setContentTitle(java.lang.CharSequence) -> a
    android.support.v4.app.NotificationCompat$Builder setContentText(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$Builder setSubText(java.lang.CharSequence) -> c
    android.support.v4.app.NotificationCompat$Builder setNumber(int) -> b
    android.support.v4.app.NotificationCompat$Builder setContentInfo(java.lang.CharSequence) -> d
    android.support.v4.app.NotificationCompat$Builder setProgress(int,int,boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setContent(android.widget.RemoteViews) -> a
    android.support.v4.app.NotificationCompat$Builder setContentIntent(android.app.PendingIntent) -> a
    android.support.v4.app.NotificationCompat$Builder setDeleteIntent(android.app.PendingIntent) -> b
    android.support.v4.app.NotificationCompat$Builder setFullScreenIntent(android.app.PendingIntent,boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setTicker(java.lang.CharSequence) -> e
    android.support.v4.app.NotificationCompat$Builder setTicker(java.lang.CharSequence,android.widget.RemoteViews) -> a
    android.support.v4.app.NotificationCompat$Builder setLargeIcon(android.graphics.Bitmap) -> a
    android.support.v4.app.NotificationCompat$Builder setSound(android.net.Uri) -> a
    android.support.v4.app.NotificationCompat$Builder setSound(android.net.Uri,int) -> a
    android.support.v4.app.NotificationCompat$Builder setVibrate(long[]) -> a
    android.support.v4.app.NotificationCompat$Builder setLights(int,int,int) -> a
    android.support.v4.app.NotificationCompat$Builder setOngoing(boolean) -> b
    android.support.v4.app.NotificationCompat$Builder setOnlyAlertOnce(boolean) -> c
    android.support.v4.app.NotificationCompat$Builder setAutoCancel(boolean) -> d
    android.support.v4.app.NotificationCompat$Builder setDefaults(int) -> c
    void setFlag(int,boolean) -> a
    android.support.v4.app.NotificationCompat$Builder setPriority(int) -> d
    android.support.v4.app.NotificationCompat$Builder addAction(int,java.lang.CharSequence,android.app.PendingIntent) -> a
    android.support.v4.app.NotificationCompat$Builder setStyle(android.support.v4.app.NotificationCompat$Style) -> a
    android.app.Notification getNotification() -> a
    android.app.Notification build() -> b
android.support.v4.app.NotificationCompat$InboxStyle -> android.support.v4.app.bl:
    java.util.ArrayList mTexts -> a
    android.support.v4.app.NotificationCompat$InboxStyle setBigContentTitle(java.lang.CharSequence) -> a
    android.support.v4.app.NotificationCompat$InboxStyle setSummaryText(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$InboxStyle addLine(java.lang.CharSequence) -> c
android.support.v4.app.NotificationCompat$NotificationCompatImpl -> android.support.v4.app.bm:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplBase -> android.support.v4.app.bn:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplHoneycomb -> android.support.v4.app.bo:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplIceCreamSandwich -> android.support.v4.app.bp:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplJellybean -> android.support.v4.app.bq:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$Style -> android.support.v4.app.br:
    android.support.v4.app.NotificationCompat$Builder mBuilder -> d
    java.lang.CharSequence mBigContentTitle -> e
    java.lang.CharSequence mSummaryText -> f
    boolean mSummaryTextSet -> g
    void setBuilder(android.support.v4.app.NotificationCompat$Builder) -> a
    android.app.Notification build() -> a
android.support.v4.app.NotificationCompatHoneycomb -> android.support.v4.app.bs:
    android.app.Notification add(android.content.Context,android.app.Notification,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,android.widget.RemoteViews,int,android.app.PendingIntent,android.app.PendingIntent,android.graphics.Bitmap) -> a
android.support.v4.app.NotificationCompatIceCreamSandwich -> android.support.v4.app.bt:
    android.app.Notification add(android.content.Context,android.app.Notification,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,android.widget.RemoteViews,int,android.app.PendingIntent,android.app.PendingIntent,android.graphics.Bitmap,int,int,boolean) -> a
android.support.v4.app.NotificationCompatJellybean -> android.support.v4.app.bu:
    android.app.Notification$Builder b -> a
    void addAction(int,java.lang.CharSequence,android.app.PendingIntent) -> a
    void addBigTextStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,java.lang.CharSequence) -> a
    void addBigPictureStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,android.graphics.Bitmap,android.graphics.Bitmap,boolean) -> a
    void addInboxStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,java.util.ArrayList) -> a
    android.app.Notification build() -> a
android.support.v4.app.ServiceCompat -> android.support.v4.app.bv:
    int START_STICKY -> a
android.support.v4.app.ShareCompat -> android.support.v4.app.bw:
    java.lang.String EXTRA_CALLING_PACKAGE -> a
    java.lang.String EXTRA_CALLING_ACTIVITY -> b
    android.support.v4.app.ShareCompat$ShareCompatImpl IMPL -> c
    java.lang.String getCallingPackage(android.app.Activity) -> a
    android.content.ComponentName getCallingActivity(android.app.Activity) -> b
    void configureMenuItem(android.view.MenuItem,android.support.v4.app.ShareCompat$IntentBuilder) -> a
    void configureMenuItem(android.view.Menu,int,android.support.v4.app.ShareCompat$IntentBuilder) -> a
    android.support.v4.app.ShareCompat$ShareCompatImpl access$000() -> a
android.support.v4.app.ShareCompat$IntentBuilder -> android.support.v4.app.bx:
    android.app.Activity mActivity -> a
    android.content.Intent mIntent -> b
    java.lang.CharSequence mChooserTitle -> c
    java.util.ArrayList mToAddresses -> d
    java.util.ArrayList mCcAddresses -> e
    java.util.ArrayList mBccAddresses -> f
    java.util.ArrayList mStreams -> g
    android.support.v4.app.ShareCompat$IntentBuilder from(android.app.Activity) -> a
    android.content.Intent getIntent() -> a
    android.app.Activity getActivity() -> b
    void combineArrayExtra(java.lang.String,java.util.ArrayList) -> a
    void combineArrayExtra(java.lang.String,java.lang.String[]) -> a
    android.content.Intent createChooserIntent() -> c
    void startChooser() -> d
    android.support.v4.app.ShareCompat$IntentBuilder setChooserTitle(java.lang.CharSequence) -> a
    android.support.v4.app.ShareCompat$IntentBuilder setChooserTitle(int) -> a
    android.support.v4.app.ShareCompat$IntentBuilder setType(java.lang.String) -> a
    android.support.v4.app.ShareCompat$IntentBuilder setText(java.lang.CharSequence) -> b
    android.support.v4.app.ShareCompat$IntentBuilder setHtmlText(java.lang.String) -> b
    android.support.v4.app.ShareCompat$IntentBuilder setStream(android.net.Uri) -> a
    android.support.v4.app.ShareCompat$IntentBuilder addStream(android.net.Uri) -> b
    android.support.v4.app.ShareCompat$IntentBuilder setEmailTo(java.lang.String[]) -> a
    android.support.v4.app.ShareCompat$IntentBuilder addEmailTo(java.lang.String) -> c
    android.support.v4.app.ShareCompat$IntentBuilder addEmailTo(java.lang.String[]) -> b
    android.support.v4.app.ShareCompat$IntentBuilder setEmailCc(java.lang.String[]) -> c
    android.support.v4.app.ShareCompat$IntentBuilder addEmailCc(java.lang.String) -> d
    android.support.v4.app.ShareCompat$IntentBuilder addEmailCc(java.lang.String[]) -> d
    android.support.v4.app.ShareCompat$IntentBuilder setEmailBcc(java.lang.String[]) -> e
    android.support.v4.app.ShareCompat$IntentBuilder addEmailBcc(java.lang.String) -> e
    android.support.v4.app.ShareCompat$IntentBuilder addEmailBcc(java.lang.String[]) -> f
    android.support.v4.app.ShareCompat$IntentBuilder setSubject(java.lang.String) -> f
android.support.v4.app.ShareCompat$IntentReader -> android.support.v4.app.by:
    java.lang.String TAG -> a
    android.app.Activity mActivity -> b
    android.content.Intent mIntent -> c
    java.lang.String mCallingPackage -> d
    android.content.ComponentName mCallingActivity -> e
    java.util.ArrayList mStreams -> f
    android.support.v4.app.ShareCompat$IntentReader from(android.app.Activity) -> a
    boolean isShareIntent() -> a
    boolean isSingleShare() -> b
    boolean isMultipleShare() -> c
    java.lang.String getType() -> d
    java.lang.CharSequence getText() -> e
    java.lang.String getHtmlText() -> f
    android.net.Uri getStream() -> g
    android.net.Uri getStream(int) -> a
    int getStreamCount() -> h
    java.lang.String[] getEmailTo() -> i
    java.lang.String[] getEmailCc() -> j
    java.lang.String[] getEmailBcc() -> k
    java.lang.String getSubject() -> l
    java.lang.String getCallingPackage() -> m
    android.content.ComponentName getCallingActivity() -> n
    android.graphics.drawable.Drawable getCallingActivityIcon() -> o
    android.graphics.drawable.Drawable getCallingApplicationIcon() -> p
    java.lang.CharSequence getCallingApplicationLabel() -> q
android.support.v4.app.ShareCompat$ShareCompatImpl -> android.support.v4.app.bz:
    void configureMenuItem(android.view.MenuItem,android.support.v4.app.ShareCompat$IntentBuilder) -> a
    java.lang.String escapeHtml(java.lang.CharSequence) -> a
android.support.v4.app.ShareCompat$ShareCompatImplBase -> android.support.v4.app.ca:
    void configureMenuItem(android.view.MenuItem,android.support.v4.app.ShareCompat$IntentBuilder) -> a
    java.lang.String escapeHtml(java.lang.CharSequence) -> a
    void withinStyle(java.lang.StringBuilder,java.lang.CharSequence,int,int) -> a
android.support.v4.app.ShareCompat$ShareCompatImplICS -> android.support.v4.app.cb:
    void configureMenuItem(android.view.MenuItem,android.support.v4.app.ShareCompat$IntentBuilder) -> a
    boolean shouldAddChooserIntent(android.view.MenuItem) -> a
android.support.v4.app.ShareCompat$ShareCompatImplJB -> android.support.v4.app.cc:
    java.lang.String escapeHtml(java.lang.CharSequence) -> a
    boolean shouldAddChooserIntent(android.view.MenuItem) -> a
android.support.v4.app.ShareCompatICS -> android.support.v4.app.cd:
    java.lang.String HISTORY_FILENAME_PREFIX -> a
    void configureMenuItem(android.view.MenuItem,android.app.Activity,android.content.Intent) -> a
android.support.v4.app.ShareCompatJB -> android.support.v4.app.ce:
    java.lang.String escapeHtml(java.lang.CharSequence) -> a
android.support.v4.app.SuperNotCalledException -> android.support.v4.app.cf:
android.support.v4.app.TaskStackBuilder -> android.support.v4.app.cg:
    java.lang.String TAG -> a
    android.support.v4.app.TaskStackBuilder$TaskStackBuilderImpl IMPL -> b
    java.util.ArrayList mIntents -> c
    android.content.Context mSourceContext -> d
    android.support.v4.app.TaskStackBuilder create(android.content.Context) -> a
    android.support.v4.app.TaskStackBuilder from(android.content.Context) -> b
    android.support.v4.app.TaskStackBuilder addNextIntent(android.content.Intent) -> a
    android.support.v4.app.TaskStackBuilder addNextIntentWithParentStack(android.content.Intent) -> b
    android.support.v4.app.TaskStackBuilder addParentStack(android.app.Activity) -> a
    android.support.v4.app.TaskStackBuilder addParentStack(java.lang.Class) -> a
    android.support.v4.app.TaskStackBuilder addParentStack(android.content.ComponentName) -> a
    int getIntentCount() -> a
    android.content.Intent getIntent(int) -> a
    android.content.Intent editIntentAt(int) -> b
    java.util.Iterator iterator() -> iterator
    void startActivities() -> b
    void startActivities(android.os.Bundle) -> a
    android.app.PendingIntent getPendingIntent(int,int) -> a
    android.app.PendingIntent getPendingIntent(int,int,android.os.Bundle) -> a
    android.content.Intent[] getIntents() -> c
android.support.v4.app.TaskStackBuilder$TaskStackBuilderImpl -> android.support.v4.app.ch:
    android.app.PendingIntent getPendingIntent(android.content.Context,android.content.Intent[],int,int,android.os.Bundle) -> a
android.support.v4.app.TaskStackBuilder$TaskStackBuilderImplBase -> android.support.v4.app.ci:
    android.app.PendingIntent getPendingIntent(android.content.Context,android.content.Intent[],int,int,android.os.Bundle) -> a
android.support.v4.app.TaskStackBuilder$TaskStackBuilderImplHoneycomb -> android.support.v4.app.cj:
    android.app.PendingIntent getPendingIntent(android.content.Context,android.content.Intent[],int,int,android.os.Bundle) -> a
android.support.v4.app.TaskStackBuilder$TaskStackBuilderImplJellybean -> android.support.v4.app.ck:
    android.app.PendingIntent getPendingIntent(android.content.Context,android.content.Intent[],int,int,android.os.Bundle) -> a
android.support.v4.app.TaskStackBuilderHoneycomb -> android.support.v4.app.cl:
    android.app.PendingIntent getActivitiesPendingIntent(android.content.Context,int,android.content.Intent[],int) -> a
android.support.v4.app.TaskStackBuilderJellybean -> android.support.v4.app.cm:
    android.app.PendingIntent getActivitiesPendingIntent(android.content.Context,int,android.content.Intent[],int,android.os.Bundle) -> a
android.support.v4.content.AsyncTaskLoader -> android.support.v4.b.a:
    java.lang.String TAG -> a
    boolean DEBUG -> b
    android.support.v4.content.AsyncTaskLoader$LoadTask mTask -> c
    android.support.v4.content.AsyncTaskLoader$LoadTask mCancellingTask -> d
    long mUpdateThrottle -> e
    long mLastLoadCompleteTime -> f
    android.os.Handler mHandler -> g
    void setUpdateThrottle(long) -> a
    void onForceLoad() -> a
    boolean cancelLoad() -> b
    void onCanceled(java.lang.Object) -> a
    void executePendingTask() -> c
    void dispatchOnCancelled(android.support.v4.content.AsyncTaskLoader$LoadTask,java.lang.Object) -> a
    void dispatchOnLoadComplete(android.support.v4.content.AsyncTaskLoader$LoadTask,java.lang.Object) -> b
    java.lang.Object loadInBackground() -> d
    java.lang.Object onLoadInBackground() -> e
    void waitForLoader() -> f
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.content.AsyncTaskLoader$LoadTask -> android.support.v4.b.b:
    java.lang.Object result -> a
    boolean waiting -> b
    java.util.concurrent.CountDownLatch done -> e
    android.support.v4.content.AsyncTaskLoader this$0 -> c
    java.lang.Object doInBackground(java.lang.Void[]) -> a
    void onPostExecute(java.lang.Object) -> a
    void onCancelled() -> a
    void run() -> run
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    java.util.concurrent.CountDownLatch access$000(android.support.v4.content.AsyncTaskLoader$LoadTask) -> a
android.support.v4.content.ContextCompat -> android.support.v4.b.c:
    boolean startActivities(android.content.Context,android.content.Intent[]) -> a
    boolean startActivities(android.content.Context,android.content.Intent[],android.os.Bundle) -> a
android.support.v4.content.ContextCompatHoneycomb -> android.support.v4.b.d:
    void startActivities(android.content.Context,android.content.Intent[]) -> a
android.support.v4.content.ContextCompatJellybean -> android.support.v4.b.e:
    void startActivities(android.content.Context,android.content.Intent[],android.os.Bundle) -> a
android.support.v4.content.CursorLoader -> android.support.v4.b.f:
    android.support.v4.content.Loader$ForceLoadContentObserver mObserver -> h
    android.net.Uri mUri -> i
    java.lang.String[] mProjection -> j
    java.lang.String mSelection -> k
    java.lang.String[] mSelectionArgs -> l
    java.lang.String mSortOrder -> m
    android.database.Cursor mCursor -> n
    android.database.Cursor loadInBackground() -> g
    void registerContentObserver(android.database.Cursor,android.database.ContentObserver) -> a
    void deliverResult(android.database.Cursor) -> a
    void onStartLoading() -> h
    void onStopLoading() -> i
    void onCanceled(android.database.Cursor) -> b
    void onReset() -> j
    android.net.Uri getUri() -> k
    void setUri(android.net.Uri) -> a
    java.lang.String[] getProjection() -> l
    void setProjection(java.lang.String[]) -> a
    java.lang.String getSelection() -> m
    void setSelection(java.lang.String) -> a
    java.lang.String[] getSelectionArgs() -> n
    void setSelectionArgs(java.lang.String[]) -> b
    java.lang.String getSortOrder() -> o
    void setSortOrder(java.lang.String) -> b
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    java.lang.Object loadInBackground() -> d
    void onCanceled(java.lang.Object) -> a
    void deliverResult(java.lang.Object) -> b
android.support.v4.content.FileProvider -> android.support.v4.b.g:
    java.lang.String[] COLUMNS -> a
    java.lang.String META_DATA_FILE_PROVIDER_PATHS -> b
    java.lang.String TAG_ROOT_PATH -> c
    java.lang.String TAG_FILES_PATH -> d
    java.lang.String TAG_CACHE_PATH -> e
    java.lang.String TAG_EXTERNAL -> f
    java.lang.String ATTR_NAME -> g
    java.lang.String ATTR_PATH -> h
    java.io.File DEVICE_ROOT -> i
    java.util.HashMap sCache -> j
    android.support.v4.content.FileProvider$PathStrategy mStrategy -> k
    boolean onCreate() -> onCreate
    void attachInfo(android.content.Context,android.content.pm.ProviderInfo) -> attachInfo
    android.net.Uri getUriForFile(android.content.Context,java.lang.String,java.io.File) -> a
    android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String) -> query
    java.lang.String getType(android.net.Uri) -> getType
    android.net.Uri insert(android.net.Uri,android.content.ContentValues) -> insert
    int update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[]) -> update
    int delete(android.net.Uri,java.lang.String,java.lang.String[]) -> delete
    android.os.ParcelFileDescriptor openFile(android.net.Uri,java.lang.String) -> openFile
    android.support.v4.content.FileProvider$PathStrategy getPathStrategy(android.content.Context,java.lang.String) -> a
    android.support.v4.content.FileProvider$PathStrategy parsePathStrategy(android.content.Context,java.lang.String) -> b
    int modeToMode(java.lang.String) -> a
    java.io.File buildPath(java.io.File,java.lang.String[]) -> a
    java.lang.String[] copyOf(java.lang.String[],int) -> a
    java.lang.Object[] copyOf(java.lang.Object[],int) -> a
android.support.v4.content.FileProvider$PathStrategy -> android.support.v4.b.h:
    android.net.Uri getUriForFile(java.io.File) -> a
    java.io.File getFileForUri(android.net.Uri) -> a
android.support.v4.content.FileProvider$SimplePathStrategy -> android.support.v4.b.i:
    java.lang.String mAuthority -> a
    java.util.HashMap mRoots -> b
    void addRoot(java.lang.String,java.io.File) -> a
    android.net.Uri getUriForFile(java.io.File) -> a
    java.io.File getFileForUri(android.net.Uri) -> a
android.support.v4.content.IntentCompat -> android.support.v4.b.j:
    android.support.v4.content.IntentCompat$IntentCompatImpl IMPL -> h
    java.lang.String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE -> a
    java.lang.String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE -> b
    java.lang.String EXTRA_CHANGED_PACKAGE_LIST -> c
    java.lang.String EXTRA_CHANGED_UID_LIST -> d
    java.lang.String EXTRA_HTML_TEXT -> e
    int FLAG_ACTIVITY_TASK_ON_HOME -> f
    int FLAG_ACTIVITY_CLEAR_TASK -> g
    android.content.Intent makeMainActivity(android.content.ComponentName) -> a
    android.content.Intent makeMainSelectorActivity(java.lang.String,java.lang.String) -> a
    android.content.Intent makeRestartActivityTask(android.content.ComponentName) -> b
android.support.v4.content.IntentCompat$IntentCompatImpl -> android.support.v4.b.k:
    android.content.Intent makeMainActivity(android.content.ComponentName) -> a
    android.content.Intent makeMainSelectorActivity(java.lang.String,java.lang.String) -> a
    android.content.Intent makeRestartActivityTask(android.content.ComponentName) -> b
android.support.v4.content.IntentCompat$IntentCompatImplBase -> android.support.v4.b.l:
    android.content.Intent makeMainActivity(android.content.ComponentName) -> a
    android.content.Intent makeMainSelectorActivity(java.lang.String,java.lang.String) -> a
    android.content.Intent makeRestartActivityTask(android.content.ComponentName) -> b
android.support.v4.content.IntentCompat$IntentCompatImplHC -> android.support.v4.b.m:
    android.content.Intent makeMainActivity(android.content.ComponentName) -> a
    android.content.Intent makeRestartActivityTask(android.content.ComponentName) -> b
android.support.v4.content.IntentCompat$IntentCompatImplIcsMr1 -> android.support.v4.b.n:
    android.content.Intent makeMainSelectorActivity(java.lang.String,java.lang.String) -> a
android.support.v4.content.IntentCompatHoneycomb -> android.support.v4.b.o:
    android.content.Intent makeMainActivity(android.content.ComponentName) -> a
    android.content.Intent makeRestartActivityTask(android.content.ComponentName) -> b
android.support.v4.content.IntentCompatIcsMr1 -> android.support.v4.b.p:
    android.content.Intent makeMainSelectorActivity(java.lang.String,java.lang.String) -> a
android.support.v4.content.Loader -> android.support.v4.b.q:
    int mId -> o
    android.support.v4.content.Loader$OnLoadCompleteListener mListener -> p
    android.content.Context mContext -> q
    boolean mStarted -> r
    boolean mAbandoned -> s
    boolean mReset -> t
    boolean mContentChanged -> u
    void deliverResult(java.lang.Object) -> b
    android.content.Context getContext() -> p
    int getId() -> q
    void registerListener(int,android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void unregisterListener(android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    boolean isStarted() -> r
    boolean isAbandoned() -> s
    boolean isReset() -> t
    void startLoading() -> u
    void onStartLoading() -> h
    void forceLoad() -> v
    void onForceLoad() -> a
    void stopLoading() -> w
    void onStopLoading() -> i
    void abandon() -> x
    void onAbandon() -> y
    void reset() -> z
    void onReset() -> j
    boolean takeContentChanged() -> A
    void onContentChanged() -> B
    java.lang.String dataToString(java.lang.Object) -> c
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.content.Loader$ForceLoadContentObserver -> android.support.v4.b.r:
    android.support.v4.content.Loader this$0 -> a
    boolean deliverSelfNotifications() -> deliverSelfNotifications
    void onChange(boolean) -> onChange
android.support.v4.content.Loader$OnLoadCompleteListener -> android.support.v4.b.s:
    void onLoadComplete(android.support.v4.content.Loader,java.lang.Object) -> a
android.support.v4.content.LocalBroadcastManager -> android.support.v4.b.t:
    java.lang.String TAG -> b
    boolean DEBUG -> c
    android.content.Context mAppContext -> d
    java.util.HashMap mReceivers -> e
    java.util.HashMap mActions -> f
    java.util.ArrayList mPendingBroadcasts -> g
    int MSG_EXEC_PENDING_BROADCASTS -> a
    android.os.Handler mHandler -> h
    java.lang.Object mLock -> i
    android.support.v4.content.LocalBroadcastManager mInstance -> j
    android.support.v4.content.LocalBroadcastManager getInstance(android.content.Context) -> a
    void registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter) -> a
    void unregisterReceiver(android.content.BroadcastReceiver) -> a
    boolean sendBroadcast(android.content.Intent) -> a
    void sendBroadcastSync(android.content.Intent) -> b
    void executePendingBroadcasts() -> a
    void access$000(android.support.v4.content.LocalBroadcastManager) -> a
android.support.v4.content.LocalBroadcastManager$1 -> android.support.v4.b.u:
    android.support.v4.content.LocalBroadcastManager this$0 -> a
    void handleMessage(android.os.Message) -> handleMessage
android.support.v4.content.LocalBroadcastManager$BroadcastRecord -> android.support.v4.b.v:
    android.content.Intent intent -> a
    java.util.ArrayList receivers -> b
android.support.v4.content.LocalBroadcastManager$ReceiverRecord -> android.support.v4.b.w:
    android.content.IntentFilter filter -> a
    android.content.BroadcastReceiver receiver -> b
    boolean broadcasting -> c
    java.lang.String toString() -> toString
android.support.v4.content.ModernAsyncTask -> android.support.v4.b.x:
    java.lang.String LOG_TAG -> a
    int CORE_POOL_SIZE -> b
    int MAXIMUM_POOL_SIZE -> c
    int KEEP_ALIVE -> e
    java.util.concurrent.ThreadFactory sThreadFactory -> f
    java.util.concurrent.BlockingQueue sPoolWorkQueue -> g
    java.util.concurrent.Executor THREAD_POOL_EXECUTOR -> d
    int MESSAGE_POST_RESULT -> h
    int MESSAGE_POST_PROGRESS -> i
    android.support.v4.content.ModernAsyncTask$InternalHandler sHandler -> j
    java.util.concurrent.Executor sDefaultExecutor -> k
    android.support.v4.content.ModernAsyncTask$WorkerRunnable mWorker -> l
    java.util.concurrent.FutureTask mFuture -> m
    android.support.v4.content.ModernAsyncTask$Status mStatus -> n
    java.util.concurrent.atomic.AtomicBoolean mTaskInvoked -> o
    void init() -> b
    void setDefaultExecutor(java.util.concurrent.Executor) -> a
    void postResultIfNotInvoked(java.lang.Object) -> c
    java.lang.Object postResult(java.lang.Object) -> d
    android.support.v4.content.ModernAsyncTask$Status getStatus() -> c
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    void onPreExecute() -> d
    void onPostExecute(java.lang.Object) -> a
    void onProgressUpdate(java.lang.Object[]) -> b
    void onCancelled(java.lang.Object) -> b
    void onCancelled() -> a
    boolean isCancelled() -> e
    boolean cancel(boolean) -> a
    java.lang.Object get() -> f
    java.lang.Object get(long,java.util.concurrent.TimeUnit) -> a
    android.support.v4.content.ModernAsyncTask execute(java.lang.Object[]) -> c
    android.support.v4.content.ModernAsyncTask executeOnExecutor(java.util.concurrent.Executor,java.lang.Object[]) -> a
    void execute(java.lang.Runnable) -> a
    void publishProgress(java.lang.Object[]) -> d
    void finish(java.lang.Object) -> e
    java.util.concurrent.atomic.AtomicBoolean access$200(android.support.v4.content.ModernAsyncTask) -> a
    java.lang.Object access$300(android.support.v4.content.ModernAsyncTask,java.lang.Object) -> a
    void access$400(android.support.v4.content.ModernAsyncTask,java.lang.Object) -> b
    void access$500(android.support.v4.content.ModernAsyncTask,java.lang.Object) -> c
android.support.v4.content.ModernAsyncTask$1 -> android.support.v4.b.y:
    java.util.concurrent.atomic.AtomicInteger mCount -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
android.support.v4.content.ModernAsyncTask$2 -> android.support.v4.b.z:
    android.support.v4.content.ModernAsyncTask this$0 -> a
    java.lang.Object call() -> call
android.support.v4.content.ModernAsyncTask$3 -> android.support.v4.b.aa:
    android.support.v4.content.ModernAsyncTask this$0 -> a
    void done() -> done
android.support.v4.content.ModernAsyncTask$4 -> android.support.v4.b.ab:
    int[] $SwitchMap$android$support$v4$content$ModernAsyncTask$Status -> a
android.support.v4.content.ModernAsyncTask$AsyncTaskResult -> android.support.v4.b.ac:
    android.support.v4.content.ModernAsyncTask mTask -> a
    java.lang.Object[] mData -> b
android.support.v4.content.ModernAsyncTask$InternalHandler -> android.support.v4.b.ad:
    void handleMessage(android.os.Message) -> handleMessage
android.support.v4.content.ModernAsyncTask$Status -> android.support.v4.b.ae:
    android.support.v4.content.ModernAsyncTask$Status PENDING -> a
    android.support.v4.content.ModernAsyncTask$Status RUNNING -> b
    android.support.v4.content.ModernAsyncTask$Status FINISHED -> c
    android.support.v4.content.ModernAsyncTask$Status[] $VALUES -> d
    android.support.v4.content.ModernAsyncTask$Status[] values() -> values
    android.support.v4.content.ModernAsyncTask$Status valueOf(java.lang.String) -> valueOf
android.support.v4.content.ModernAsyncTask$WorkerRunnable -> android.support.v4.b.af:
    java.lang.Object[] mParams -> b
android.support.v4.content.pm.ActivityInfoCompat -> android.support.v4.b.a.a:
    int CONFIG_UI_MODE -> a
android.support.v4.database.DatabaseUtilsCompat -> android.support.v4.c.a:
    java.lang.String concatenateWhere(java.lang.String,java.lang.String) -> a
    java.lang.String[] appendSelectionArgs(java.lang.String[],java.lang.String[]) -> a
android.support.v4.net.ConnectivityManagerCompat -> android.support.v4.d.a:
    android.support.v4.net.ConnectivityManagerCompat$ConnectivityManagerCompatImpl IMPL -> a
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
    android.net.NetworkInfo getNetworkInfoFromBroadcast(android.net.ConnectivityManager,android.content.Intent) -> a
android.support.v4.net.ConnectivityManagerCompat$BaseConnectivityManagerCompatImpl -> android.support.v4.d.b:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompat$ConnectivityManagerCompatImpl -> android.support.v4.d.c:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompat$GingerbreadConnectivityManagerCompatImpl -> android.support.v4.d.d:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompat$HoneycombMR2ConnectivityManagerCompatImpl -> android.support.v4.d.e:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompat$JellyBeanConnectivityManagerCompatImpl -> android.support.v4.d.f:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompatGingerbread -> android.support.v4.d.g:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompatHoneycombMR2 -> android.support.v4.d.h:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.ConnectivityManagerCompatJellyBean -> android.support.v4.d.i:
    boolean isActiveNetworkMetered(android.net.ConnectivityManager) -> a
android.support.v4.net.TrafficStatsCompat -> android.support.v4.d.j:
    android.support.v4.net.TrafficStatsCompat$TrafficStatsCompatImpl IMPL -> a
    void clearThreadStatsTag() -> a
    int getThreadStatsTag() -> b
    void incrementOperationCount(int) -> a
    void incrementOperationCount(int,int) -> a
    void setThreadStatsTag(int) -> b
    void tagSocket(java.net.Socket) -> a
    void untagSocket(java.net.Socket) -> b
android.support.v4.net.TrafficStatsCompat$1 -> android.support.v4.d.k:
android.support.v4.net.TrafficStatsCompat$BaseTrafficStatsCompatImpl -> android.support.v4.d.l:
    java.lang.ThreadLocal mThreadSocketTags -> a
    void clearThreadStatsTag() -> a
    int getThreadStatsTag() -> b
    void incrementOperationCount(int) -> a
    void incrementOperationCount(int,int) -> a
    void setThreadStatsTag(int) -> b
    void tagSocket(java.net.Socket) -> a
    void untagSocket(java.net.Socket) -> b
android.support.v4.net.TrafficStatsCompat$BaseTrafficStatsCompatImpl$1 -> android.support.v4.d.m:
    android.support.v4.net.TrafficStatsCompat$BaseTrafficStatsCompatImpl this$0 -> a
    android.support.v4.net.TrafficStatsCompat$BaseTrafficStatsCompatImpl$SocketTags initialValue() -> a
    java.lang.Object initialValue() -> initialValue
android.support.v4.net.TrafficStatsCompat$BaseTrafficStatsCompatImpl$SocketTags -> android.support.v4.d.n:
    int statsTag -> a
android.support.v4.net.TrafficStatsCompat$IcsTrafficStatsCompatImpl -> android.support.v4.d.o:
    void clearThreadStatsTag() -> a
    int getThreadStatsTag() -> b
    void incrementOperationCount(int) -> a
    void incrementOperationCount(int,int) -> a
    void setThreadStatsTag(int) -> b
    void tagSocket(java.net.Socket) -> a
    void untagSocket(java.net.Socket) -> b
android.support.v4.net.TrafficStatsCompat$TrafficStatsCompatImpl -> android.support.v4.d.p:
    void clearThreadStatsTag() -> a
    int getThreadStatsTag() -> b
    void incrementOperationCount(int) -> a
    void incrementOperationCount(int,int) -> a
    void setThreadStatsTag(int) -> b
    void tagSocket(java.net.Socket) -> a
    void untagSocket(java.net.Socket) -> b
android.support.v4.net.TrafficStatsCompatIcs -> android.support.v4.d.q:
    void clearThreadStatsTag() -> a
    int getThreadStatsTag() -> b
    void incrementOperationCount(int) -> a
    void incrementOperationCount(int,int) -> a
    void setThreadStatsTag(int) -> b
    void tagSocket(java.net.Socket) -> a
    void untagSocket(java.net.Socket) -> b
android.support.v4.os.ParcelableCompat -> android.support.v4.e.a:
    android.os.Parcelable$Creator newCreator(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.os.ParcelableCompat$CompatCreator -> android.support.v4.e.b:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorCallbacks -> android.support.v4.e.c:
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
    java.lang.Object[] newArray(int) -> a
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2 -> android.support.v4.e.d:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2Stub -> android.support.v4.e.e:
    android.os.Parcelable$Creator instantiate(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.util.AtomicFile -> android.support.v4.f.a:
    java.io.File mBaseName -> a
    java.io.File mBackupName -> b
    java.io.File getBaseFile() -> a
    void delete() -> b
    java.io.FileOutputStream startWrite() -> c
    void finishWrite(java.io.FileOutputStream) -> a
    void failWrite(java.io.FileOutputStream) -> b
    java.io.FileInputStream openRead() -> d
    byte[] readFully() -> e
    boolean sync(java.io.FileOutputStream) -> c
android.support.v4.util.DebugUtils -> android.support.v4.f.b:
    void buildShortClassTag(java.lang.Object,java.lang.StringBuilder) -> a
android.support.v4.util.LogWriter -> android.support.v4.f.c:
    java.lang.String mTag -> a
    java.lang.StringBuilder mBuilder -> b
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
android.support.v4.util.LongSparseArray -> android.support.v4.f.d:
    java.lang.Object DELETED -> a
    boolean mGarbage -> b
    long[] mKeys -> c
    java.lang.Object[] mValues -> d
    int mSize -> e
    android.support.v4.util.LongSparseArray clone() -> a
    java.lang.Object get(long) -> a
    java.lang.Object get(long,java.lang.Object) -> a
    void delete(long) -> b
    void remove(long) -> c
    void removeAt(int) -> a
    void gc() -> d
    void put(long,java.lang.Object) -> b
    int size() -> b
    long keyAt(int) -> b
    java.lang.Object valueAt(int) -> c
    void setValueAt(int,java.lang.Object) -> a
    int indexOfKey(long) -> d
    int indexOfValue(java.lang.Object) -> a
    void clear() -> c
    void append(long,java.lang.Object) -> c
    int binarySearch(long[],int,int,long) -> a
    int idealByteArraySize(int) -> d
    int idealLongArraySize(int) -> e
    java.lang.Object clone() -> clone
android.support.v4.util.LruCache -> android.support.v4.f.e:
    java.util.LinkedHashMap map -> a
    int size -> b
    int maxSize -> c
    int putCount -> d
    int createCount -> e
    int evictionCount -> f
    int hitCount -> g
    int missCount -> h
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    void trimToSize(int) -> a
    java.lang.Object remove(java.lang.Object) -> b
    void entryRemoved(boolean,java.lang.Object,java.lang.Object,java.lang.Object) -> a
    java.lang.Object create(java.lang.Object) -> c
    int safeSizeOf(java.lang.Object,java.lang.Object) -> c
    int sizeOf(java.lang.Object,java.lang.Object) -> b
    void evictAll() -> a
    int size() -> b
    int maxSize() -> c
    int hitCount() -> d
    int missCount() -> e
    int createCount() -> f
    int putCount() -> g
    int evictionCount() -> h
    java.util.Map snapshot() -> i
    java.lang.String toString() -> toString
android.support.v4.util.SparseArrayCompat -> android.support.v4.f.f:
    java.lang.Object DELETED -> a
    boolean mGarbage -> b
    int[] mKeys -> c
    java.lang.Object[] mValues -> d
    int mSize -> e
    java.lang.Object get(int) -> a
    java.lang.Object get(int,java.lang.Object) -> a
    void delete(int) -> b
    void remove(int) -> c
    void removeAt(int) -> d
    void removeAtRange(int,int) -> a
    void gc() -> c
    void put(int,java.lang.Object) -> b
    int size() -> a
    int keyAt(int) -> e
    java.lang.Object valueAt(int) -> f
    void setValueAt(int,java.lang.Object) -> c
    int indexOfKey(int) -> g
    int indexOfValue(java.lang.Object) -> a
    void clear() -> b
    void append(int,java.lang.Object) -> d
    int binarySearch(int[],int,int,int) -> a
    int idealByteArraySize(int) -> h
    int idealIntArraySize(int) -> i
android.support.v4.util.TimeUtils -> android.support.v4.f.g:
    int HUNDRED_DAY_FIELD_LEN -> a
    int SECONDS_PER_MINUTE -> b
    int SECONDS_PER_HOUR -> c
    int SECONDS_PER_DAY -> d
    java.lang.Object sFormatSync -> e
    char[] sFormatStr -> f
    int accumField(int,int,boolean,int) -> a
    int printField(char[],int,char,int,boolean,int) -> a
    int formatDurationLocked(long,int) -> a
    void formatDuration(long,java.lang.StringBuilder) -> a
    void formatDuration(long,java.io.PrintWriter,int) -> a
    void formatDuration(long,java.io.PrintWriter) -> a
    void formatDuration(long,long,java.io.PrintWriter) -> a
android.support.v4.view.AccessibilityDelegateCompat -> android.support.v4.view.a:
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateImpl IMPL -> b
    java.lang.Object DEFAULT_DELEGATE -> c
    java.lang.Object mBridge -> a
    java.lang.Object getBridge() -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl -> android.support.v4.view.b:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl$1 -> android.support.v4.view.c:
    android.support.v4.view.AccessibilityDelegateCompat val$compat -> a
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl this$0 -> b
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateImpl -> android.support.v4.view.d:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl -> android.support.v4.view.e:
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl$1 -> android.support.v4.view.f:
    android.support.v4.view.AccessibilityDelegateCompat val$compat -> a
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl this$0 -> b
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    java.lang.Object getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateStubImpl -> android.support.v4.view.g:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompatIcs -> android.support.v4.view.h:
    java.lang.Object newAccessibilityDelegateDefaultImpl() -> a
    java.lang.Object newAccessibilityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompatIcs$1 -> android.support.v4.view.i:
    android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge val$bridge -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onInitializeAccessibilityEvent
    void onInitializeAccessibilityNodeInfo(android.view.View,android.view.accessibility.AccessibilityNodeInfo) -> onInitializeAccessibilityNodeInfo
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onPopulateAccessibilityEvent
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> onRequestSendAccessibilityEvent
    void sendAccessibilityEvent(android.view.View,int) -> sendAccessibilityEvent
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> sendAccessibilityEventUnchecked
android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge -> android.support.v4.view.j:
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompatJellyBean -> android.support.v4.view.k:
    java.lang.Object newAccessibilityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean) -> a
    java.lang.Object getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompatJellyBean$1 -> android.support.v4.view.l:
    android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean val$bridge -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onInitializeAccessibilityEvent
    void onInitializeAccessibilityNodeInfo(android.view.View,android.view.accessibility.AccessibilityNodeInfo) -> onInitializeAccessibilityNodeInfo
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onPopulateAccessibilityEvent
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> onRequestSendAccessibilityEvent
    void sendAccessibilityEvent(android.view.View,int) -> sendAccessibilityEvent
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> sendAccessibilityEventUnchecked
    android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider(android.view.View) -> getAccessibilityNodeProvider
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> performAccessibilityAction
android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean -> android.support.v4.view.m:
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    java.lang.Object getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.GestureDetectorCompat -> android.support.v4.view.n:
    android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImpl mImpl -> a
    boolean isLongpressEnabled() -> a
    boolean onTouchEvent(android.view.MotionEvent) -> a
    void setIsLongpressEnabled(boolean) -> a
    void setOnDoubleTapListener(android.view.GestureDetector$OnDoubleTapListener) -> a
android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImpl -> android.support.v4.view.o:
    boolean isLongpressEnabled() -> a
    boolean onTouchEvent(android.view.MotionEvent) -> a
    void setIsLongpressEnabled(boolean) -> a
    void setOnDoubleTapListener(android.view.GestureDetector$OnDoubleTapListener) -> a
android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase -> android.support.v4.view.p:
    int mTouchSlopSquare -> a
    int mDoubleTapSlopSquare -> b
    int mMinimumFlingVelocity -> c
    int mMaximumFlingVelocity -> d
    int LONGPRESS_TIMEOUT -> e
    int TAP_TIMEOUT -> f
    int DOUBLE_TAP_TIMEOUT -> g
    int SHOW_PRESS -> h
    int LONG_PRESS -> i
    int TAP -> j
    android.os.Handler mHandler -> k
    android.view.GestureDetector$OnGestureListener mListener -> l
    android.view.GestureDetector$OnDoubleTapListener mDoubleTapListener -> m
    boolean mStillDown -> n
    boolean mDeferConfirmSingleTap -> o
    boolean mInLongPress -> p
    boolean mAlwaysInTapRegion -> q
    boolean mAlwaysInBiggerTapRegion -> r
    android.view.MotionEvent mCurrentDownEvent -> s
    android.view.MotionEvent mPreviousUpEvent -> t
    boolean mIsDoubleTapping -> u
    float mLastFocusX -> v
    float mLastFocusY -> w
    float mDownFocusX -> x
    float mDownFocusY -> y
    boolean mIsLongpressEnabled -> z
    android.view.VelocityTracker mVelocityTracker -> A
    void init(android.content.Context) -> a
    void setOnDoubleTapListener(android.view.GestureDetector$OnDoubleTapListener) -> a
    void setIsLongpressEnabled(boolean) -> a
    boolean isLongpressEnabled() -> a
    boolean onTouchEvent(android.view.MotionEvent) -> a
    void cancel() -> b
    void cancelTaps() -> c
    boolean isConsideredDoubleTap(android.view.MotionEvent,android.view.MotionEvent,android.view.MotionEvent) -> a
    void dispatchLongPress() -> d
    android.view.MotionEvent access$000(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase) -> a
    android.view.GestureDetector$OnGestureListener access$100(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase) -> b
    void access$200(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase) -> c
    android.view.GestureDetector$OnDoubleTapListener access$300(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase) -> d
    boolean access$400(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase) -> e
    boolean access$502(android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase,boolean) -> a
android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase$GestureHandler -> android.support.v4.view.q:
    android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplBase this$0 -> a
    void handleMessage(android.os.Message) -> handleMessage
android.support.v4.view.GestureDetectorCompat$GestureDetectorCompatImplJellybeanMr2 -> android.support.v4.view.r:
    android.view.GestureDetector mDetector -> a
    boolean isLongpressEnabled() -> a
    boolean onTouchEvent(android.view.MotionEvent) -> a
    void setIsLongpressEnabled(boolean) -> a
    void setOnDoubleTapListener(android.view.GestureDetector$OnDoubleTapListener) -> a
android.support.v4.view.GravityCompat -> android.support.v4.view.s:
    android.support.v4.view.GravityCompat$GravityCompatImpl IMPL -> a
    int RELATIVE_LAYOUT_DIRECTION -> b
    int START -> c
    int END -> d
    int RELATIVE_HORIZONTAL_GRAVITY_MASK -> e
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> a
    void apply(int,int,int,android.graphics.Rect,int,int,android.graphics.Rect,int) -> a
    void applyDisplay(int,android.graphics.Rect,android.graphics.Rect,int) -> a
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImpl -> android.support.v4.view.t:
    int getAbsoluteGravity(int,int) -> a
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> a
    void apply(int,int,int,android.graphics.Rect,int,int,android.graphics.Rect,int) -> a
    void applyDisplay(int,android.graphics.Rect,android.graphics.Rect,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImplBase -> android.support.v4.view.u:
    int getAbsoluteGravity(int,int) -> a
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> a
    void apply(int,int,int,android.graphics.Rect,int,int,android.graphics.Rect,int) -> a
    void applyDisplay(int,android.graphics.Rect,android.graphics.Rect,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImplJellybeanMr1 -> android.support.v4.view.v:
    int getAbsoluteGravity(int,int) -> a
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> a
    void apply(int,int,int,android.graphics.Rect,int,int,android.graphics.Rect,int) -> a
    void applyDisplay(int,android.graphics.Rect,android.graphics.Rect,int) -> a
android.support.v4.view.GravityCompatJellybeanMr1 -> android.support.v4.view.w:
    int getAbsoluteGravity(int,int) -> a
    void apply(int,int,int,android.graphics.Rect,android.graphics.Rect,int) -> a
    void apply(int,int,int,android.graphics.Rect,int,int,android.graphics.Rect,int) -> a
    void applyDisplay(int,android.graphics.Rect,android.graphics.Rect,int) -> a
android.support.v4.view.KeyEventCompat -> android.support.v4.view.x:
    android.support.v4.view.KeyEventCompat$KeyEventVersionImpl IMPL -> a
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
    boolean hasModifiers(android.view.KeyEvent,int) -> a
    boolean hasNoModifiers(android.view.KeyEvent) -> a
    void startTracking(android.view.KeyEvent) -> b
    boolean isTracking(android.view.KeyEvent) -> c
android.support.v4.view.KeyEventCompat$BaseKeyEventVersionImpl -> android.support.v4.view.y:
    int META_MODIFIER_MASK -> a
    int META_ALL_MASK -> b
    int metaStateFilterDirectionalModifiers(int,int,int,int,int) -> a
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
    void startTracking(android.view.KeyEvent) -> a
    boolean isTracking(android.view.KeyEvent) -> b
android.support.v4.view.KeyEventCompat$EclairKeyEventVersionImpl -> android.support.v4.view.z:
    void startTracking(android.view.KeyEvent) -> a
    boolean isTracking(android.view.KeyEvent) -> b
android.support.v4.view.KeyEventCompat$HoneycombKeyEventVersionImpl -> android.support.v4.view.aa:
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.KeyEventCompat$KeyEventVersionImpl -> android.support.v4.view.ab:
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
    void startTracking(android.view.KeyEvent) -> a
    boolean isTracking(android.view.KeyEvent) -> b
android.support.v4.view.KeyEventCompatEclair -> android.support.v4.view.ac:
    void startTracking(android.view.KeyEvent) -> a
    boolean isTracking(android.view.KeyEvent) -> b
android.support.v4.view.KeyEventCompatHoneycomb -> android.support.v4.view.ad:
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.MenuCompat -> android.support.v4.view.ae:
    android.support.v4.view.MenuCompat$MenuVersionImpl IMPL -> a
    boolean setShowAsAction(android.view.MenuItem,int) -> a
android.support.v4.view.MenuCompat$BaseMenuVersionImpl -> android.support.v4.view.af:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
android.support.v4.view.MenuCompat$HoneycombMenuVersionImpl -> android.support.v4.view.ag:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
android.support.v4.view.MenuCompat$MenuVersionImpl -> android.support.v4.view.ah:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
android.support.v4.view.MenuItemCompat -> android.support.v4.view.ai:
    int SHOW_AS_ACTION_NEVER -> a
    int SHOW_AS_ACTION_IF_ROOM -> b
    int SHOW_AS_ACTION_ALWAYS -> c
    int SHOW_AS_ACTION_WITH_TEXT -> d
    int SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW -> e
    android.support.v4.view.MenuItemCompat$MenuVersionImpl IMPL -> f
    boolean setShowAsAction(android.view.MenuItem,int) -> a
    android.view.MenuItem setActionView(android.view.MenuItem,android.view.View) -> a
android.support.v4.view.MenuItemCompat$BaseMenuVersionImpl -> android.support.v4.view.aj:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
    android.view.MenuItem setActionView(android.view.MenuItem,android.view.View) -> a
android.support.v4.view.MenuItemCompat$HoneycombMenuVersionImpl -> android.support.v4.view.ak:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
    android.view.MenuItem setActionView(android.view.MenuItem,android.view.View) -> a
android.support.v4.view.MenuItemCompat$MenuVersionImpl -> android.support.v4.view.al:
    boolean setShowAsAction(android.view.MenuItem,int) -> a
    android.view.MenuItem setActionView(android.view.MenuItem,android.view.View) -> a
android.support.v4.view.MenuItemCompatHoneycomb -> android.support.v4.view.am:
    void setShowAsAction(android.view.MenuItem,int) -> a
    android.view.MenuItem setActionView(android.view.MenuItem,android.view.View) -> a
android.support.v4.view.MotionEventCompat -> android.support.v4.view.an:
    android.support.v4.view.MotionEventCompat$MotionEventVersionImpl IMPL -> a
    int ACTION_MASK -> b
    int ACTION_POINTER_DOWN -> c
    int ACTION_POINTER_UP -> d
    int ACTION_HOVER_MOVE -> e
    int ACTION_SCROLL -> f
    int ACTION_POINTER_INDEX_MASK -> g
    int ACTION_POINTER_INDEX_SHIFT -> h
    int ACTION_HOVER_ENTER -> i
    int ACTION_HOVER_EXIT -> j
    int getActionMasked(android.view.MotionEvent) -> a
    int getActionIndex(android.view.MotionEvent) -> b
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> c
android.support.v4.view.MotionEventCompat$BaseMotionEventVersionImpl -> android.support.v4.view.ao:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompat$EclairMotionEventVersionImpl -> android.support.v4.view.ap:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompat$MotionEventVersionImpl -> android.support.v4.view.aq:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompatEclair -> android.support.v4.view.ar:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.PagerAdapter -> android.support.v4.view.as:
    android.database.DataSetObservable mObservable -> c
    int POSITION_UNCHANGED -> a
    int POSITION_NONE -> b
    int getCount() -> b
    void startUpdate(android.view.ViewGroup) -> a
    java.lang.Object instantiateItem(android.view.ViewGroup,int) -> a
    void destroyItem(android.view.ViewGroup,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.ViewGroup,int,java.lang.Object) -> b
    void finishUpdate(android.view.ViewGroup) -> b
    void startUpdate(android.view.View) -> a
    java.lang.Object instantiateItem(android.view.View,int) -> a
    void destroyItem(android.view.View,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.View,int,java.lang.Object) -> b
    void finishUpdate(android.view.View) -> b
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    android.os.Parcelable saveState() -> a
    void restoreState(android.os.Parcelable,java.lang.ClassLoader) -> a
    int getItemPosition(java.lang.Object) -> a
    void notifyDataSetChanged() -> c
    void registerDataSetObserver(android.database.DataSetObserver) -> a
    void unregisterDataSetObserver(android.database.DataSetObserver) -> b
    java.lang.CharSequence getPageTitle(int) -> c
    float getPageWidth(int) -> d
android.support.v4.view.PagerTabStrip -> android.support.v4.view.at:
    java.lang.String TAG -> f
    int INDICATOR_HEIGHT -> g
    int MIN_PADDING_BOTTOM -> h
    int TAB_PADDING -> i
    int TAB_SPACING -> j
    int MIN_TEXT_SPACING -> k
    int FULL_UNDERLINE_HEIGHT -> l
    int MIN_STRIP_HEIGHT -> m
    int mIndicatorColor -> n
    int mIndicatorHeight -> o
    int mMinPaddingBottom -> p
    int mMinTextSpacing -> q
    int mMinStripHeight -> r
    int mTabPadding -> s
    android.graphics.Paint mTabPaint -> t
    android.graphics.Rect mTempRect -> u
    int mTabAlpha -> v
    boolean mDrawFullUnderline -> w
    boolean mDrawFullUnderlineSet -> x
    int mFullUnderlineHeight -> y
    boolean mIgnoreTap -> z
    float mInitialMotionX -> A
    float mInitialMotionY -> B
    int mTouchSlop -> C
    void setTabIndicatorColor(int) -> setTabIndicatorColor
    void setTabIndicatorColorResource(int) -> setTabIndicatorColorResource
    int getTabIndicatorColor() -> getTabIndicatorColor
    void setPadding(int,int,int,int) -> setPadding
    void setTextSpacing(int) -> setTextSpacing
    void setBackgroundDrawable(android.graphics.drawable.Drawable) -> setBackgroundDrawable
    void setBackgroundColor(int) -> setBackgroundColor
    void setBackgroundResource(int) -> setBackgroundResource
    void setDrawFullUnderline(boolean) -> setDrawFullUnderline
    boolean getDrawFullUnderline() -> getDrawFullUnderline
    int getMinHeight() -> getMinHeight
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void onDraw(android.graphics.Canvas) -> onDraw
    void updateTextPositions(int,float,boolean) -> a
android.support.v4.view.PagerTabStrip$1 -> android.support.v4.view.au:
    android.support.v4.view.PagerTabStrip this$0 -> a
    void onClick(android.view.View) -> onClick
android.support.v4.view.PagerTabStrip$2 -> android.support.v4.view.av:
    android.support.v4.view.PagerTabStrip this$0 -> a
    void onClick(android.view.View) -> onClick
android.support.v4.view.PagerTitleStrip -> android.support.v4.view.aw:
    java.lang.String TAG -> f
    android.support.v4.view.ViewPager mPager -> a
    android.widget.TextView mPrevText -> b
    android.widget.TextView mCurrText -> c
    android.widget.TextView mNextText -> d
    int mLastKnownCurrentPage -> g
    float mLastKnownPositionOffset -> h
    int mScaledTextSpacing -> i
    int mGravity -> j
    boolean mUpdatingText -> k
    boolean mUpdatingPositions -> l
    android.support.v4.view.PagerTitleStrip$PageListener mPageListener -> m
    java.lang.ref.WeakReference mWatchingAdapter -> n
    int[] ATTRS -> o
    int[] TEXT_ATTRS -> p
    float SIDE_ALPHA -> q
    int TEXT_SPACING -> r
    int mNonPrimaryAlpha -> s
    int mTextColor -> e
    android.support.v4.view.PagerTitleStrip$PagerTitleStripImpl IMPL -> t
    void setSingleLineAllCaps(android.widget.TextView) -> setSingleLineAllCaps
    void setTextSpacing(int) -> setTextSpacing
    int getTextSpacing() -> getTextSpacing
    void setNonPrimaryAlpha(float) -> setNonPrimaryAlpha
    void setTextColor(int) -> setTextColor
    void setTextSize(int,float) -> a
    void setGravity(int) -> setGravity
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    void updateText(int,android.support.v4.view.PagerAdapter) -> a
    void requestLayout() -> requestLayout
    void updateAdapter(android.support.v4.view.PagerAdapter,android.support.v4.view.PagerAdapter) -> a
    void updateTextPositions(int,float,boolean) -> a
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
    int getMinHeight() -> getMinHeight
    float access$100(android.support.v4.view.PagerTitleStrip) -> a
android.support.v4.view.PagerTitleStrip$1 -> android.support.v4.view.ax:
android.support.v4.view.PagerTitleStrip$PageListener -> android.support.v4.view.ay:
    int mScrollState -> b
    android.support.v4.view.PagerTitleStrip this$0 -> a
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    void onPageScrollStateChanged(int) -> b
    void onAdapterChanged(android.support.v4.view.PagerAdapter,android.support.v4.view.PagerAdapter) -> a
    void onChanged() -> onChanged
android.support.v4.view.PagerTitleStrip$PagerTitleStripImpl -> android.support.v4.view.az:
    void setSingleLineAllCaps(android.widget.TextView) -> a
android.support.v4.view.PagerTitleStrip$PagerTitleStripImplBase -> android.support.v4.view.ba:
    void setSingleLineAllCaps(android.widget.TextView) -> a
android.support.v4.view.PagerTitleStrip$PagerTitleStripImplIcs -> android.support.v4.view.bb:
    void setSingleLineAllCaps(android.widget.TextView) -> a
android.support.v4.view.PagerTitleStripIcs -> android.support.v4.view.bc:
    void setSingleLineAllCaps(android.widget.TextView) -> a
android.support.v4.view.PagerTitleStripIcs$SingleLineAllCapsTransform -> android.support.v4.view.bd:
    java.lang.String TAG -> a
    java.util.Locale mLocale -> b
    java.lang.CharSequence getTransformation(java.lang.CharSequence,android.view.View) -> getTransformation
android.support.v4.view.VelocityTrackerCompat -> android.support.v4.view.be:
    android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl IMPL -> a
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$BaseVelocityTrackerVersionImpl -> android.support.v4.view.bf:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$HoneycombVelocityTrackerVersionImpl -> android.support.v4.view.bg:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl -> android.support.v4.view.bh:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompatHoneycomb -> android.support.v4.view.bi:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.ViewCompat -> android.support.v4.view.bj:
    int OVER_SCROLL_ALWAYS -> a
    int OVER_SCROLL_IF_CONTENT_SCROLLS -> b
    int OVER_SCROLL_NEVER -> c
    long FAKE_FRAME_TIME -> o
    int IMPORTANT_FOR_ACCESSIBILITY_AUTO -> d
    int IMPORTANT_FOR_ACCESSIBILITY_YES -> e
    int IMPORTANT_FOR_ACCESSIBILITY_NO -> f
    int LAYER_TYPE_NONE -> g
    int LAYER_TYPE_SOFTWARE -> h
    int LAYER_TYPE_HARDWARE -> i
    int LAYOUT_DIRECTION_LTR -> j
    int LAYOUT_DIRECTION_RTL -> k
    int LAYOUT_DIRECTION_INHERIT -> l
    int LAYOUT_DIRECTION_LOCALE -> m
    android.support.v4.view.ViewCompat$ViewCompatImpl IMPL -> n
    boolean canScrollHorizontally(android.view.View,int) -> a
    boolean canScrollVertically(android.view.View,int) -> b
    int getOverScrollMode(android.view.View) -> a
    void setOverScrollMode(android.view.View,int) -> c
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean hasTransientState(android.view.View) -> b
    void setHasTransientState(android.view.View,boolean) -> a
    void postInvalidateOnAnimation(android.view.View) -> c
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> a
    int getImportantForAccessibility(android.view.View) -> d
    void setImportantForAccessibility(android.view.View,int) -> d
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> e
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> f
    int getLabelFor(android.view.View) -> g
    void setLabelFor(android.view.View,int) -> e
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> h
    void setLayoutDirection(android.view.View,int) -> f
    android.view.ViewParent getParentForAccessibility(android.view.View) -> i
android.support.v4.view.ViewCompat$BaseViewCompatImpl -> android.support.v4.view.bk:
    boolean canScrollHorizontally(android.view.View,int) -> a
    boolean canScrollVertically(android.view.View,int) -> b
    int getOverScrollMode(android.view.View) -> a
    void setOverScrollMode(android.view.View,int) -> c
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean hasTransientState(android.view.View) -> b
    void setHasTransientState(android.view.View,boolean) -> a
    void postInvalidateOnAnimation(android.view.View) -> c
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> a
    long getFrameTime() -> a
    int getImportantForAccessibility(android.view.View) -> d
    void setImportantForAccessibility(android.view.View,int) -> d
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> e
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> f
    int getLabelFor(android.view.View) -> g
    void setLabelFor(android.view.View,int) -> e
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> h
    void setLayoutDirection(android.view.View,int) -> f
    android.view.ViewParent getParentForAccessibility(android.view.View) -> i
android.support.v4.view.ViewCompat$GBViewCompatImpl -> android.support.v4.view.bl:
    int getOverScrollMode(android.view.View) -> a
    void setOverScrollMode(android.view.View,int) -> c
android.support.v4.view.ViewCompat$HCViewCompatImpl -> android.support.v4.view.bm:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> f
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
android.support.v4.view.ViewCompat$ICSViewCompatImpl -> android.support.v4.view.bn:
    boolean canScrollHorizontally(android.view.View,int) -> a
    boolean canScrollVertically(android.view.View,int) -> b
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
android.support.v4.view.ViewCompat$JBViewCompatImpl -> android.support.v4.view.bo:
    boolean hasTransientState(android.view.View) -> b
    void setHasTransientState(android.view.View,boolean) -> a
    void postInvalidateOnAnimation(android.view.View) -> c
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> a
    int getImportantForAccessibility(android.view.View) -> d
    void setImportantForAccessibility(android.view.View,int) -> d
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> e
    android.view.ViewParent getParentForAccessibility(android.view.View) -> i
android.support.v4.view.ViewCompat$JbMr1ViewCompatImpl -> android.support.v4.view.bp:
    int getLabelFor(android.view.View) -> g
    void setLabelFor(android.view.View,int) -> e
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> h
    void setLayoutDirection(android.view.View,int) -> f
android.support.v4.view.ViewCompat$ViewCompatImpl -> android.support.v4.view.bq:
    boolean canScrollHorizontally(android.view.View,int) -> a
    boolean canScrollVertically(android.view.View,int) -> b
    int getOverScrollMode(android.view.View) -> a
    void setOverScrollMode(android.view.View,int) -> c
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean hasTransientState(android.view.View) -> b
    void setHasTransientState(android.view.View,boolean) -> a
    void postInvalidateOnAnimation(android.view.View) -> c
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> a
    int getImportantForAccessibility(android.view.View) -> d
    void setImportantForAccessibility(android.view.View,int) -> d
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> e
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> f
    int getLabelFor(android.view.View) -> g
    void setLabelFor(android.view.View,int) -> e
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> h
    void setLayoutDirection(android.view.View,int) -> f
    android.view.ViewParent getParentForAccessibility(android.view.View) -> i
android.support.v4.view.ViewCompatGingerbread -> android.support.v4.view.br:
    int getOverScrollMode(android.view.View) -> a
    void setOverScrollMode(android.view.View,int) -> a
android.support.v4.view.ViewCompatHC -> android.support.v4.view.bs:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> a
android.support.v4.view.ViewCompatICS -> android.support.v4.view.bt:
    boolean canScrollHorizontally(android.view.View,int) -> a
    boolean canScrollVertically(android.view.View,int) -> b
    void setAccessibilityDelegate(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> b
android.support.v4.view.ViewCompatJB -> android.support.v4.view.bu:
    boolean hasTransientState(android.view.View) -> a
    void setHasTransientState(android.view.View,boolean) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    void postOnAnimationDelayed(android.view.View,java.lang.Runnable,long) -> a
    int getImportantForAccessibility(android.view.View) -> c
    void setImportantForAccessibility(android.view.View,int) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
    java.lang.Object getAccessibilityNodeProvider(android.view.View) -> d
    android.view.ViewParent getParentForAccessibility(android.view.View) -> e
android.support.v4.view.ViewCompatJellybeanMr1 -> android.support.v4.view.bv:
    int getLabelFor(android.view.View) -> a
    void setLabelFor(android.view.View,int) -> a
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> b
    void setLayoutDirection(android.view.View,int) -> b
android.support.v4.view.ViewConfigurationCompat -> android.support.v4.view.bw:
    android.support.v4.view.ViewConfigurationCompat$ViewConfigurationVersionImpl IMPL -> a
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$BaseViewConfigurationVersionImpl -> android.support.v4.view.bx:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$FroyoViewConfigurationVersionImpl -> android.support.v4.view.by:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$ViewConfigurationVersionImpl -> android.support.v4.view.bz:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompatFroyo -> android.support.v4.view.ca:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewGroupCompat -> android.support.v4.view.cb:
    android.support.v4.view.ViewGroupCompat$ViewGroupCompatImpl IMPL -> a
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void setMotionEventSplittingEnabled(android.view.ViewGroup,boolean) -> a
android.support.v4.view.ViewGroupCompat$ViewGroupCompatHCImpl -> android.support.v4.view.cc:
    void setMotionEventSplittingEnabled(android.view.ViewGroup,boolean) -> a
android.support.v4.view.ViewGroupCompat$ViewGroupCompatIcsImpl -> android.support.v4.view.cd:
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
android.support.v4.view.ViewGroupCompat$ViewGroupCompatImpl -> android.support.v4.view.ce:
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void setMotionEventSplittingEnabled(android.view.ViewGroup,boolean) -> a
android.support.v4.view.ViewGroupCompat$ViewGroupCompatStubImpl -> android.support.v4.view.cf:
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void setMotionEventSplittingEnabled(android.view.ViewGroup,boolean) -> a
android.support.v4.view.ViewGroupCompatHC -> android.support.v4.view.cg:
    void setMotionEventSplittingEnabled(android.view.ViewGroup,boolean) -> a
android.support.v4.view.ViewGroupCompatIcs -> android.support.v4.view.ch:
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
android.support.v4.view.ViewPager -> android.support.v4.view.ViewPager:
    java.lang.String TAG -> d
    boolean DEBUG -> e
    boolean USE_CACHE -> f
    int DEFAULT_OFFSCREEN_PAGES -> g
    int MAX_SETTLE_DURATION -> h
    int MIN_DISTANCE_FOR_FLING -> i
    int DEFAULT_GUTTER_SIZE -> j
    int MIN_FLING_VELOCITY -> k
    int[] LAYOUT_ATTRS -> l
    int mExpectedAdapterCount -> m
    java.util.Comparator COMPARATOR -> n
    android.view.animation.Interpolator sInterpolator -> o
    java.util.ArrayList mItems -> p
    android.support.v4.view.ViewPager$ItemInfo mTempItem -> q
    android.graphics.Rect mTempRect -> r
    android.support.v4.view.PagerAdapter mAdapter -> s
    int mCurItem -> t
    int mRestoredCurItem -> u
    android.os.Parcelable mRestoredAdapterState -> v
    java.lang.ClassLoader mRestoredClassLoader -> w
    android.widget.Scroller mScroller -> x
    android.support.v4.view.ViewPager$PagerObserver mObserver -> y
    int mPageMargin -> z
    android.graphics.drawable.Drawable mMarginDrawable -> A
    int mTopPageBounds -> B
    int mBottomPageBounds -> C
    float mFirstOffset -> D
    float mLastOffset -> E
    int mChildWidthMeasureSpec -> F
    int mChildHeightMeasureSpec -> G
    boolean mInLayout -> H
    boolean mScrollingCacheEnabled -> I
    boolean mPopulatePending -> J
    int mOffscreenPageLimit -> K
    boolean mIsBeingDragged -> L
    boolean mIsUnableToDrag -> M
    boolean mIgnoreGutter -> N
    int mDefaultGutterSize -> O
    int mGutterSize -> P
    int mTouchSlop -> Q
    float mLastMotionX -> R
    float mLastMotionY -> S
    float mInitialMotionX -> T
    float mInitialMotionY -> U
    int mActivePointerId -> V
    int INVALID_POINTER -> W
    android.view.VelocityTracker mVelocityTracker -> Z
    int mMinimumVelocity -> aa
    int mMaximumVelocity -> ab
    int mFlingDistance -> ac
    int mCloseEnough -> ad
    int CLOSE_ENOUGH -> ae
    boolean mFakeDragging -> af
    long mFakeDragBeginTime -> ag
    android.support.v4.widget.EdgeEffectCompat mLeftEdge -> ah
    android.support.v4.widget.EdgeEffectCompat mRightEdge -> ai
    boolean mFirstLayout -> aj
    boolean mNeedCalculatePageOffsets -> ak
    boolean mCalledSuper -> al
    int mDecorChildCount -> am
    android.support.v4.view.ViewPager$OnPageChangeListener mOnPageChangeListener -> an
    android.support.v4.view.ViewPager$OnPageChangeListener mInternalPageChangeListener -> ao
    android.support.v4.view.ViewPager$OnAdapterChangeListener mAdapterChangeListener -> ap
    android.support.v4.view.ViewPager$PageTransformer mPageTransformer -> aq
    java.lang.reflect.Method mSetChildrenDrawingOrderEnabled -> ar
    int DRAW_ORDER_DEFAULT -> as
    int DRAW_ORDER_FORWARD -> at
    int DRAW_ORDER_REVERSE -> au
    int mDrawingOrder -> av
    java.util.ArrayList mDrawingOrderedChildren -> aw
    android.support.v4.view.ViewPager$ViewPositionComparator sPositionComparator -> ax
    int SCROLL_STATE_IDLE -> a
    int SCROLL_STATE_DRAGGING -> b
    int SCROLL_STATE_SETTLING -> c
    java.lang.Runnable mEndScrollRunnable -> ay
    int mScrollState -> az
    void initViewPager() -> a
    void onDetachedFromWindow() -> onDetachedFromWindow
    void setScrollState(int) -> setScrollState
    void setAdapter(android.support.v4.view.PagerAdapter) -> setAdapter
    void removeNonDecorViews() -> j
    android.support.v4.view.PagerAdapter getAdapter() -> getAdapter
    void setOnAdapterChangeListener(android.support.v4.view.ViewPager$OnAdapterChangeListener) -> setOnAdapterChangeListener
    int getClientWidth() -> getClientWidth
    void setCurrentItem(int) -> setCurrentItem
    void setCurrentItem(int,boolean) -> a
    int getCurrentItem() -> getCurrentItem
    void setCurrentItemInternal(int,boolean,boolean) -> a
    void setCurrentItemInternal(int,boolean,boolean,int) -> a
    void scrollToItem(int,boolean,int,boolean) -> a
    void setOnPageChangeListener(android.support.v4.view.ViewPager$OnPageChangeListener) -> setOnPageChangeListener
    void setPageTransformer(boolean,android.support.v4.view.ViewPager$PageTransformer) -> a
    void setChildrenDrawingOrderEnabledCompat(boolean) -> setChildrenDrawingOrderEnabledCompat
    int getChildDrawingOrder(int,int) -> getChildDrawingOrder
    android.support.v4.view.ViewPager$OnPageChangeListener setInternalPageChangeListener(android.support.v4.view.ViewPager$OnPageChangeListener) -> a
    int getOffscreenPageLimit() -> getOffscreenPageLimit
    void setOffscreenPageLimit(int) -> setOffscreenPageLimit
    void setPageMargin(int) -> setPageMargin
    int getPageMargin() -> getPageMargin
    void setPageMarginDrawable(android.graphics.drawable.Drawable) -> setPageMarginDrawable
    void setPageMarginDrawable(int) -> setPageMarginDrawable
    boolean verifyDrawable(android.graphics.drawable.Drawable) -> verifyDrawable
    void drawableStateChanged() -> drawableStateChanged
    float distanceInfluenceForSnapDuration(float) -> a
    void smoothScrollTo(int,int) -> a
    void smoothScrollTo(int,int,int) -> a
    android.support.v4.view.ViewPager$ItemInfo addNewItem(int,int) -> b
    void dataSetChanged() -> b
    void populate() -> c
    void populate(int) -> a
    void sortChildDrawingOrder() -> k
    void calculatePageOffsets(android.support.v4.view.ViewPager$ItemInfo,int,android.support.v4.view.ViewPager$ItemInfo) -> a
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void addView(android.view.View,int,android.view.ViewGroup$LayoutParams) -> addView
    void removeView(android.view.View) -> removeView
    android.support.v4.view.ViewPager$ItemInfo infoForChild(android.view.View) -> a
    android.support.v4.view.ViewPager$ItemInfo infoForAnyChild(android.view.View) -> b
    android.support.v4.view.ViewPager$ItemInfo infoForPosition(int) -> b
    void onAttachedToWindow() -> onAttachedToWindow
    void onMeasure(int,int) -> onMeasure
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    void recomputeScrollPosition(int,int,int,int) -> a
    void onLayout(boolean,int,int,int,int) -> onLayout
    void computeScroll() -> computeScroll
    boolean pageScrolled(int) -> d
    void onPageScrolled(int,float,int) -> a
    void completeScroll(boolean) -> a
    boolean isGutterDrag(float,float) -> a
    void enableLayers(boolean) -> b
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    boolean performDrag(float) -> c
    android.support.v4.view.ViewPager$ItemInfo infoForCurrentScrollPosition() -> l
    int determineTargetPage(int,float,int,int) -> a
    void draw(android.graphics.Canvas) -> draw
    void onDraw(android.graphics.Canvas) -> onDraw
    boolean beginFakeDrag() -> d
    void endFakeDrag() -> e
    void fakeDragBy(float) -> b
    boolean isFakeDragging() -> f
    void onSecondaryPointerUp(android.view.MotionEvent) -> a
    void endDrag() -> m
    void setScrollingCacheEnabled(boolean) -> setScrollingCacheEnabled
    boolean canScroll(android.view.View,boolean,int,int,int) -> a
    boolean dispatchKeyEvent(android.view.KeyEvent) -> dispatchKeyEvent
    boolean executeKeyEvent(android.view.KeyEvent) -> a
    boolean arrowScroll(int) -> c
    android.graphics.Rect getChildRectInPagerCoordinates(android.graphics.Rect,android.view.View) -> a
    boolean pageLeft() -> g
    boolean pageRight() -> h
    void addFocusables(java.util.ArrayList,int,int) -> addFocusables
    void addTouchables(java.util.ArrayList) -> addTouchables
    boolean onRequestFocusInDescendants(int,android.graphics.Rect) -> onRequestFocusInDescendants
    boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    void access$000(android.support.v4.view.ViewPager,int) -> a
    android.support.v4.view.PagerAdapter access$200(android.support.v4.view.ViewPager) -> a
    int access$300(android.support.v4.view.ViewPager) -> b
    int[] access$400() -> i
android.support.v4.view.ViewPager$1 -> android.support.v4.view.ci:
    int compare(android.support.v4.view.ViewPager$ItemInfo,android.support.v4.view.ViewPager$ItemInfo) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.view.ViewPager$2 -> android.support.v4.view.cj:
    float getInterpolation(float) -> getInterpolation
android.support.v4.view.ViewPager$3 -> android.support.v4.view.ck:
    android.support.v4.view.ViewPager this$0 -> a
    void run() -> run
android.support.v4.view.ViewPager$Decor -> android.support.v4.view.cl:
android.support.v4.view.ViewPager$ItemInfo -> android.support.v4.view.cm:
    java.lang.Object object -> a
    int position -> b
    boolean scrolling -> c
    float widthFactor -> d
    float offset -> e
android.support.v4.view.ViewPager$LayoutParams -> android.support.v4.view.cn:
    boolean isDecor -> a
    int gravity -> b
    float widthFactor -> c
    boolean needsMeasure -> d
    int position -> e
    int childIndex -> f
android.support.v4.view.ViewPager$MyAccessibilityDelegate -> android.support.v4.view.co:
    android.support.v4.view.ViewPager this$0 -> b
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.ViewPager$OnAdapterChangeListener -> android.support.v4.view.cp:
    void onAdapterChanged(android.support.v4.view.PagerAdapter,android.support.v4.view.PagerAdapter) -> a
android.support.v4.view.ViewPager$OnPageChangeListener -> android.support.v4.view.cq:
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    void onPageScrollStateChanged(int) -> b
android.support.v4.view.ViewPager$PageTransformer -> android.support.v4.view.cr:
    void transformPage(android.view.View,float) -> a
android.support.v4.view.ViewPager$PagerObserver -> android.support.v4.view.cs:
    android.support.v4.view.ViewPager this$0 -> a
    void onChanged() -> onChanged
    void onInvalidated() -> onInvalidated
android.support.v4.view.ViewPager$SavedState -> android.support.v4.view.ViewPager$SavedState:
    int position -> a
    android.os.Parcelable adapterState -> b
    java.lang.ClassLoader loader -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.view.ViewPager$SavedState$1 -> android.support.v4.view.ct:
    android.support.v4.view.ViewPager$SavedState createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> b
    android.support.v4.view.ViewPager$SavedState[] newArray(int) -> b
    java.lang.Object[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
android.support.v4.view.ViewPager$SimpleOnPageChangeListener -> android.support.v4.view.cu:
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    void onPageScrollStateChanged(int) -> b
android.support.v4.view.ViewPager$ViewPositionComparator -> android.support.v4.view.cv:
    int compare(android.view.View,android.view.View) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.view.accessibility.AccessibilityEventCompat -> android.support.v4.view.a.a:
    android.support.v4.view.accessibility.AccessibilityEventCompat$AccessibilityEventVersionImpl IMPL -> q
    int TYPE_VIEW_HOVER_ENTER -> a
    int TYPE_VIEW_HOVER_EXIT -> b
    int TYPE_TOUCH_EXPLORATION_GESTURE_START -> c
    int TYPE_TOUCH_EXPLORATION_GESTURE_END -> d
    int TYPE_WINDOW_CONTENT_CHANGED -> e
    int TYPE_VIEW_SCROLLED -> f
    int TYPE_VIEW_TEXT_SELECTION_CHANGED -> g
    int TYPE_ANNOUNCEMENT -> h
    int TYPE_VIEW_ACCESSIBILITY_FOCUSED -> i
    int TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED -> j
    int TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY -> k
    int TYPE_GESTURE_DETECTION_START -> l
    int TYPE_GESTURE_DETECTION_END -> m
    int TYPE_TOUCH_INTERACTION_START -> n
    int TYPE_TOUCH_INTERACTION_END -> o
    int TYPES_ALL_MASK -> p
    int getRecordCount(android.view.accessibility.AccessibilityEvent) -> a
    void appendRecord(android.view.accessibility.AccessibilityEvent,android.support.v4.view.accessibility.AccessibilityRecordCompat) -> a
    android.support.v4.view.accessibility.AccessibilityRecordCompat getRecord(android.view.accessibility.AccessibilityEvent,int) -> a
android.support.v4.view.accessibility.AccessibilityEventCompat$AccessibilityEventIcsImpl -> android.support.v4.view.a.b:
    void appendRecord(android.view.accessibility.AccessibilityEvent,java.lang.Object) -> a
    java.lang.Object getRecord(android.view.accessibility.AccessibilityEvent,int) -> a
    int getRecordCount(android.view.accessibility.AccessibilityEvent) -> a
android.support.v4.view.accessibility.AccessibilityEventCompat$AccessibilityEventStubImpl -> android.support.v4.view.a.c:
    void appendRecord(android.view.accessibility.AccessibilityEvent,java.lang.Object) -> a
    java.lang.Object getRecord(android.view.accessibility.AccessibilityEvent,int) -> a
    int getRecordCount(android.view.accessibility.AccessibilityEvent) -> a
android.support.v4.view.accessibility.AccessibilityEventCompat$AccessibilityEventVersionImpl -> android.support.v4.view.a.d:
    int getRecordCount(android.view.accessibility.AccessibilityEvent) -> a
    void appendRecord(android.view.accessibility.AccessibilityEvent,java.lang.Object) -> a
    java.lang.Object getRecord(android.view.accessibility.AccessibilityEvent,int) -> a
android.support.v4.view.accessibility.AccessibilityEventCompatIcs -> android.support.v4.view.a.e:
    int getRecordCount(android.view.accessibility.AccessibilityEvent) -> a
    void appendRecord(android.view.accessibility.AccessibilityEvent,java.lang.Object) -> a
    java.lang.Object getRecord(android.view.accessibility.AccessibilityEvent,int) -> a
android.support.v4.view.accessibility.AccessibilityManagerCompat -> android.support.v4.view.a.f:
    android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerVersionImpl IMPL -> a
    boolean addAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean removeAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> b
    java.util.List getInstalledAccessibilityServiceList(android.view.accessibility.AccessibilityManager) -> a
    java.util.List getEnabledAccessibilityServiceList(android.view.accessibility.AccessibilityManager,int) -> a
    boolean isTouchExplorationEnabled(android.view.accessibility.AccessibilityManager) -> b
    android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerVersionImpl access$000() -> a
android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerIcsImpl -> android.support.v4.view.a.g:
    java.lang.Object newAccessiblityStateChangeListener(android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean addAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean removeAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> b
    java.util.List getEnabledAccessibilityServiceList(android.view.accessibility.AccessibilityManager,int) -> a
    java.util.List getInstalledAccessibilityServiceList(android.view.accessibility.AccessibilityManager) -> a
    boolean isTouchExplorationEnabled(android.view.accessibility.AccessibilityManager) -> b
android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerIcsImpl$1 -> android.support.v4.view.a.h:
    android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat val$listener -> a
    android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerIcsImpl this$0 -> b
    void onAccessibilityStateChanged(boolean) -> a
android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerStubImpl -> android.support.v4.view.a.i:
    java.lang.Object newAccessiblityStateChangeListener(android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean addAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean removeAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> b
    java.util.List getEnabledAccessibilityServiceList(android.view.accessibility.AccessibilityManager,int) -> a
    java.util.List getInstalledAccessibilityServiceList(android.view.accessibility.AccessibilityManager) -> a
    boolean isTouchExplorationEnabled(android.view.accessibility.AccessibilityManager) -> b
android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityManagerVersionImpl -> android.support.v4.view.a.j:
    java.lang.Object newAccessiblityStateChangeListener(android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean addAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> a
    boolean removeAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat) -> b
    java.util.List getEnabledAccessibilityServiceList(android.view.accessibility.AccessibilityManager,int) -> a
    java.util.List getInstalledAccessibilityServiceList(android.view.accessibility.AccessibilityManager) -> a
    boolean isTouchExplorationEnabled(android.view.accessibility.AccessibilityManager) -> b
android.support.v4.view.accessibility.AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat -> android.support.v4.view.a.k:
    java.lang.Object mListener -> a
    void onAccessibilityStateChanged(boolean) -> a
android.support.v4.view.accessibility.AccessibilityManagerCompatIcs -> android.support.v4.view.a.l:
    java.lang.Object newAccessibilityStateChangeListener(android.support.v4.view.accessibility.AccessibilityManagerCompatIcs$AccessibilityStateChangeListenerBridge) -> a
    boolean addAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,java.lang.Object) -> a
    boolean removeAccessibilityStateChangeListener(android.view.accessibility.AccessibilityManager,java.lang.Object) -> b
    java.util.List getEnabledAccessibilityServiceList(android.view.accessibility.AccessibilityManager,int) -> a
    java.util.List getInstalledAccessibilityServiceList(android.view.accessibility.AccessibilityManager) -> a
    boolean isTouchExplorationEnabled(android.view.accessibility.AccessibilityManager) -> b
android.support.v4.view.accessibility.AccessibilityManagerCompatIcs$1 -> android.support.v4.view.a.m:
    android.support.v4.view.accessibility.AccessibilityManagerCompatIcs$AccessibilityStateChangeListenerBridge val$bridge -> a
    void onAccessibilityStateChanged(boolean) -> onAccessibilityStateChanged
android.support.v4.view.accessibility.AccessibilityManagerCompatIcs$AccessibilityStateChangeListenerBridge -> android.support.v4.view.a.n:
    void onAccessibilityStateChanged(boolean) -> a
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat -> android.support.v4.view.a.o:
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoImpl IMPL -> x
    java.lang.Object mInfo -> y
    int ACTION_FOCUS -> a
    int ACTION_CLEAR_FOCUS -> b
    int ACTION_SELECT -> c
    int ACTION_CLEAR_SELECTION -> d
    int ACTION_CLICK -> e
    int ACTION_LONG_CLICK -> f
    int ACTION_ACCESSIBILITY_FOCUS -> g
    int ACTION_CLEAR_ACCESSIBILITY_FOCUS -> h
    int ACTION_NEXT_AT_MOVEMENT_GRANULARITY -> i
    int ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY -> j
    int ACTION_NEXT_HTML_ELEMENT -> k
    int ACTION_PREVIOUS_HTML_ELEMENT -> l
    int ACTION_SCROLL_FORWARD -> m
    int ACTION_SCROLL_BACKWARD -> n
    java.lang.String ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT -> o
    java.lang.String ACTION_ARGUMENT_HTML_ELEMENT_STRING -> p
    int FOCUS_INPUT -> q
    int FOCUS_ACCESSIBILITY -> r
    int MOVEMENT_GRANULARITY_CHARACTER -> s
    int MOVEMENT_GRANULARITY_WORD -> t
    int MOVEMENT_GRANULARITY_LINE -> u
    int MOVEMENT_GRANULARITY_PARAGRAPH -> v
    int MOVEMENT_GRANULARITY_PAGE -> w
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat wrapNonNullInstance(java.lang.Object) -> a
    java.lang.Object getInfo() -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat obtain(android.view.View) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat obtain(android.view.View,int) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat obtain() -> b
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat obtain(android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void setSource(android.view.View) -> b
    void setSource(android.view.View,int) -> b
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat findFocus(int) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat focusSearch(int) -> b
    int getWindowId() -> c
    int getChildCount() -> d
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getChild(int) -> c
    void addChild(android.view.View) -> c
    void addChild(android.view.View,int) -> c
    int getActions() -> e
    void addAction(int) -> d
    boolean performAction(int) -> e
    boolean performAction(int,android.os.Bundle) -> a
    void setMovementGranularities(int) -> f
    int getMovementGranularities() -> f
    java.util.List findAccessibilityNodeInfosByText(java.lang.String) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getParent() -> g
    void setParent(android.view.View) -> d
    void setParent(android.view.View,int) -> d
    void getBoundsInParent(android.graphics.Rect) -> a
    void setBoundsInParent(android.graphics.Rect) -> b
    void getBoundsInScreen(android.graphics.Rect) -> c
    void setBoundsInScreen(android.graphics.Rect) -> d
    boolean isCheckable() -> h
    void setCheckable(boolean) -> a
    boolean isChecked() -> i
    void setChecked(boolean) -> b
    boolean isFocusable() -> j
    void setFocusable(boolean) -> c
    boolean isFocused() -> k
    void setFocused(boolean) -> d
    boolean isVisibleToUser() -> l
    void setVisibleToUser(boolean) -> e
    boolean isAccessibilityFocused() -> m
    void setAccessibilityFocused(boolean) -> f
    boolean isSelected() -> n
    void setSelected(boolean) -> g
    boolean isClickable() -> o
    void setClickable(boolean) -> h
    boolean isLongClickable() -> p
    void setLongClickable(boolean) -> i
    boolean isEnabled() -> q
    void setEnabled(boolean) -> j
    boolean isPassword() -> r
    void setPassword(boolean) -> k
    boolean isScrollable() -> s
    void setScrollable(boolean) -> l
    java.lang.CharSequence getPackageName() -> t
    void setPackageName(java.lang.CharSequence) -> a
    java.lang.CharSequence getClassName() -> u
    void setClassName(java.lang.CharSequence) -> b
    java.lang.CharSequence getText() -> v
    void setText(java.lang.CharSequence) -> c
    java.lang.CharSequence getContentDescription() -> w
    void setContentDescription(java.lang.CharSequence) -> d
    void recycle() -> x
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoIcsImpl -> android.support.v4.view.a.p:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(android.view.View) -> a
    java.lang.Object obtain(java.lang.Object) -> a
    void addAction(java.lang.Object,int) -> a
    void addChild(java.lang.Object,android.view.View) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.Object,java.lang.String) -> a
    int getActions(java.lang.Object) -> b
    void getBoundsInParent(java.lang.Object,android.graphics.Rect) -> a
    void getBoundsInScreen(java.lang.Object,android.graphics.Rect) -> b
    java.lang.Object getChild(java.lang.Object,int) -> b
    int getChildCount(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    java.lang.CharSequence getPackageName(java.lang.Object) -> f
    java.lang.Object getParent(java.lang.Object) -> g
    java.lang.CharSequence getText(java.lang.Object) -> h
    int getWindowId(java.lang.Object) -> i
    boolean isCheckable(java.lang.Object) -> j
    boolean isChecked(java.lang.Object) -> k
    boolean isClickable(java.lang.Object) -> l
    boolean isEnabled(java.lang.Object) -> m
    boolean isFocusable(java.lang.Object) -> n
    boolean isFocused(java.lang.Object) -> o
    boolean isLongClickable(java.lang.Object) -> p
    boolean isPassword(java.lang.Object) -> q
    boolean isScrollable(java.lang.Object) -> r
    boolean isSelected(java.lang.Object) -> s
    boolean performAction(java.lang.Object,int) -> c
    void setBoundsInParent(java.lang.Object,android.graphics.Rect) -> c
    void setBoundsInScreen(java.lang.Object,android.graphics.Rect) -> d
    void setCheckable(java.lang.Object,boolean) -> a
    void setChecked(java.lang.Object,boolean) -> b
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setClickable(java.lang.Object,boolean) -> c
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> b
    void setEnabled(java.lang.Object,boolean) -> d
    void setFocusable(java.lang.Object,boolean) -> e
    void setFocused(java.lang.Object,boolean) -> f
    void setLongClickable(java.lang.Object,boolean) -> g
    void setPackageName(java.lang.Object,java.lang.CharSequence) -> c
    void setParent(java.lang.Object,android.view.View) -> b
    void setPassword(java.lang.Object,boolean) -> h
    void setScrollable(java.lang.Object,boolean) -> i
    void setSelected(java.lang.Object,boolean) -> j
    void setSource(java.lang.Object,android.view.View) -> c
    void setText(java.lang.Object,java.lang.CharSequence) -> d
    void recycle(java.lang.Object) -> t
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoImpl -> android.support.v4.view.a.q:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(android.view.View) -> a
    java.lang.Object obtain(java.lang.Object) -> a
    java.lang.Object obtain(android.view.View,int) -> a
    void setSource(java.lang.Object,android.view.View) -> c
    void setSource(java.lang.Object,android.view.View,int) -> a
    java.lang.Object findFocus(java.lang.Object,int) -> d
    java.lang.Object focusSearch(java.lang.Object,int) -> e
    int getWindowId(java.lang.Object) -> i
    int getChildCount(java.lang.Object) -> c
    java.lang.Object getChild(java.lang.Object,int) -> b
    void addChild(java.lang.Object,android.view.View) -> a
    void addChild(java.lang.Object,android.view.View,int) -> b
    int getActions(java.lang.Object) -> b
    void addAction(java.lang.Object,int) -> a
    boolean performAction(java.lang.Object,int) -> c
    boolean performAction(java.lang.Object,int,android.os.Bundle) -> a
    void setMovementGranularities(java.lang.Object,int) -> f
    int getMovementGranularities(java.lang.Object) -> u
    java.util.List findAccessibilityNodeInfosByText(java.lang.Object,java.lang.String) -> a
    java.lang.Object getParent(java.lang.Object) -> g
    void setParent(java.lang.Object,android.view.View,int) -> c
    void setParent(java.lang.Object,android.view.View) -> b
    void getBoundsInParent(java.lang.Object,android.graphics.Rect) -> a
    void setBoundsInParent(java.lang.Object,android.graphics.Rect) -> c
    void getBoundsInScreen(java.lang.Object,android.graphics.Rect) -> b
    void setBoundsInScreen(java.lang.Object,android.graphics.Rect) -> d
    boolean isCheckable(java.lang.Object) -> j
    void setCheckable(java.lang.Object,boolean) -> a
    boolean isChecked(java.lang.Object) -> k
    void setChecked(java.lang.Object,boolean) -> b
    boolean isFocusable(java.lang.Object) -> n
    void setFocusable(java.lang.Object,boolean) -> e
    boolean isFocused(java.lang.Object) -> o
    void setFocused(java.lang.Object,boolean) -> f
    boolean isVisibleToUser(java.lang.Object) -> v
    void setVisibleToUser(java.lang.Object,boolean) -> k
    boolean isAccessibilityFocused(java.lang.Object) -> w
    void setAccessibilityFocused(java.lang.Object,boolean) -> l
    boolean isSelected(java.lang.Object) -> s
    void setSelected(java.lang.Object,boolean) -> j
    boolean isClickable(java.lang.Object) -> l
    void setClickable(java.lang.Object,boolean) -> c
    boolean isLongClickable(java.lang.Object) -> p
    void setLongClickable(java.lang.Object,boolean) -> g
    boolean isEnabled(java.lang.Object) -> m
    void setEnabled(java.lang.Object,boolean) -> d
    boolean isPassword(java.lang.Object) -> q
    void setPassword(java.lang.Object,boolean) -> h
    boolean isScrollable(java.lang.Object) -> r
    void setScrollable(java.lang.Object,boolean) -> i
    java.lang.CharSequence getPackageName(java.lang.Object) -> f
    void setPackageName(java.lang.Object,java.lang.CharSequence) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    java.lang.CharSequence getText(java.lang.Object) -> h
    void setText(java.lang.Object,java.lang.CharSequence) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> b
    void recycle(java.lang.Object) -> t
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoJellybeanImpl -> android.support.v4.view.a.r:
    java.lang.Object obtain(android.view.View,int) -> a
    java.lang.Object findFocus(java.lang.Object,int) -> d
    java.lang.Object focusSearch(java.lang.Object,int) -> e
    void addChild(java.lang.Object,android.view.View,int) -> b
    void setSource(java.lang.Object,android.view.View,int) -> a
    boolean isVisibleToUser(java.lang.Object) -> v
    void setVisibleToUser(java.lang.Object,boolean) -> k
    boolean isAccessibilityFocused(java.lang.Object) -> w
    void setAccessibilityFocused(java.lang.Object,boolean) -> l
    boolean performAction(java.lang.Object,int,android.os.Bundle) -> a
    void setMovementGranularities(java.lang.Object,int) -> f
    int getMovementGranularities(java.lang.Object) -> u
    void setParent(java.lang.Object,android.view.View,int) -> c
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoStubImpl -> android.support.v4.view.a.s:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(android.view.View) -> a
    java.lang.Object obtain(android.view.View,int) -> a
    java.lang.Object obtain(java.lang.Object) -> a
    void addAction(java.lang.Object,int) -> a
    void addChild(java.lang.Object,android.view.View) -> a
    void addChild(java.lang.Object,android.view.View,int) -> b
    java.util.List findAccessibilityNodeInfosByText(java.lang.Object,java.lang.String) -> a
    int getActions(java.lang.Object) -> b
    void getBoundsInParent(java.lang.Object,android.graphics.Rect) -> a
    void getBoundsInScreen(java.lang.Object,android.graphics.Rect) -> b
    java.lang.Object getChild(java.lang.Object,int) -> b
    int getChildCount(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    java.lang.CharSequence getPackageName(java.lang.Object) -> f
    java.lang.Object getParent(java.lang.Object) -> g
    java.lang.CharSequence getText(java.lang.Object) -> h
    int getWindowId(java.lang.Object) -> i
    boolean isCheckable(java.lang.Object) -> j
    boolean isChecked(java.lang.Object) -> k
    boolean isClickable(java.lang.Object) -> l
    boolean isEnabled(java.lang.Object) -> m
    boolean isFocusable(java.lang.Object) -> n
    boolean isFocused(java.lang.Object) -> o
    boolean isVisibleToUser(java.lang.Object) -> v
    boolean isAccessibilityFocused(java.lang.Object) -> w
    boolean isLongClickable(java.lang.Object) -> p
    boolean isPassword(java.lang.Object) -> q
    boolean isScrollable(java.lang.Object) -> r
    boolean isSelected(java.lang.Object) -> s
    boolean performAction(java.lang.Object,int) -> c
    boolean performAction(java.lang.Object,int,android.os.Bundle) -> a
    void setMovementGranularities(java.lang.Object,int) -> f
    int getMovementGranularities(java.lang.Object) -> u
    void setBoundsInParent(java.lang.Object,android.graphics.Rect) -> c
    void setBoundsInScreen(java.lang.Object,android.graphics.Rect) -> d
    void setCheckable(java.lang.Object,boolean) -> a
    void setChecked(java.lang.Object,boolean) -> b
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setClickable(java.lang.Object,boolean) -> c
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> b
    void setEnabled(java.lang.Object,boolean) -> d
    void setFocusable(java.lang.Object,boolean) -> e
    void setFocused(java.lang.Object,boolean) -> f
    void setVisibleToUser(java.lang.Object,boolean) -> k
    void setAccessibilityFocused(java.lang.Object,boolean) -> l
    void setLongClickable(java.lang.Object,boolean) -> g
    void setPackageName(java.lang.Object,java.lang.CharSequence) -> c
    void setParent(java.lang.Object,android.view.View) -> b
    void setPassword(java.lang.Object,boolean) -> h
    void setScrollable(java.lang.Object,boolean) -> i
    void setSelected(java.lang.Object,boolean) -> j
    void setSource(java.lang.Object,android.view.View) -> c
    void setSource(java.lang.Object,android.view.View,int) -> a
    java.lang.Object findFocus(java.lang.Object,int) -> d
    java.lang.Object focusSearch(java.lang.Object,int) -> e
    void setText(java.lang.Object,java.lang.CharSequence) -> d
    void recycle(java.lang.Object) -> t
    void setParent(java.lang.Object,android.view.View,int) -> c
android.support.v4.view.accessibility.AccessibilityNodeInfoCompatIcs -> android.support.v4.view.a.t:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(android.view.View) -> a
    java.lang.Object obtain(java.lang.Object) -> a
    void addAction(java.lang.Object,int) -> a
    void addChild(java.lang.Object,android.view.View) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.Object,java.lang.String) -> a
    int getActions(java.lang.Object) -> b
    void getBoundsInParent(java.lang.Object,android.graphics.Rect) -> a
    void getBoundsInScreen(java.lang.Object,android.graphics.Rect) -> b
    java.lang.Object getChild(java.lang.Object,int) -> b
    int getChildCount(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    java.lang.CharSequence getPackageName(java.lang.Object) -> f
    java.lang.Object getParent(java.lang.Object) -> g
    java.lang.CharSequence getText(java.lang.Object) -> h
    int getWindowId(java.lang.Object) -> i
    boolean isCheckable(java.lang.Object) -> j
    boolean isChecked(java.lang.Object) -> k
    boolean isClickable(java.lang.Object) -> l
    boolean isEnabled(java.lang.Object) -> m
    boolean isFocusable(java.lang.Object) -> n
    boolean isFocused(java.lang.Object) -> o
    boolean isLongClickable(java.lang.Object) -> p
    boolean isPassword(java.lang.Object) -> q
    boolean isScrollable(java.lang.Object) -> r
    boolean isSelected(java.lang.Object) -> s
    boolean performAction(java.lang.Object,int) -> c
    void setBoundsInParent(java.lang.Object,android.graphics.Rect) -> c
    void setBoundsInScreen(java.lang.Object,android.graphics.Rect) -> d
    void setCheckable(java.lang.Object,boolean) -> a
    void setChecked(java.lang.Object,boolean) -> b
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setClickable(java.lang.Object,boolean) -> c
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> b
    void setEnabled(java.lang.Object,boolean) -> d
    void setFocusable(java.lang.Object,boolean) -> e
    void setFocused(java.lang.Object,boolean) -> f
    void setLongClickable(java.lang.Object,boolean) -> g
    void setPackageName(java.lang.Object,java.lang.CharSequence) -> c
    void setParent(java.lang.Object,android.view.View) -> b
    void setPassword(java.lang.Object,boolean) -> h
    void setScrollable(java.lang.Object,boolean) -> i
    void setSelected(java.lang.Object,boolean) -> j
    void setSource(java.lang.Object,android.view.View) -> c
    void setText(java.lang.Object,java.lang.CharSequence) -> d
    void recycle(java.lang.Object) -> t
android.support.v4.view.accessibility.AccessibilityNodeInfoCompatJellyBean -> android.support.v4.view.a.u:
    void addChild(java.lang.Object,android.view.View,int) -> a
    void setSource(java.lang.Object,android.view.View,int) -> b
    boolean isVisibleToUser(java.lang.Object) -> a
    void setVisibleToUser(java.lang.Object,boolean) -> a
    boolean performAction(java.lang.Object,int,android.os.Bundle) -> a
    void setMovementGranularities(java.lang.Object,int) -> a
    int getMovementGranularities(java.lang.Object) -> b
    java.lang.Object obtain(android.view.View,int) -> a
    java.lang.Object findFocus(java.lang.Object,int) -> b
    java.lang.Object focusSearch(java.lang.Object,int) -> c
    void setParent(java.lang.Object,android.view.View,int) -> c
    boolean isAccessibilityFocused(java.lang.Object) -> c
    void setAccesibilityFocused(java.lang.Object,boolean) -> b
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat -> android.support.v4.view.a.v:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderImpl IMPL -> a
    java.lang.Object mProvider -> b
    java.lang.Object getProvider() -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int) -> a
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderImpl -> android.support.v4.view.a.w:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl -> android.support.v4.view.a.x:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl$1 -> android.support.v4.view.a.y:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat val$compat -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl this$0 -> b
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
    java.lang.Object createAccessibilityNodeInfo(int) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderStubImpl -> android.support.v4.view.a.z:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean -> android.support.v4.view.a.aa:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$1 -> android.support.v4.view.a.ab:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge val$bridge -> a
    android.view.accessibility.AccessibilityNodeInfo createAccessibilityNodeInfo(int) -> createAccessibilityNodeInfo
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> findAccessibilityNodeInfosByText
    boolean performAction(int,int,android.os.Bundle) -> performAction
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge -> android.support.v4.view.a.ac:
    java.lang.Object createAccessibilityNodeInfo(int) -> a
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
android.support.v4.view.accessibility.AccessibilityRecordCompat -> android.support.v4.view.a.ad:
    android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordImpl IMPL -> a
    java.lang.Object mRecord -> b
    java.lang.Object getImpl() -> a
    android.support.v4.view.accessibility.AccessibilityRecordCompat obtain(android.support.v4.view.accessibility.AccessibilityRecordCompat) -> a
    android.support.v4.view.accessibility.AccessibilityRecordCompat obtain() -> b
    void setSource(android.view.View) -> a
    void setSource(android.view.View,int) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getSource() -> c
    int getWindowId() -> d
    boolean isChecked() -> e
    void setChecked(boolean) -> a
    boolean isEnabled() -> f
    void setEnabled(boolean) -> b
    boolean isPassword() -> g
    void setPassword(boolean) -> c
    boolean isFullScreen() -> h
    void setFullScreen(boolean) -> d
    boolean isScrollable() -> i
    void setScrollable(boolean) -> e
    int getItemCount() -> j
    void setItemCount(int) -> a
    int getCurrentItemIndex() -> k
    void setCurrentItemIndex(int) -> b
    int getFromIndex() -> l
    void setFromIndex(int) -> c
    int getToIndex() -> m
    void setToIndex(int) -> d
    int getScrollX() -> n
    void setScrollX(int) -> e
    int getScrollY() -> o
    void setScrollY(int) -> f
    int getMaxScrollX() -> p
    void setMaxScrollX(int) -> g
    int getMaxScrollY() -> q
    void setMaxScrollY(int) -> h
    int getAddedCount() -> r
    void setAddedCount(int) -> i
    int getRemovedCount() -> s
    void setRemovedCount(int) -> j
    java.lang.CharSequence getClassName() -> t
    void setClassName(java.lang.CharSequence) -> a
    java.util.List getText() -> u
    java.lang.CharSequence getBeforeText() -> v
    void setBeforeText(java.lang.CharSequence) -> b
    java.lang.CharSequence getContentDescription() -> w
    void setContentDescription(java.lang.CharSequence) -> c
    android.os.Parcelable getParcelableData() -> x
    void setParcelableData(android.os.Parcelable) -> a
    void recycle() -> y
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordIcsImpl -> android.support.v4.view.a.ae:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(java.lang.Object) -> a
    int getAddedCount(java.lang.Object) -> b
    java.lang.CharSequence getBeforeText(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    int getCurrentItemIndex(java.lang.Object) -> f
    int getFromIndex(java.lang.Object) -> g
    int getItemCount(java.lang.Object) -> h
    android.os.Parcelable getParcelableData(java.lang.Object) -> i
    int getRemovedCount(java.lang.Object) -> j
    int getScrollX(java.lang.Object) -> k
    int getScrollY(java.lang.Object) -> l
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getSource(java.lang.Object) -> m
    java.util.List getText(java.lang.Object) -> n
    int getToIndex(java.lang.Object) -> o
    int getWindowId(java.lang.Object) -> p
    boolean isChecked(java.lang.Object) -> q
    boolean isEnabled(java.lang.Object) -> r
    boolean isFullScreen(java.lang.Object) -> s
    boolean isPassword(java.lang.Object) -> t
    boolean isScrollable(java.lang.Object) -> u
    void recycle(java.lang.Object) -> v
    void setAddedCount(java.lang.Object,int) -> a
    void setBeforeText(java.lang.Object,java.lang.CharSequence) -> a
    void setChecked(java.lang.Object,boolean) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> b
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> c
    void setCurrentItemIndex(java.lang.Object,int) -> b
    void setEnabled(java.lang.Object,boolean) -> b
    void setFromIndex(java.lang.Object,int) -> c
    void setFullScreen(java.lang.Object,boolean) -> c
    void setItemCount(java.lang.Object,int) -> d
    void setParcelableData(java.lang.Object,android.os.Parcelable) -> a
    void setPassword(java.lang.Object,boolean) -> d
    void setRemovedCount(java.lang.Object,int) -> e
    void setScrollX(java.lang.Object,int) -> f
    void setScrollY(java.lang.Object,int) -> g
    void setScrollable(java.lang.Object,boolean) -> e
    void setSource(java.lang.Object,android.view.View) -> a
    void setToIndex(java.lang.Object,int) -> h
android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordIcsMr1Impl -> android.support.v4.view.a.af:
    int getMaxScrollX(java.lang.Object) -> w
    int getMaxScrollY(java.lang.Object) -> x
    void setMaxScrollX(java.lang.Object,int) -> i
    void setMaxScrollY(java.lang.Object,int) -> j
android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordImpl -> android.support.v4.view.a.ag:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(java.lang.Object) -> a
    void setSource(java.lang.Object,android.view.View) -> a
    void setSource(java.lang.Object,android.view.View,int) -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getSource(java.lang.Object) -> m
    int getWindowId(java.lang.Object) -> p
    boolean isChecked(java.lang.Object) -> q
    void setChecked(java.lang.Object,boolean) -> a
    boolean isEnabled(java.lang.Object) -> r
    void setEnabled(java.lang.Object,boolean) -> b
    boolean isPassword(java.lang.Object) -> t
    void setPassword(java.lang.Object,boolean) -> d
    boolean isFullScreen(java.lang.Object) -> s
    void setFullScreen(java.lang.Object,boolean) -> c
    boolean isScrollable(java.lang.Object) -> u
    void setScrollable(java.lang.Object,boolean) -> e
    int getItemCount(java.lang.Object) -> h
    void setItemCount(java.lang.Object,int) -> d
    int getCurrentItemIndex(java.lang.Object) -> f
    void setCurrentItemIndex(java.lang.Object,int) -> b
    int getFromIndex(java.lang.Object) -> g
    void setFromIndex(java.lang.Object,int) -> c
    int getToIndex(java.lang.Object) -> o
    void setToIndex(java.lang.Object,int) -> h
    int getScrollX(java.lang.Object) -> k
    void setScrollX(java.lang.Object,int) -> f
    int getScrollY(java.lang.Object) -> l
    void setScrollY(java.lang.Object,int) -> g
    int getMaxScrollX(java.lang.Object) -> w
    void setMaxScrollX(java.lang.Object,int) -> i
    int getMaxScrollY(java.lang.Object) -> x
    void setMaxScrollY(java.lang.Object,int) -> j
    int getAddedCount(java.lang.Object) -> b
    void setAddedCount(java.lang.Object,int) -> a
    int getRemovedCount(java.lang.Object) -> j
    void setRemovedCount(java.lang.Object,int) -> e
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    void setClassName(java.lang.Object,java.lang.CharSequence) -> b
    java.util.List getText(java.lang.Object) -> n
    java.lang.CharSequence getBeforeText(java.lang.Object) -> c
    void setBeforeText(java.lang.Object,java.lang.CharSequence) -> a
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> c
    android.os.Parcelable getParcelableData(java.lang.Object) -> i
    void setParcelableData(java.lang.Object,android.os.Parcelable) -> a
    void recycle(java.lang.Object) -> v
android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordJellyBeanImpl -> android.support.v4.view.a.ah:
    void setSource(java.lang.Object,android.view.View,int) -> a
android.support.v4.view.accessibility.AccessibilityRecordCompat$AccessibilityRecordStubImpl -> android.support.v4.view.a.ai:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(java.lang.Object) -> a
    int getAddedCount(java.lang.Object) -> b
    java.lang.CharSequence getBeforeText(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    int getCurrentItemIndex(java.lang.Object) -> f
    int getFromIndex(java.lang.Object) -> g
    int getItemCount(java.lang.Object) -> h
    int getMaxScrollX(java.lang.Object) -> w
    int getMaxScrollY(java.lang.Object) -> x
    android.os.Parcelable getParcelableData(java.lang.Object) -> i
    int getRemovedCount(java.lang.Object) -> j
    int getScrollX(java.lang.Object) -> k
    int getScrollY(java.lang.Object) -> l
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat getSource(java.lang.Object) -> m
    java.util.List getText(java.lang.Object) -> n
    int getToIndex(java.lang.Object) -> o
    int getWindowId(java.lang.Object) -> p
    boolean isChecked(java.lang.Object) -> q
    boolean isEnabled(java.lang.Object) -> r
    boolean isFullScreen(java.lang.Object) -> s
    boolean isPassword(java.lang.Object) -> t
    boolean isScrollable(java.lang.Object) -> u
    void recycle(java.lang.Object) -> v
    void setAddedCount(java.lang.Object,int) -> a
    void setBeforeText(java.lang.Object,java.lang.CharSequence) -> a
    void setChecked(java.lang.Object,boolean) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> b
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> c
    void setCurrentItemIndex(java.lang.Object,int) -> b
    void setEnabled(java.lang.Object,boolean) -> b
    void setFromIndex(java.lang.Object,int) -> c
    void setFullScreen(java.lang.Object,boolean) -> c
    void setItemCount(java.lang.Object,int) -> d
    void setMaxScrollX(java.lang.Object,int) -> i
    void setMaxScrollY(java.lang.Object,int) -> j
    void setParcelableData(java.lang.Object,android.os.Parcelable) -> a
    void setPassword(java.lang.Object,boolean) -> d
    void setRemovedCount(java.lang.Object,int) -> e
    void setScrollX(java.lang.Object,int) -> f
    void setScrollY(java.lang.Object,int) -> g
    void setScrollable(java.lang.Object,boolean) -> e
    void setSource(java.lang.Object,android.view.View) -> a
    void setSource(java.lang.Object,android.view.View,int) -> a
    void setToIndex(java.lang.Object,int) -> h
android.support.v4.view.accessibility.AccessibilityRecordCompatIcs -> android.support.v4.view.a.aj:
    java.lang.Object obtain() -> a
    java.lang.Object obtain(java.lang.Object) -> a
    int getAddedCount(java.lang.Object) -> b
    java.lang.CharSequence getBeforeText(java.lang.Object) -> c
    java.lang.CharSequence getClassName(java.lang.Object) -> d
    java.lang.CharSequence getContentDescription(java.lang.Object) -> e
    int getCurrentItemIndex(java.lang.Object) -> f
    int getFromIndex(java.lang.Object) -> g
    int getItemCount(java.lang.Object) -> h
    android.os.Parcelable getParcelableData(java.lang.Object) -> i
    int getRemovedCount(java.lang.Object) -> j
    int getScrollX(java.lang.Object) -> k
    int getScrollY(java.lang.Object) -> l
    java.lang.Object getSource(java.lang.Object) -> m
    java.util.List getText(java.lang.Object) -> n
    int getToIndex(java.lang.Object) -> o
    int getWindowId(java.lang.Object) -> p
    boolean isChecked(java.lang.Object) -> q
    boolean isEnabled(java.lang.Object) -> r
    boolean isFullScreen(java.lang.Object) -> s
    boolean isPassword(java.lang.Object) -> t
    boolean isScrollable(java.lang.Object) -> u
    void recycle(java.lang.Object) -> v
    void setAddedCount(java.lang.Object,int) -> a
    void setBeforeText(java.lang.Object,java.lang.CharSequence) -> a
    void setChecked(java.lang.Object,boolean) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> b
    void setContentDescription(java.lang.Object,java.lang.CharSequence) -> c
    void setCurrentItemIndex(java.lang.Object,int) -> b
    void setEnabled(java.lang.Object,boolean) -> b
    void setFromIndex(java.lang.Object,int) -> c
    void setFullScreen(java.lang.Object,boolean) -> c
    void setItemCount(java.lang.Object,int) -> d
    void setParcelableData(java.lang.Object,android.os.Parcelable) -> a
    void setPassword(java.lang.Object,boolean) -> d
    void setRemovedCount(java.lang.Object,int) -> e
    void setScrollX(java.lang.Object,int) -> f
    void setScrollY(java.lang.Object,int) -> g
    void setScrollable(java.lang.Object,boolean) -> e
    void setSource(java.lang.Object,android.view.View) -> a
    void setToIndex(java.lang.Object,int) -> h
android.support.v4.view.accessibility.AccessibilityRecordCompatIcsMr1 -> android.support.v4.view.a.ak:
    int getMaxScrollX(java.lang.Object) -> a
    int getMaxScrollY(java.lang.Object) -> b
    void setMaxScrollX(java.lang.Object,int) -> a
    void setMaxScrollY(java.lang.Object,int) -> b
android.support.v4.view.accessibility.AccessibilityRecordCompatJellyBean -> android.support.v4.view.a.al:
    void setSource(java.lang.Object,android.view.View,int) -> a
android.support.v4.widget.CursorAdapter -> android.support.v4.widget.a:
    boolean mDataValid -> a
    boolean mAutoRequery -> b
    android.database.Cursor mCursor -> c
    android.content.Context mContext -> d
    int mRowIDColumn -> e
    android.support.v4.widget.CursorAdapter$ChangeObserver mChangeObserver -> f
    android.database.DataSetObserver mDataSetObserver -> g
    android.support.v4.widget.CursorFilter mCursorFilter -> h
    android.widget.FilterQueryProvider mFilterQueryProvider -> i
    int FLAG_AUTO_REQUERY -> j
    int FLAG_REGISTER_CONTENT_OBSERVER -> k
    void init(android.content.Context,android.database.Cursor,boolean) -> a
    void init(android.content.Context,android.database.Cursor,int) -> a
    android.database.Cursor getCursor() -> a
    int getCount() -> getCount
    java.lang.Object getItem(int) -> getItem
    long getItemId(int) -> getItemId
    boolean hasStableIds() -> hasStableIds
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    android.view.View getDropDownView(int,android.view.View,android.view.ViewGroup) -> getDropDownView
    android.view.View newView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> a
    android.view.View newDropDownView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> b
    void bindView(android.view.View,android.content.Context,android.database.Cursor) -> a
    void changeCursor(android.database.Cursor) -> a
    android.database.Cursor swapCursor(android.database.Cursor) -> b
    java.lang.CharSequence convertToString(android.database.Cursor) -> c
    android.database.Cursor runQueryOnBackgroundThread(java.lang.CharSequence) -> a
    android.widget.Filter getFilter() -> getFilter
    android.widget.FilterQueryProvider getFilterQueryProvider() -> b
    void setFilterQueryProvider(android.widget.FilterQueryProvider) -> a
    void onContentChanged() -> c
android.support.v4.widget.CursorAdapter$1 -> android.support.v4.widget.b:
android.support.v4.widget.CursorAdapter$ChangeObserver -> android.support.v4.widget.c:
    android.support.v4.widget.CursorAdapter this$0 -> a
    boolean deliverSelfNotifications() -> deliverSelfNotifications
    void onChange(boolean) -> onChange
android.support.v4.widget.CursorAdapter$MyDataSetObserver -> android.support.v4.widget.d:
    android.support.v4.widget.CursorAdapter this$0 -> a
    void onChanged() -> onChanged
    void onInvalidated() -> onInvalidated
android.support.v4.widget.CursorFilter -> android.support.v4.widget.e:
    android.support.v4.widget.CursorFilter$CursorFilterClient mClient -> a
    java.lang.CharSequence convertResultToString(java.lang.Object) -> convertResultToString
    android.widget.Filter$FilterResults performFiltering(java.lang.CharSequence) -> performFiltering
    void publishResults(java.lang.CharSequence,android.widget.Filter$FilterResults) -> publishResults
android.support.v4.widget.CursorFilter$CursorFilterClient -> android.support.v4.widget.f:
    java.lang.CharSequence convertToString(android.database.Cursor) -> c
    android.database.Cursor runQueryOnBackgroundThread(java.lang.CharSequence) -> a
    android.database.Cursor getCursor() -> a
    void changeCursor(android.database.Cursor) -> a
android.support.v4.widget.DrawerLayout -> android.support.v4.widget.DrawerLayout:
    java.lang.String TAG -> g
    int STATE_IDLE -> a
    int STATE_DRAGGING -> b
    int STATE_SETTLING -> c
    int LOCK_MODE_UNLOCKED -> d
    int LOCK_MODE_LOCKED_CLOSED -> e
    int LOCK_MODE_LOCKED_OPEN -> f
    int MIN_DRAWER_MARGIN -> h
    int DEFAULT_SCRIM_COLOR -> i
    int PEEK_DELAY -> j
    int MIN_FLING_VELOCITY -> k
    boolean ALLOW_EDGE_LOCK -> l
    int[] LAYOUT_ATTRS -> m
    int mMinDrawerMargin -> n
    int mScrimColor -> o
    float mScrimOpacity -> p
    android.graphics.Paint mScrimPaint -> q
    android.support.v4.widget.ViewDragHelper mLeftDragger -> r
    android.support.v4.widget.ViewDragHelper mRightDragger -> s
    android.support.v4.widget.DrawerLayout$ViewDragCallback mLeftCallback -> t
    android.support.v4.widget.DrawerLayout$ViewDragCallback mRightCallback -> u
    int mDrawerState -> v
    boolean mInLayout -> w
    boolean mFirstLayout -> x
    int mLockModeLeft -> y
    int mLockModeRight -> z
    boolean mDisallowInterceptRequested -> A
    boolean mChildrenCanceledTouch -> B
    android.support.v4.widget.DrawerLayout$DrawerListener mListener -> C
    float mInitialMotionX -> D
    float mInitialMotionY -> E
    android.graphics.drawable.Drawable mShadowLeft -> F
    android.graphics.drawable.Drawable mShadowRight -> G
    void setDrawerShadow(android.graphics.drawable.Drawable,int) -> a
    void setDrawerShadow(int,int) -> a
    void setScrimColor(int) -> setScrimColor
    void setDrawerListener(android.support.v4.widget.DrawerLayout$DrawerListener) -> setDrawerListener
    void setDrawerLockMode(int) -> setDrawerLockMode
    void setDrawerLockMode(int,int) -> b
    void setDrawerLockMode(int,android.view.View) -> a
    int getDrawerLockMode(int) -> a
    int getDrawerLockMode(android.view.View) -> a
    void updateDrawerState(int,int,android.view.View) -> a
    void dispatchOnDrawerClosed(android.view.View) -> b
    void dispatchOnDrawerOpened(android.view.View) -> c
    void dispatchOnDrawerSlide(android.view.View,float) -> a
    void setDrawerViewOffset(android.view.View,float) -> b
    float getDrawerViewOffset(android.view.View) -> d
    int getDrawerViewGravity(android.view.View) -> e
    boolean checkDrawerViewGravity(android.view.View,int) -> a
    android.view.View findOpenDrawer() -> a
    void moveDrawerToOffset(android.view.View,float) -> c
    android.view.View findDrawerWithGravity(int) -> b
    java.lang.String gravityToString(int) -> c
    void onDetachedFromWindow() -> onDetachedFromWindow
    void onAttachedToWindow() -> onAttachedToWindow
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
    void requestLayout() -> requestLayout
    void computeScroll() -> computeScroll
    boolean hasOpaqueBackground(android.view.View) -> l
    boolean drawChild(android.graphics.Canvas,android.view.View,long) -> drawChild
    boolean isContentView(android.view.View) -> f
    boolean isDrawerView(android.view.View) -> g
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void requestDisallowInterceptTouchEvent(boolean) -> requestDisallowInterceptTouchEvent
    void closeDrawers() -> b
    void closeDrawers(boolean) -> a
    void openDrawer(android.view.View) -> h
    void openDrawer(int) -> d
    void closeDrawer(android.view.View) -> i
    void closeDrawer(int) -> e
    boolean isDrawerOpen(android.view.View) -> j
    boolean isDrawerOpen(int) -> f
    boolean isDrawerVisible(android.view.View) -> k
    boolean isDrawerVisible(int) -> g
    boolean hasPeekingDrawer() -> e
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    boolean hasVisibleDrawer() -> f
    android.view.View findVisibleDrawer() -> g
    void cancelChildViewTouch() -> c
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    boolean onKeyUp(int,android.view.KeyEvent) -> onKeyUp
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    int[] access$100() -> d
android.support.v4.widget.DrawerLayout$AccessibilityDelegate -> android.support.v4.widget.g:
    android.graphics.Rect mTmpRect -> c
    android.support.v4.widget.DrawerLayout this$0 -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    boolean filter(android.view.View) -> b
    void copyNodeInfoNoChildren(android.support.v4.view.accessibility.AccessibilityNodeInfoCompat,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
android.support.v4.widget.DrawerLayout$DrawerListener -> android.support.v4.widget.h:
    void onDrawerSlide(android.view.View,float) -> a
    void onDrawerOpened(android.view.View) -> a
    void onDrawerClosed(android.view.View) -> b
    void onDrawerStateChanged(int) -> a
android.support.v4.widget.DrawerLayout$LayoutParams -> android.support.v4.widget.i:
    int gravity -> a
    float onScreen -> b
    boolean isPeeking -> c
    boolean knownOpen -> d
android.support.v4.widget.DrawerLayout$SavedState -> android.support.v4.widget.DrawerLayout$SavedState:
    int openDrawerGravity -> a
    int lockModeLeft -> b
    int lockModeRight -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.widget.DrawerLayout$SavedState$1 -> android.support.v4.widget.j:
    android.support.v4.widget.DrawerLayout$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.widget.DrawerLayout$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.widget.DrawerLayout$SimpleDrawerListener -> android.support.v4.widget.k:
    void onDrawerSlide(android.view.View,float) -> a
    void onDrawerOpened(android.view.View) -> a
    void onDrawerClosed(android.view.View) -> b
    void onDrawerStateChanged(int) -> a
android.support.v4.widget.DrawerLayout$ViewDragCallback -> android.support.v4.widget.l:
    int mGravity -> b
    android.support.v4.widget.ViewDragHelper mDragger -> c
    java.lang.Runnable mPeekRunnable -> d
    android.support.v4.widget.DrawerLayout this$0 -> a
    void setDragger(android.support.v4.widget.ViewDragHelper) -> a
    void removeCallbacks() -> a
    boolean tryCaptureView(android.view.View,int) -> a
    void onViewDragStateChanged(int) -> a
    void onViewPositionChanged(android.view.View,int,int,int,int) -> a
    void onViewCaptured(android.view.View,int) -> b
    void closeOtherDrawer() -> b
    void onViewReleased(android.view.View,float,float) -> a
    void onEdgeTouched(int,int) -> a
    void peekDrawer() -> c
    boolean onEdgeLock(int) -> b
    void onEdgeDragStarted(int,int) -> b
    int getViewHorizontalDragRange(android.view.View) -> a
    int clampViewPositionHorizontal(android.view.View,int,int) -> a
    int clampViewPositionVertical(android.view.View,int,int) -> b
    void access$000(android.support.v4.widget.DrawerLayout$ViewDragCallback) -> a
android.support.v4.widget.DrawerLayout$ViewDragCallback$1 -> android.support.v4.widget.m:
    android.support.v4.widget.DrawerLayout$ViewDragCallback this$1 -> a
    void run() -> run
android.support.v4.widget.EdgeEffectCompat -> android.support.v4.widget.n:
    java.lang.Object mEdgeEffect -> a
    android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl IMPL -> b
    void setSize(int,int) -> a
    boolean isFinished() -> a
    void finish() -> b
    boolean onPull(float) -> a
    boolean onRelease() -> c
    boolean onAbsorb(int) -> a
    boolean draw(android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$BaseEdgeEffectImpl -> android.support.v4.widget.o:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean onAbsorb(java.lang.Object,int) -> a
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectIcsImpl -> android.support.v4.widget.p:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean onAbsorb(java.lang.Object,int) -> a
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl -> android.support.v4.widget.q:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean onAbsorb(java.lang.Object,int) -> a
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompatIcs -> android.support.v4.widget.r:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean onAbsorb(java.lang.Object,int) -> a
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.ResourceCursorAdapter -> android.support.v4.widget.s:
    int mLayout -> l
    int mDropDownLayout -> m
    android.view.LayoutInflater mInflater -> n
    android.view.View newView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> a
    android.view.View newDropDownView(android.content.Context,android.database.Cursor,android.view.ViewGroup) -> b
    void setViewResource(int) -> a
    void setDropDownViewResource(int) -> b
android.support.v4.widget.ScrollerCompat -> android.support.v4.widget.t:
    java.lang.Object mScroller -> a
    android.support.v4.widget.ScrollerCompat$ScrollerCompatImpl IMPL -> b
    android.support.v4.widget.ScrollerCompat create(android.content.Context) -> a
    android.support.v4.widget.ScrollerCompat create(android.content.Context,android.view.animation.Interpolator) -> a
    boolean isFinished() -> a
    int getCurrX() -> b
    int getCurrY() -> c
    int getFinalX() -> d
    int getFinalY() -> e
    float getCurrVelocity() -> f
    boolean computeScrollOffset() -> g
    void startScroll(int,int,int,int) -> a
    void startScroll(int,int,int,int,int) -> a
    void fling(int,int,int,int,int,int,int,int) -> a
    void fling(int,int,int,int,int,int,int,int,int,int) -> a
    void abortAnimation() -> h
    void notifyHorizontalEdgeReached(int,int,int) -> a
    void notifyVerticalEdgeReached(int,int,int) -> b
    boolean isOverScrolled() -> i
android.support.v4.widget.ScrollerCompat$ScrollerCompatImpl -> android.support.v4.widget.u:
    java.lang.Object createScroller(android.content.Context,android.view.animation.Interpolator) -> a
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    float getCurrVelocity(java.lang.Object) -> d
    boolean computeScrollOffset(java.lang.Object) -> e
    void startScroll(java.lang.Object,int,int,int,int) -> a
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> f
    void notifyHorizontalEdgeReached(java.lang.Object,int,int,int) -> a
    void notifyVerticalEdgeReached(java.lang.Object,int,int,int) -> b
    boolean isOverScrolled(java.lang.Object) -> g
    int getFinalX(java.lang.Object) -> h
    int getFinalY(java.lang.Object) -> i
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplBase -> android.support.v4.widget.v:
    java.lang.Object createScroller(android.content.Context,android.view.animation.Interpolator) -> a
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    float getCurrVelocity(java.lang.Object) -> d
    boolean computeScrollOffset(java.lang.Object) -> e
    void startScroll(java.lang.Object,int,int,int,int) -> a
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> f
    void notifyHorizontalEdgeReached(java.lang.Object,int,int,int) -> a
    void notifyVerticalEdgeReached(java.lang.Object,int,int,int) -> b
    boolean isOverScrolled(java.lang.Object) -> g
    int getFinalX(java.lang.Object) -> h
    int getFinalY(java.lang.Object) -> i
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplGingerbread -> android.support.v4.widget.w:
    java.lang.Object createScroller(android.content.Context,android.view.animation.Interpolator) -> a
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    float getCurrVelocity(java.lang.Object) -> d
    boolean computeScrollOffset(java.lang.Object) -> e
    void startScroll(java.lang.Object,int,int,int,int) -> a
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> f
    void notifyHorizontalEdgeReached(java.lang.Object,int,int,int) -> a
    void notifyVerticalEdgeReached(java.lang.Object,int,int,int) -> b
    boolean isOverScrolled(java.lang.Object) -> g
    int getFinalX(java.lang.Object) -> h
    int getFinalY(java.lang.Object) -> i
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplIcs -> android.support.v4.widget.x:
    float getCurrVelocity(java.lang.Object) -> d
android.support.v4.widget.ScrollerCompatGingerbread -> android.support.v4.widget.y:
    java.lang.Object createScroller(android.content.Context,android.view.animation.Interpolator) -> a
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    boolean computeScrollOffset(java.lang.Object) -> d
    void startScroll(java.lang.Object,int,int,int,int) -> a
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int) -> a
    void fling(java.lang.Object,int,int,int,int,int,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> e
    void notifyHorizontalEdgeReached(java.lang.Object,int,int,int) -> a
    void notifyVerticalEdgeReached(java.lang.Object,int,int,int) -> b
    boolean isOverScrolled(java.lang.Object) -> f
    int getFinalX(java.lang.Object) -> g
    int getFinalY(java.lang.Object) -> h
android.support.v4.widget.ScrollerCompatIcs -> android.support.v4.widget.z:
    float getCurrVelocity(java.lang.Object) -> a
android.support.v4.widget.SearchViewCompat -> android.support.v4.widget.aa:
    android.support.v4.widget.SearchViewCompat$SearchViewCompatImpl IMPL -> a
    android.view.View newSearchView(android.content.Context) -> a
    void setSearchableInfo(android.view.View,android.content.ComponentName) -> a
    void setImeOptions(android.view.View,int) -> a
    void setInputType(android.view.View,int) -> b
    void setOnQueryTextListener(android.view.View,android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat) -> a
    void setOnCloseListener(android.view.View,android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat) -> a
    java.lang.CharSequence getQuery(android.view.View) -> a
    void setQuery(android.view.View,java.lang.CharSequence,boolean) -> a
    void setQueryHint(android.view.View,java.lang.CharSequence) -> a
    void setIconified(android.view.View,boolean) -> a
    boolean isIconified(android.view.View) -> b
    void setSubmitButtonEnabled(android.view.View,boolean) -> b
    boolean isSubmitButtonEnabled(android.view.View) -> c
    void setQueryRefinementEnabled(android.view.View,boolean) -> c
    boolean isQueryRefinementEnabled(android.view.View) -> d
    void setMaxWidth(android.view.View,int) -> c
    android.support.v4.widget.SearchViewCompat$SearchViewCompatImpl access$000() -> a
android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat -> android.support.v4.widget.ab:
    java.lang.Object mListener -> a
    boolean onClose() -> a
android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat -> android.support.v4.widget.ac:
    java.lang.Object mListener -> a
    boolean onQueryTextSubmit(java.lang.String) -> a
    boolean onQueryTextChange(java.lang.String) -> b
android.support.v4.widget.SearchViewCompat$SearchViewCompatHoneycombImpl -> android.support.v4.widget.ad:
    android.view.View newSearchView(android.content.Context) -> a
    void setSearchableInfo(android.view.View,android.content.ComponentName) -> a
    java.lang.Object newOnQueryTextListener(android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat) -> a
    void setOnQueryTextListener(java.lang.Object,java.lang.Object) -> a
    java.lang.Object newOnCloseListener(android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat) -> a
    void setOnCloseListener(java.lang.Object,java.lang.Object) -> b
    java.lang.CharSequence getQuery(android.view.View) -> a
    void setQuery(android.view.View,java.lang.CharSequence,boolean) -> a
    void setQueryHint(android.view.View,java.lang.CharSequence) -> a
    void setIconified(android.view.View,boolean) -> a
    boolean isIconified(android.view.View) -> b
    void setSubmitButtonEnabled(android.view.View,boolean) -> b
    boolean isSubmitButtonEnabled(android.view.View) -> c
    void setQueryRefinementEnabled(android.view.View,boolean) -> c
    boolean isQueryRefinementEnabled(android.view.View) -> d
    void setMaxWidth(android.view.View,int) -> a
android.support.v4.widget.SearchViewCompat$SearchViewCompatHoneycombImpl$1 -> android.support.v4.widget.ae:
    android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat val$listener -> a
    android.support.v4.widget.SearchViewCompat$SearchViewCompatHoneycombImpl this$0 -> b
    boolean onQueryTextSubmit(java.lang.String) -> a
    boolean onQueryTextChange(java.lang.String) -> b
android.support.v4.widget.SearchViewCompat$SearchViewCompatHoneycombImpl$2 -> android.support.v4.widget.af:
    android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat val$listener -> a
    android.support.v4.widget.SearchViewCompat$SearchViewCompatHoneycombImpl this$0 -> b
    boolean onClose() -> a
android.support.v4.widget.SearchViewCompat$SearchViewCompatIcsImpl -> android.support.v4.widget.ag:
    android.view.View newSearchView(android.content.Context) -> a
    void setImeOptions(android.view.View,int) -> b
    void setInputType(android.view.View,int) -> c
android.support.v4.widget.SearchViewCompat$SearchViewCompatImpl -> android.support.v4.widget.ah:
    android.view.View newSearchView(android.content.Context) -> a
    void setSearchableInfo(android.view.View,android.content.ComponentName) -> a
    void setImeOptions(android.view.View,int) -> b
    void setInputType(android.view.View,int) -> c
    java.lang.Object newOnQueryTextListener(android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat) -> a
    void setOnQueryTextListener(java.lang.Object,java.lang.Object) -> a
    java.lang.Object newOnCloseListener(android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat) -> a
    void setOnCloseListener(java.lang.Object,java.lang.Object) -> b
    java.lang.CharSequence getQuery(android.view.View) -> a
    void setQuery(android.view.View,java.lang.CharSequence,boolean) -> a
    void setQueryHint(android.view.View,java.lang.CharSequence) -> a
    void setIconified(android.view.View,boolean) -> a
    boolean isIconified(android.view.View) -> b
    void setSubmitButtonEnabled(android.view.View,boolean) -> b
    boolean isSubmitButtonEnabled(android.view.View) -> c
    void setQueryRefinementEnabled(android.view.View,boolean) -> c
    boolean isQueryRefinementEnabled(android.view.View) -> d
    void setMaxWidth(android.view.View,int) -> a
android.support.v4.widget.SearchViewCompat$SearchViewCompatStubImpl -> android.support.v4.widget.ai:
    android.view.View newSearchView(android.content.Context) -> a
    void setSearchableInfo(android.view.View,android.content.ComponentName) -> a
    void setImeOptions(android.view.View,int) -> b
    void setInputType(android.view.View,int) -> c
    java.lang.Object newOnQueryTextListener(android.support.v4.widget.SearchViewCompat$OnQueryTextListenerCompat) -> a
    void setOnQueryTextListener(java.lang.Object,java.lang.Object) -> a
    java.lang.Object newOnCloseListener(android.support.v4.widget.SearchViewCompat$OnCloseListenerCompat) -> a
    void setOnCloseListener(java.lang.Object,java.lang.Object) -> b
    java.lang.CharSequence getQuery(android.view.View) -> a
    void setQuery(android.view.View,java.lang.CharSequence,boolean) -> a
    void setQueryHint(android.view.View,java.lang.CharSequence) -> a
    void setIconified(android.view.View,boolean) -> a
    boolean isIconified(android.view.View) -> b
    void setSubmitButtonEnabled(android.view.View,boolean) -> b
    boolean isSubmitButtonEnabled(android.view.View) -> c
    void setQueryRefinementEnabled(android.view.View,boolean) -> c
    boolean isQueryRefinementEnabled(android.view.View) -> d
    void setMaxWidth(android.view.View,int) -> a
android.support.v4.widget.SearchViewCompatHoneycomb -> android.support.v4.widget.aj:
    android.view.View newSearchView(android.content.Context) -> a
    void setSearchableInfo(android.view.View,android.content.ComponentName) -> a
    java.lang.Object newOnQueryTextListener(android.support.v4.widget.SearchViewCompatHoneycomb$OnQueryTextListenerCompatBridge) -> a
    void setOnQueryTextListener(java.lang.Object,java.lang.Object) -> a
    java.lang.Object newOnCloseListener(android.support.v4.widget.SearchViewCompatHoneycomb$OnCloseListenerCompatBridge) -> a
    void setOnCloseListener(java.lang.Object,java.lang.Object) -> b
    java.lang.CharSequence getQuery(android.view.View) -> a
    void setQuery(android.view.View,java.lang.CharSequence,boolean) -> a
    void setQueryHint(android.view.View,java.lang.CharSequence) -> a
    void setIconified(android.view.View,boolean) -> a
    boolean isIconified(android.view.View) -> b
    void setSubmitButtonEnabled(android.view.View,boolean) -> b
    boolean isSubmitButtonEnabled(android.view.View) -> c
    void setQueryRefinementEnabled(android.view.View,boolean) -> c
    boolean isQueryRefinementEnabled(android.view.View) -> d
    void setMaxWidth(android.view.View,int) -> a
android.support.v4.widget.SearchViewCompatHoneycomb$1 -> android.support.v4.widget.ak:
    android.support.v4.widget.SearchViewCompatHoneycomb$OnQueryTextListenerCompatBridge val$listener -> a
    boolean onQueryTextSubmit(java.lang.String) -> onQueryTextSubmit
    boolean onQueryTextChange(java.lang.String) -> onQueryTextChange
android.support.v4.widget.SearchViewCompatHoneycomb$2 -> android.support.v4.widget.al:
    android.support.v4.widget.SearchViewCompatHoneycomb$OnCloseListenerCompatBridge val$listener -> a
    boolean onClose() -> onClose
android.support.v4.widget.SearchViewCompatHoneycomb$OnCloseListenerCompatBridge -> android.support.v4.widget.am:
    boolean onClose() -> a
android.support.v4.widget.SearchViewCompatHoneycomb$OnQueryTextListenerCompatBridge -> android.support.v4.widget.an:
    boolean onQueryTextSubmit(java.lang.String) -> a
    boolean onQueryTextChange(java.lang.String) -> b
android.support.v4.widget.SearchViewCompatIcs -> android.support.v4.widget.ao:
    android.view.View newSearchView(android.content.Context) -> a
    void setImeOptions(android.view.View,int) -> a
    void setInputType(android.view.View,int) -> b
android.support.v4.widget.SearchViewCompatIcs$MySearchView -> android.support.v4.widget.ap:
    void onActionViewCollapsed() -> onActionViewCollapsed
android.support.v4.widget.SimpleCursorAdapter -> android.support.v4.widget.aq:
    int[] mFrom -> l
    int[] mTo -> m
    int mStringConversionColumn -> o
    android.support.v4.widget.SimpleCursorAdapter$CursorToStringConverter mCursorToStringConverter -> p
    android.support.v4.widget.SimpleCursorAdapter$ViewBinder mViewBinder -> q
    java.lang.String[] mOriginalFrom -> n
    void bindView(android.view.View,android.content.Context,android.database.Cursor) -> a
    android.support.v4.widget.SimpleCursorAdapter$ViewBinder getViewBinder() -> d
    void setViewBinder(android.support.v4.widget.SimpleCursorAdapter$ViewBinder) -> a
    void setViewImage(android.widget.ImageView,java.lang.String) -> a
    void setViewText(android.widget.TextView,java.lang.String) -> a
    int getStringConversionColumn() -> e
    void setStringConversionColumn(int) -> c
    android.support.v4.widget.SimpleCursorAdapter$CursorToStringConverter getCursorToStringConverter() -> f
    void setCursorToStringConverter(android.support.v4.widget.SimpleCursorAdapter$CursorToStringConverter) -> a
    java.lang.CharSequence convertToString(android.database.Cursor) -> c
    void findColumns(java.lang.String[]) -> a
    android.database.Cursor swapCursor(android.database.Cursor) -> b
    void changeCursorAndColumns(android.database.Cursor,java.lang.String[],int[]) -> a
android.support.v4.widget.SimpleCursorAdapter$CursorToStringConverter -> android.support.v4.widget.ar:
    java.lang.CharSequence convertToString(android.database.Cursor) -> a
android.support.v4.widget.SimpleCursorAdapter$ViewBinder -> android.support.v4.widget.as:
    boolean setViewValue(android.view.View,android.database.Cursor,int) -> a
android.support.v4.widget.SlidingPaneLayout -> android.support.v4.widget.SlidingPaneLayout:
    java.lang.String TAG -> b
    int DEFAULT_OVERHANG_SIZE -> c
    int DEFAULT_FADE_COLOR -> d
    int mSliderFadeColor -> e
    int MIN_FLING_VELOCITY -> f
    int mCoveredFadeColor -> g
    android.graphics.drawable.Drawable mShadowDrawable -> h
    int mOverhangSize -> i
    boolean mCanSlide -> j
    android.view.View mSlideableView -> k
    float mSlideOffset -> l
    float mParallaxOffset -> m
    int mSlideRange -> n
    boolean mIsUnableToDrag -> o
    int mParallaxBy -> p
    float mInitialMotionX -> q
    float mInitialMotionY -> r
    android.support.v4.widget.SlidingPaneLayout$PanelSlideListener mPanelSlideListener -> s
    android.support.v4.widget.ViewDragHelper mDragHelper -> t
    boolean mPreservedOpenState -> u
    boolean mFirstLayout -> v
    android.graphics.Rect mTmpRect -> w
    java.util.ArrayList mPostedRunnables -> x
    android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImpl IMPL -> a
    void setParallaxDistance(int) -> setParallaxDistance
    int getParallaxDistance() -> getParallaxDistance
    void setSliderFadeColor(int) -> setSliderFadeColor
    int getSliderFadeColor() -> getSliderFadeColor
    void setCoveredFadeColor(int) -> setCoveredFadeColor
    int getCoveredFadeColor() -> getCoveredFadeColor
    void setPanelSlideListener(android.support.v4.widget.SlidingPaneLayout$PanelSlideListener) -> setPanelSlideListener
    void dispatchOnPanelSlide(android.view.View) -> a
    void dispatchOnPanelOpened(android.view.View) -> b
    void dispatchOnPanelClosed(android.view.View) -> c
    void updateObscuredViewsVisibility(android.view.View) -> d
    void setAllChildrenVisible() -> a
    boolean hasOpaqueBackground(android.view.View) -> f
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    void requestChildFocus(android.view.View,android.view.View) -> requestChildFocus
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    boolean closePane(android.view.View,int) -> a
    boolean openPane(android.view.View,int) -> b
    void smoothSlideOpen() -> b
    boolean openPane() -> c
    void smoothSlideClosed() -> d
    boolean closePane() -> e
    boolean isOpen() -> f
    boolean canSlide() -> g
    boolean isSlideable() -> h
    void onPanelDragged(int) -> a
    void dimChildView(android.view.View,float,int) -> a
    boolean drawChild(android.graphics.Canvas,android.view.View,long) -> drawChild
    void invalidateChildRegion(android.view.View) -> g
    boolean smoothSlideTo(float,int) -> a
    void computeScroll() -> computeScroll
    void setShadowDrawable(android.graphics.drawable.Drawable) -> setShadowDrawable
    void setShadowResource(int) -> setShadowResource
    void draw(android.graphics.Canvas) -> draw
    void parallaxOtherViews(float) -> a
    boolean canScroll(android.view.View,boolean,int,int,int) -> a
    boolean isDimmed(android.view.View) -> e
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    boolean access$100(android.support.v4.widget.SlidingPaneLayout) -> a
    android.support.v4.widget.ViewDragHelper access$200(android.support.v4.widget.SlidingPaneLayout) -> b
    float access$300(android.support.v4.widget.SlidingPaneLayout) -> c
    android.view.View access$400(android.support.v4.widget.SlidingPaneLayout) -> d
    boolean access$502(android.support.v4.widget.SlidingPaneLayout,boolean) -> a
    void access$600(android.support.v4.widget.SlidingPaneLayout,int) -> a
    int access$700(android.support.v4.widget.SlidingPaneLayout) -> e
    void access$900(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
    java.util.ArrayList access$1000(android.support.v4.widget.SlidingPaneLayout) -> f
android.support.v4.widget.SlidingPaneLayout$1 -> android.support.v4.widget.at:
android.support.v4.widget.SlidingPaneLayout$AccessibilityDelegate -> android.support.v4.widget.au:
    android.graphics.Rect mTmpRect -> c
    android.support.v4.widget.SlidingPaneLayout this$0 -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    boolean filter(android.view.View) -> b
    void copyNodeInfoNoChildren(android.support.v4.view.accessibility.AccessibilityNodeInfoCompat,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
android.support.v4.widget.SlidingPaneLayout$DisableLayerRunnable -> android.support.v4.widget.av:
    android.view.View mChildView -> a
    android.support.v4.widget.SlidingPaneLayout this$0 -> b
    void run() -> run
android.support.v4.widget.SlidingPaneLayout$DragHelperCallback -> android.support.v4.widget.aw:
    android.support.v4.widget.SlidingPaneLayout this$0 -> a
    boolean tryCaptureView(android.view.View,int) -> a
    void onViewDragStateChanged(int) -> a
    void onViewCaptured(android.view.View,int) -> b
    void onViewPositionChanged(android.view.View,int,int,int,int) -> a
    void onViewReleased(android.view.View,float,float) -> a
    int getViewHorizontalDragRange(android.view.View) -> a
    int clampViewPositionHorizontal(android.view.View,int,int) -> a
    void onEdgeDragStarted(int,int) -> b
android.support.v4.widget.SlidingPaneLayout$LayoutParams -> android.support.v4.widget.ax:
    int[] ATTRS -> e
    float weight -> a
    boolean slideable -> b
    boolean dimWhenOffset -> c
    android.graphics.Paint dimPaint -> d
android.support.v4.widget.SlidingPaneLayout$PanelSlideListener -> android.support.v4.widget.ay:
    void onPanelSlide(android.view.View,float) -> a
    void onPanelOpened(android.view.View) -> a
    void onPanelClosed(android.view.View) -> b
android.support.v4.widget.SlidingPaneLayout$SavedState -> android.support.v4.widget.SlidingPaneLayout$SavedState:
    boolean isOpen -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.widget.SlidingPaneLayout$SavedState$1 -> android.support.v4.widget.az:
    android.support.v4.widget.SlidingPaneLayout$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.widget.SlidingPaneLayout$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.widget.SlidingPaneLayout$SimplePanelSlideListener -> android.support.v4.widget.ba:
    void onPanelSlide(android.view.View,float) -> a
    void onPanelOpened(android.view.View) -> a
    void onPanelClosed(android.view.View) -> b
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImpl -> android.support.v4.widget.bb:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplBase -> android.support.v4.widget.bc:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplJB -> android.support.v4.widget.bd:
    java.lang.reflect.Method mGetDisplayList -> a
    java.lang.reflect.Field mRecreateDisplayList -> b
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplJBMR1 -> android.support.v4.widget.be:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.ViewDragHelper -> android.support.v4.widget.bf:
    java.lang.String TAG -> m
    int INVALID_POINTER -> a
    int STATE_IDLE -> b
    int STATE_DRAGGING -> c
    int STATE_SETTLING -> d
    int EDGE_LEFT -> e
    int EDGE_RIGHT -> f
    int EDGE_TOP -> g
    int EDGE_BOTTOM -> h
    int EDGE_ALL -> i
    int DIRECTION_HORIZONTAL -> j
    int DIRECTION_VERTICAL -> k
    int DIRECTION_ALL -> l
    int EDGE_SIZE -> n
    int BASE_SETTLE_DURATION -> o
    int MAX_SETTLE_DURATION -> p
    int mDragState -> q
    int mTouchSlop -> r
    int mActivePointerId -> s
    float[] mInitialMotionX -> t
    float[] mInitialMotionY -> u
    float[] mLastMotionX -> v
    float[] mLastMotionY -> w
    int[] mInitialEdgesTouched -> x
    int[] mEdgeDragsInProgress -> y
    int[] mEdgeDragsLocked -> z
    int mPointersDown -> A
    android.view.VelocityTracker mVelocityTracker -> B
    float mMaxVelocity -> C
    float mMinVelocity -> D
    int mEdgeSize -> E
    int mTrackingEdges -> F
    android.support.v4.widget.ScrollerCompat mScroller -> G
    android.support.v4.widget.ViewDragHelper$Callback mCallback -> H
    android.view.View mCapturedView -> I
    boolean mReleaseInProgress -> J
    android.view.ViewGroup mParentView -> K
    android.view.animation.Interpolator sInterpolator -> L
    java.lang.Runnable mSetIdleRunnable -> M
    android.support.v4.widget.ViewDragHelper create(android.view.ViewGroup,android.support.v4.widget.ViewDragHelper$Callback) -> a
    android.support.v4.widget.ViewDragHelper create(android.view.ViewGroup,float,android.support.v4.widget.ViewDragHelper$Callback) -> a
    void setMinVelocity(float) -> a
    float getMinVelocity() -> a
    int getViewDragState() -> b
    void setEdgeTrackingEnabled(int) -> a
    int getEdgeSize() -> c
    void captureChildView(android.view.View,int) -> a
    android.view.View getCapturedView() -> d
    int getActivePointerId() -> e
    int getTouchSlop() -> f
    void cancel() -> g
    void abort() -> h
    boolean smoothSlideViewTo(android.view.View,int,int) -> a
    boolean settleCapturedViewAt(int,int) -> a
    boolean forceSettleCapturedViewAt(int,int,int,int) -> b
    int computeSettleDuration(android.view.View,int,int,int,int) -> a
    int computeAxisDuration(int,int,int) -> a
    int clampMag(int,int,int) -> b
    float clampMag(float,float,float) -> a
    float distanceInfluenceForSnapDuration(float) -> b
    void flingCapturedView(int,int,int,int) -> a
    boolean continueSettling(boolean) -> a
    void dispatchViewReleased(float,float) -> a
    void clearMotionHistory() -> i
    void clearMotionHistory(int) -> f
    void ensureMotionHistorySizeForId(int) -> g
    void saveInitialMotion(float,float,int) -> a
    void saveLastMotion(android.view.MotionEvent) -> c
    boolean isPointerDown(int) -> b
    void setDragState(int) -> c
    boolean tryCaptureViewForDrag(android.view.View,int) -> b
    boolean canScroll(android.view.View,boolean,int,int,int,int) -> a
    boolean shouldInterceptTouchEvent(android.view.MotionEvent) -> a
    void processTouchEvent(android.view.MotionEvent) -> b
    void reportNewEdgeDrags(float,float,int) -> b
    boolean checkNewEdgeDrag(float,float,int,int) -> a
    boolean checkTouchSlop(android.view.View,float,float) -> a
    boolean checkTouchSlop(int) -> d
    boolean checkTouchSlop(int,int) -> b
    boolean isEdgeTouched(int) -> e
    boolean isEdgeTouched(int,int) -> c
    void releaseViewForPointerUp() -> j
    void dragTo(int,int,int,int) -> c
    boolean isCapturedViewUnder(int,int) -> d
    boolean isViewUnder(android.view.View,int,int) -> b
    android.view.View findTopChildUnder(int,int) -> e
    int getEdgesTouched(int,int) -> f
android.support.v4.widget.ViewDragHelper$1 -> android.support.v4.widget.bg:
    float getInterpolation(float) -> getInterpolation
android.support.v4.widget.ViewDragHelper$2 -> android.support.v4.widget.bh:
    android.support.v4.widget.ViewDragHelper this$0 -> a
    void run() -> run
android.support.v4.widget.ViewDragHelper$Callback -> android.support.v4.widget.bi:
    void onViewDragStateChanged(int) -> a
    void onViewPositionChanged(android.view.View,int,int,int,int) -> a
    void onViewCaptured(android.view.View,int) -> b
    void onViewReleased(android.view.View,float,float) -> a
    void onEdgeTouched(int,int) -> a
    boolean onEdgeLock(int) -> b
    void onEdgeDragStarted(int,int) -> b
    int getOrderedChildIndex(int) -> c
    int getViewHorizontalDragRange(android.view.View) -> a
    int getViewVerticalDragRange(android.view.View) -> b
    boolean tryCaptureView(android.view.View,int) -> a
    int clampViewPositionHorizontal(android.view.View,int,int) -> a
    int clampViewPositionVertical(android.view.View,int,int) -> b
aurelienribon.tweenengine.BaseTween -> a.a.a:
    int step -> f
    int repeatCnt -> g
    boolean isIterationStep -> h
    boolean isYoyo -> i
    float delay -> a
    float duration -> b
    float repeatDelay -> j
    float currentTime -> k
    float deltaTime -> l
    boolean isStarted -> m
    boolean isInitialized -> n
    boolean isFinished -> o
    boolean isKilled -> p
    boolean isPaused -> q
    aurelienribon.tweenengine.TweenCallback callback -> r
    int callbackTriggers -> s
    java.lang.Object userData -> t
    boolean isAutoRemoveEnabled -> c
    boolean isAutoStartEnabled -> d
    boolean $assertionsDisabled -> e
    void reset() -> a
    java.lang.Object build() -> b
    java.lang.Object start() -> c
    java.lang.Object start(aurelienribon.tweenengine.TweenManager) -> a
    java.lang.Object delay(float) -> a
    void kill() -> d
    void free() -> e
    void pause() -> f
    void resume() -> g
    java.lang.Object repeat(int,float) -> a
    java.lang.Object repeatYoyo(int,float) -> b
    java.lang.Object setCallback(aurelienribon.tweenengine.TweenCallback) -> a
    java.lang.Object setCallbackTriggers(int) -> a
    java.lang.Object setUserData(java.lang.Object) -> a
    float getDelay() -> h
    float getDuration() -> i
    int getRepeatCount() -> j
    float getRepeatDelay() -> k
    float getFullDuration() -> l
    java.lang.Object getUserData() -> m
    int getStep() -> n
    float getCurrentTime() -> o
    boolean isStarted() -> p
    boolean isInitialized() -> q
    boolean isFinished() -> r
    boolean isYoyo() -> s
    boolean isPaused() -> t
    void forceStartValues() -> u
    void forceEndValues() -> v
    boolean containsTarget(java.lang.Object) -> b
    boolean containsTarget(java.lang.Object,int) -> a
    void initializeOverride() -> w
    void updateOverride(int,int,boolean,float) -> a
    void forceToStart() -> x
    void forceToEnd(float) -> b
    void callCallback(int) -> b
    boolean isReverse(int) -> c
    boolean isValid(int) -> d
    void killTarget(java.lang.Object) -> c
    void killTarget(java.lang.Object,int) -> b
    void update(float) -> c
    void initialize() -> y
    void testRelaunch() -> z
    void updateStep() -> A
    void testCompletion() -> B
aurelienribon.tweenengine.Pool -> a.a.b:
    java.util.ArrayList objects -> a
    aurelienribon.tweenengine.Pool$Callback callback -> b
    java.lang.Object create() -> a
    java.lang.Object get() -> b
    void free(java.lang.Object) -> a
    void clear() -> c
    int size() -> d
    void ensureCapacity(int) -> a
aurelienribon.tweenengine.Pool$Callback -> a.a.c:
    void onPool(java.lang.Object) -> a
    void onUnPool(java.lang.Object) -> b
aurelienribon.tweenengine.Timeline -> a.a.d:
    aurelienribon.tweenengine.Pool$Callback poolCallback -> h
    aurelienribon.tweenengine.Pool pool -> f
    java.util.List children -> i
    aurelienribon.tweenengine.Timeline current -> j
    aurelienribon.tweenengine.Timeline parent -> k
    aurelienribon.tweenengine.Timeline$Modes mode -> l
    boolean isBuilt -> m
    boolean $assertionsDisabled -> g
    int getPoolSize() -> y
    void ensurePoolCapacity(int) -> e
    aurelienribon.tweenengine.Timeline createSequence() -> z
    aurelienribon.tweenengine.Timeline createParallel() -> A
    void reset() -> a
    void setup(aurelienribon.tweenengine.Timeline$Modes) -> a
    aurelienribon.tweenengine.Timeline push(aurelienribon.tweenengine.Tween) -> a
    aurelienribon.tweenengine.Timeline push(aurelienribon.tweenengine.Timeline) -> a
    aurelienribon.tweenengine.Timeline pushPause(float) -> d
    aurelienribon.tweenengine.Timeline beginSequence() -> B
    aurelienribon.tweenengine.Timeline beginParallel() -> C
    aurelienribon.tweenengine.Timeline end() -> D
    java.util.List getChildren() -> E
    aurelienribon.tweenengine.Timeline build() -> F
    aurelienribon.tweenengine.Timeline start() -> G
    void free() -> e
    void updateOverride(int,int,boolean,float) -> a
    void forceStartValues() -> u
    void forceEndValues() -> v
    boolean containsTarget(java.lang.Object) -> b
    boolean containsTarget(java.lang.Object,int) -> a
    java.lang.Object start() -> c
    java.lang.Object build() -> b
aurelienribon.tweenengine.Timeline$1 -> a.a.e:
    void onPool(aurelienribon.tweenengine.Timeline) -> a
    void onUnPool(aurelienribon.tweenengine.Timeline) -> b
    void onUnPool(java.lang.Object) -> b
    void onPool(java.lang.Object) -> a
aurelienribon.tweenengine.Timeline$2 -> a.a.f:
    aurelienribon.tweenengine.Timeline create() -> e
    java.lang.Object create() -> a
aurelienribon.tweenengine.Timeline$3 -> a.a.g:
    int[] $SwitchMap$aurelienribon$tweenengine$Timeline$Modes -> a
aurelienribon.tweenengine.Timeline$Modes -> a.a.h:
    aurelienribon.tweenengine.Timeline$Modes SEQUENCE -> a
    aurelienribon.tweenengine.Timeline$Modes PARALLEL -> b
    aurelienribon.tweenengine.Timeline$Modes[] $VALUES -> c
    aurelienribon.tweenengine.Timeline$Modes[] values() -> values
    aurelienribon.tweenengine.Timeline$Modes valueOf(java.lang.String) -> valueOf
aurelienribon.tweenengine.Tween -> a.a.i:
    int INFINITY -> f
    int combinedAttrsLimit -> h
    int waypointsLimit -> i
    aurelienribon.tweenengine.Pool$Callback poolCallback -> j
    aurelienribon.tweenengine.Pool pool -> k
    java.util.Map registeredAccessors -> l
    java.lang.Object target -> m
    java.lang.Class targetClass -> n
    aurelienribon.tweenengine.TweenAccessor accessor -> o
    int type -> p
    aurelienribon.tweenengine.TweenEquation equation -> q
    aurelienribon.tweenengine.TweenPath path -> r
    boolean isFrom -> s
    boolean isRelative -> t
    int combinedAttrsCnt -> u
    int waypointsCnt -> v
    float[] startValues -> w
    float[] targetValues -> x
    float[] waypoints -> y
    float[] accessorBuffer -> z
    float[] pathBuffer -> A
    boolean $assertionsDisabled -> g
    void setCombinedAttributesLimit(int) -> e
    void setWaypointsLimit(int) -> f
    java.lang.String getVersion() -> y
    int getPoolSize() -> z
    void ensurePoolCapacity(int) -> g
    void registerAccessor(java.lang.Class,aurelienribon.tweenengine.TweenAccessor) -> a
    aurelienribon.tweenengine.TweenAccessor getRegisteredAccessor(java.lang.Class) -> a
    aurelienribon.tweenengine.Tween to(java.lang.Object,int,float) -> a
    aurelienribon.tweenengine.Tween from(java.lang.Object,int,float) -> b
    aurelienribon.tweenengine.Tween set(java.lang.Object,int) -> c
    aurelienribon.tweenengine.Tween call(aurelienribon.tweenengine.TweenCallback) -> b
    aurelienribon.tweenengine.Tween mark() -> A
    void reset() -> a
    void setup(java.lang.Object,int,float) -> c
    java.lang.Class findTargetClass() -> J
    aurelienribon.tweenengine.Tween ease(aurelienribon.tweenengine.TweenEquation) -> a
    aurelienribon.tweenengine.Tween cast(java.lang.Class) -> b
    aurelienribon.tweenengine.Tween target(float) -> d
    aurelienribon.tweenengine.Tween target(float,float) -> a
    aurelienribon.tweenengine.Tween target(float,float,float) -> a
    aurelienribon.tweenengine.Tween target(float[]) -> a
    aurelienribon.tweenengine.Tween targetRelative(float) -> e
    aurelienribon.tweenengine.Tween targetRelative(float,float) -> b
    aurelienribon.tweenengine.Tween targetRelative(float,float,float) -> b
    aurelienribon.tweenengine.Tween targetRelative(float[]) -> b
    aurelienribon.tweenengine.Tween waypoint(float) -> f
    aurelienribon.tweenengine.Tween waypoint(float,float) -> c
    aurelienribon.tweenengine.Tween waypoint(float,float,float) -> c
    aurelienribon.tweenengine.Tween waypoint(float[]) -> c
    aurelienribon.tweenengine.Tween path(aurelienribon.tweenengine.TweenPath) -> a
    java.lang.Object getTarget() -> B
    int getType() -> C
    aurelienribon.tweenengine.TweenEquation getEasing() -> D
    float[] getTargetValues() -> E
    int getCombinedAttributesCount() -> F
    aurelienribon.tweenengine.TweenAccessor getAccessor() -> G
    java.lang.Class getTargetClass() -> H
    aurelienribon.tweenengine.Tween build() -> I
    void free() -> e
    void initializeOverride() -> w
    void updateOverride(int,int,boolean,float) -> a
    void forceStartValues() -> u
    void forceEndValues() -> v
    boolean containsTarget(java.lang.Object) -> b
    boolean containsTarget(java.lang.Object,int) -> a
    void throwCombinedAttrsLimitReached() -> K
    void throwWaypointsLimitReached() -> L
    java.lang.Object build() -> b
aurelienribon.tweenengine.Tween$1 -> a.a.j:
    void onPool(aurelienribon.tweenengine.Tween) -> a
    void onUnPool(aurelienribon.tweenengine.Tween) -> b
    void onUnPool(java.lang.Object) -> b
    void onPool(java.lang.Object) -> a
aurelienribon.tweenengine.Tween$2 -> a.a.k:
    aurelienribon.tweenengine.Tween create() -> e
    java.lang.Object create() -> a
aurelienribon.tweenengine.TweenAccessor -> a.a.l:
    int getValues(java.lang.Object,int,float[]) -> a
    void setValues(java.lang.Object,int,float[]) -> b
aurelienribon.tweenengine.TweenCallback -> a.a.m:
    int BEGIN -> a
    int START -> b
    int END -> c
    int COMPLETE -> d
    int BACK_BEGIN -> e
    int BACK_START -> f
    int BACK_END -> g
    int BACK_COMPLETE -> h
    int ANY_FORWARD -> i
    int ANY_BACKWARD -> j
    int ANY -> k
    void onEvent(int,aurelienribon.tweenengine.BaseTween) -> a
aurelienribon.tweenengine.TweenEquation -> a.a.n:
    float compute(float) -> a
    boolean isValueOf(java.lang.String) -> a
aurelienribon.tweenengine.TweenEquations -> a.a.o:
    aurelienribon.tweenengine.equations.Linear easeNone -> a
    aurelienribon.tweenengine.equations.Quad easeInQuad -> b
    aurelienribon.tweenengine.equations.Quad easeOutQuad -> c
    aurelienribon.tweenengine.equations.Quad easeInOutQuad -> d
    aurelienribon.tweenengine.equations.Cubic easeInCubic -> e
    aurelienribon.tweenengine.equations.Cubic easeOutCubic -> f
    aurelienribon.tweenengine.equations.Cubic easeInOutCubic -> g
    aurelienribon.tweenengine.equations.Quart easeInQuart -> h
    aurelienribon.tweenengine.equations.Quart easeOutQuart -> i
    aurelienribon.tweenengine.equations.Quart easeInOutQuart -> j
    aurelienribon.tweenengine.equations.Quint easeInQuint -> k
    aurelienribon.tweenengine.equations.Quint easeOutQuint -> l
    aurelienribon.tweenengine.equations.Quint easeInOutQuint -> m
    aurelienribon.tweenengine.equations.Circ easeInCirc -> n
    aurelienribon.tweenengine.equations.Circ easeOutCirc -> o
    aurelienribon.tweenengine.equations.Circ easeInOutCirc -> p
    aurelienribon.tweenengine.equations.Sine easeInSine -> q
    aurelienribon.tweenengine.equations.Sine easeOutSine -> r
    aurelienribon.tweenengine.equations.Sine easeInOutSine -> s
    aurelienribon.tweenengine.equations.Expo easeInExpo -> t
    aurelienribon.tweenengine.equations.Expo easeOutExpo -> u
    aurelienribon.tweenengine.equations.Expo easeInOutExpo -> v
    aurelienribon.tweenengine.equations.Back easeInBack -> w
    aurelienribon.tweenengine.equations.Back easeOutBack -> x
    aurelienribon.tweenengine.equations.Back easeInOutBack -> y
    aurelienribon.tweenengine.equations.Bounce easeInBounce -> z
    aurelienribon.tweenengine.equations.Bounce easeOutBounce -> A
    aurelienribon.tweenengine.equations.Bounce easeInOutBounce -> B
    aurelienribon.tweenengine.equations.Elastic easeInElastic -> C
    aurelienribon.tweenengine.equations.Elastic easeOutElastic -> D
    aurelienribon.tweenengine.equations.Elastic easeInOutElastic -> E
aurelienribon.tweenengine.TweenManager -> a.a.p:
    java.util.ArrayList objects -> a
    boolean isPaused -> b
    void setAutoRemove(aurelienribon.tweenengine.BaseTween,boolean) -> a
    void setAutoStart(aurelienribon.tweenengine.BaseTween,boolean) -> b
    aurelienribon.tweenengine.TweenManager add(aurelienribon.tweenengine.BaseTween) -> a
    boolean containsTarget(java.lang.Object) -> a
    boolean containsTarget(java.lang.Object,int) -> a
    void killAll() -> a
    void killTarget(java.lang.Object) -> b
    void killTarget(java.lang.Object,int) -> b
    void ensureCapacity(int) -> a
    void pause() -> b
    void resume() -> c
    void update(float) -> a
    int size() -> d
    int getRunningTweensCount() -> e
    int getRunningTimelinesCount() -> f
    java.util.List getObjects() -> g
    int getTweensCount(java.util.List) -> a
    int getTimelinesCount(java.util.List) -> b
aurelienribon.tweenengine.TweenPath -> a.a.q:
    float compute(float,float[],int) -> a
aurelienribon.tweenengine.TweenPaths -> a.a.r:
    aurelienribon.tweenengine.paths.Linear linear -> a
    aurelienribon.tweenengine.paths.CatmullRom catmullRom -> b
aurelienribon.tweenengine.TweenUtils -> a.a.s:
    aurelienribon.tweenengine.TweenEquation[] easings -> a
    aurelienribon.tweenengine.TweenEquation parseEasing(java.lang.String) -> a
aurelienribon.tweenengine.equations.Back -> a.a.a.a:
    aurelienribon.tweenengine.equations.Back IN -> a
    aurelienribon.tweenengine.equations.Back OUT -> b
    aurelienribon.tweenengine.equations.Back INOUT -> c
    float param_s -> d
    aurelienribon.tweenengine.equations.Back s(float) -> b
aurelienribon.tweenengine.equations.Back$1 -> a.a.a.b:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Back$2 -> a.a.a.c:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Back$3 -> a.a.a.d:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Bounce -> a.a.a.e:
    aurelienribon.tweenengine.equations.Bounce IN -> a
    aurelienribon.tweenengine.equations.Bounce OUT -> b
    aurelienribon.tweenengine.equations.Bounce INOUT -> c
aurelienribon.tweenengine.equations.Bounce$1 -> a.a.a.f:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Bounce$2 -> a.a.a.g:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Bounce$3 -> a.a.a.h:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Circ -> a.a.a.i:
    aurelienribon.tweenengine.equations.Circ IN -> a
    aurelienribon.tweenengine.equations.Circ OUT -> b
    aurelienribon.tweenengine.equations.Circ INOUT -> c
aurelienribon.tweenengine.equations.Circ$1 -> a.a.a.j:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Circ$2 -> a.a.a.k:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Circ$3 -> a.a.a.l:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Cubic -> a.a.a.m:
    aurelienribon.tweenengine.equations.Cubic IN -> a
    aurelienribon.tweenengine.equations.Cubic OUT -> b
    aurelienribon.tweenengine.equations.Cubic INOUT -> c
aurelienribon.tweenengine.equations.Cubic$1 -> a.a.a.n:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Cubic$2 -> a.a.a.o:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Cubic$3 -> a.a.a.p:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Elastic -> a.a.a.q:
    float PI -> h
    aurelienribon.tweenengine.equations.Elastic IN -> a
    aurelienribon.tweenengine.equations.Elastic OUT -> b
    aurelienribon.tweenengine.equations.Elastic INOUT -> c
    float param_a -> d
    float param_p -> e
    boolean setA -> f
    boolean setP -> g
    aurelienribon.tweenengine.equations.Elastic a(float) -> b
    aurelienribon.tweenengine.equations.Elastic p(float) -> c
aurelienribon.tweenengine.equations.Elastic$1 -> a.a.a.r:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Elastic$2 -> a.a.a.s:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Elastic$3 -> a.a.a.t:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Expo -> a.a.a.u:
    aurelienribon.tweenengine.equations.Expo IN -> a
    aurelienribon.tweenengine.equations.Expo OUT -> b
    aurelienribon.tweenengine.equations.Expo INOUT -> c
aurelienribon.tweenengine.equations.Expo$1 -> a.a.a.v:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Expo$2 -> a.a.a.w:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Expo$3 -> a.a.a.x:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Linear -> a.a.a.y:
    aurelienribon.tweenengine.equations.Linear INOUT -> a
aurelienribon.tweenengine.equations.Linear$1 -> a.a.a.z:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quad -> a.a.a.aa:
    aurelienribon.tweenengine.equations.Quad IN -> a
    aurelienribon.tweenengine.equations.Quad OUT -> b
    aurelienribon.tweenengine.equations.Quad INOUT -> c
aurelienribon.tweenengine.equations.Quad$1 -> a.a.a.ab:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quad$2 -> a.a.a.ac:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quad$3 -> a.a.a.ad:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quart -> a.a.a.ae:
    aurelienribon.tweenengine.equations.Quart IN -> a
    aurelienribon.tweenengine.equations.Quart OUT -> b
    aurelienribon.tweenengine.equations.Quart INOUT -> c
aurelienribon.tweenengine.equations.Quart$1 -> a.a.a.af:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quart$2 -> a.a.a.ag:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quart$3 -> a.a.a.ah:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quint -> a.a.a.ai:
    aurelienribon.tweenengine.equations.Quint IN -> a
    aurelienribon.tweenengine.equations.Quint OUT -> b
    aurelienribon.tweenengine.equations.Quint INOUT -> c
aurelienribon.tweenengine.equations.Quint$1 -> a.a.a.aj:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quint$2 -> a.a.a.ak:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Quint$3 -> a.a.a.al:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Sine -> a.a.a.am:
    float PI -> d
    aurelienribon.tweenengine.equations.Sine IN -> a
    aurelienribon.tweenengine.equations.Sine OUT -> b
    aurelienribon.tweenengine.equations.Sine INOUT -> c
aurelienribon.tweenengine.equations.Sine$1 -> a.a.a.an:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Sine$2 -> a.a.a.ao:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.equations.Sine$3 -> a.a.a.ap:
    float compute(float) -> a
    java.lang.String toString() -> toString
aurelienribon.tweenengine.paths.CatmullRom -> a.a.b.a:
    float compute(float,float[],int) -> a
    float catmullRomSpline(float,float,float,float,float) -> a
aurelienribon.tweenengine.paths.Linear -> a.a.b.b:
    float compute(float,float[],int) -> a
aurelienribon.tweenengine.primitives.MutableFloat -> a.a.c.a:
    float value -> a
    void setValue(float) -> a
    int intValue() -> intValue
    long longValue() -> longValue
    float floatValue() -> floatValue
    double doubleValue() -> doubleValue
    int getValues(aurelienribon.tweenengine.primitives.MutableFloat,int,float[]) -> a
    void setValues(aurelienribon.tweenengine.primitives.MutableFloat,int,float[]) -> b
    void setValues(java.lang.Object,int,float[]) -> b
    int getValues(java.lang.Object,int,float[]) -> a
aurelienribon.tweenengine.primitives.MutableInteger -> a.a.c.b:
    int value -> a
    void setValue(int) -> a
    int intValue() -> intValue
    long longValue() -> longValue
    float floatValue() -> floatValue
    double doubleValue() -> doubleValue
    int getValues(aurelienribon.tweenengine.primitives.MutableInteger,int,float[]) -> a
    void setValues(aurelienribon.tweenengine.primitives.MutableInteger,int,float[]) -> b
    void setValues(java.lang.Object,int,float[]) -> b
    int getValues(java.lang.Object,int,float[]) -> a
box2dLight.ConeLight -> b.a:
    float coneDegree -> a
    void setDirection(float) -> a
    float getConeDegree() -> a
    void setConeDegree(float) -> b
    void setDistance(float) -> c
box2dLight.DirectionalLight -> b.b:
    float sin -> a
    float cos -> b
    com.badlogic.gdx.math.Vector2[] start -> c
    com.badlogic.gdx.math.Vector2[] end -> d
    float lastX -> e
    void setDirection(float) -> a
    void update() -> a_
    void render() -> b
    void attachToBody(com.badlogic.gdx.physics.box2d.Body,float,float) -> a
    void setPosition(float,float) -> a
    com.badlogic.gdx.physics.box2d.Body getBody() -> c
    float getX() -> d
    float getY() -> e
    void setPosition(com.badlogic.gdx.math.Vector2) -> a
    boolean contains(float,float) -> b
box2dLight.Light -> b.c:
    com.badlogic.gdx.graphics.Color DefaultColor -> f
    boolean active -> a
    boolean soft -> g
    boolean xray -> h
    boolean staticLight -> i
    float softShadowLenght -> j
    box2dLight.RayHandler rayHandler -> k
    boolean culled -> l
    int rayNum -> m
    int vertexNum -> n
    float distance -> o
    float direction -> p
    com.badlogic.gdx.graphics.Color color -> q
    com.badlogic.gdx.graphics.Mesh lightMesh -> r
    com.badlogic.gdx.graphics.Mesh softShadowMesh -> s
    float colorF -> t
    int MIN_RAYS -> u
    float[] segments -> v
    float[] mx -> w
    float[] my -> x
    float[] f -> y
    int m_index -> z
    com.badlogic.gdx.math.Vector2 tmpPosition -> A
    float zero -> B
    com.badlogic.gdx.physics.box2d.RayCastCallback ray -> C
    com.badlogic.gdx.physics.box2d.Filter filterA -> b
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setDistance(float) -> c
    void update() -> a_
    void render() -> b
    void setDirection(float) -> a
    void remove() -> f
    void attachToBody(com.badlogic.gdx.physics.box2d.Body,float,float) -> a
    com.badlogic.gdx.physics.box2d.Body getBody() -> c
    void setPosition(float,float) -> a
    void setPosition(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> g
    float getX() -> d
    float getY() -> e
    void staticUpdate() -> h
    boolean isActive() -> i
    void setActive(boolean) -> a
    boolean isXray() -> j
    void setXray(boolean) -> b
    boolean isStaticLight() -> k
    void setStaticLight(boolean) -> c
    boolean isSoft() -> l
    void setSoft(boolean) -> d
    float getSoftShadowLenght() -> m
    void setSoftnessLenght(float) -> d
    void setRayNum(int) -> a
    com.badlogic.gdx.graphics.Color getColor() -> n
    float getDistance() -> o
    boolean contains(float,float) -> b
    boolean contactFilter(com.badlogic.gdx.physics.box2d.Fixture) -> a
    void setContactFilter(com.badlogic.gdx.physics.box2d.Filter) -> a
    void setContactFilter(short,short,short) -> a
    com.badlogic.gdx.physics.box2d.Filter access$0(box2dLight.Light) -> a
box2dLight.Light$1 -> b.d:
    box2dLight.Light this$0 -> a
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
box2dLight.LightMap -> b.e:
    com.badlogic.gdx.graphics.glutils.ShaderProgram shadowShader -> s
    com.badlogic.gdx.graphics.glutils.FrameBuffer frameBuffer -> a
    com.badlogic.gdx.graphics.Mesh lightMapMesh -> t
    com.badlogic.gdx.graphics.glutils.FrameBuffer pingPongBuffer -> u
    box2dLight.RayHandler rayHandler -> v
    com.badlogic.gdx.graphics.glutils.ShaderProgram withoutShadowShader -> w
    com.badlogic.gdx.graphics.glutils.ShaderProgram blurShader -> x
    com.badlogic.gdx.graphics.glutils.ShaderProgram diffuseShader -> y
    float[] verts -> z
    int VERT_SIZE -> b
    int X1 -> c
    int Y1 -> d
    int U1 -> e
    int V1 -> f
    int X2 -> g
    int Y2 -> h
    int U2 -> i
    int V2 -> j
    int X3 -> k
    int Y3 -> l
    int U3 -> m
    int V3 -> n
    int X4 -> o
    int Y4 -> p
    int U4 -> q
    int V4 -> r
    void render() -> a
    void gaussianBlur() -> b
    void dispose() -> c
    com.badlogic.gdx.graphics.Mesh createLightMapMesh() -> d
box2dLight.PointLight -> b.f:
    void setEndPoints() -> p
    void setDirection(float) -> a
    void setDistance(float) -> c
box2dLight.PositionalLight -> b.g:
    com.badlogic.gdx.physics.box2d.Body body -> a
    float bodyOffsetX -> E
    float bodyOffsetY -> F
    float[] sin -> b
    float[] cos -> c
    com.badlogic.gdx.math.Vector2 start -> d
    float[] endX -> e
    float[] endY -> D
    com.badlogic.gdx.math.Vector2 tmpEnd -> G
    void attachToBody(com.badlogic.gdx.physics.box2d.Body,float,float) -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> g
    com.badlogic.gdx.physics.box2d.Body getBody() -> c
    float getX() -> d
    float getY() -> e
    void setPosition(float,float) -> a
    void setPosition(com.badlogic.gdx.math.Vector2) -> a
    void update() -> a_
    void setMesh() -> q
    void render() -> b
    boolean contains(float,float) -> b
box2dLight.RayHandler -> b.h:
    boolean isGL20 -> a
    boolean culling -> b
    boolean shadows -> c
    boolean blur -> d
    int blurNum -> e
    com.badlogic.gdx.graphics.Color ambientLight -> f
    com.badlogic.gdx.physics.box2d.World world -> g
    com.badlogic.gdx.graphics.glutils.ShaderProgram lightShader -> h
    com.badlogic.gdx.graphics.Mesh box -> x
    com.badlogic.gdx.math.Matrix4 combined -> y
    float x1 -> i
    float x2 -> j
    float y1 -> k
    float y2 -> l
    box2dLight.LightMap lightMap -> z
    com.badlogic.gdx.utils.Array lightList -> m
    com.badlogic.gdx.utils.Array disabledLights -> n
    int lightRenderedLastFrame -> o
    java.lang.String HIGH -> p
    java.lang.String MED -> q
    java.lang.String LOW -> r
    java.lang.String colorPrecision -> s
    boolean gammaCorrection -> t
    float gammaCorrectionParameter -> u
    boolean isDiffuse -> v
    float GAMMA_COR -> w
    void setCombinedMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setCombinedMatrix(com.badlogic.gdx.math.Matrix4,float,float,float,float) -> a
    boolean intersect(float,float,float) -> a
    void updateAndRender() -> a
    void update() -> b
    void render() -> c
    void renderWithShaders() -> d
    boolean pointAtLight(float,float) -> a
    boolean pointAtShadow(float,float) -> b
    void alphaChannelClear() -> l
    void dispose() -> e
    void removeAll() -> f
    void setShadowBox() -> m
    void setCulling(boolean) -> a
    void setBlur(boolean) -> b
    void setBlurNum(int) -> a
    void setShadows(boolean) -> c
    void setAmbientLight(float) -> a
    void setAmbientLight(float,float,float,float) -> a
    void setAmbientLight(com.badlogic.gdx.graphics.Color) -> a
    void setWorld(com.badlogic.gdx.physics.box2d.World) -> a
    void setColorPrecisionHighp() -> g
    void setColorPrecisionMediump() -> h
    void setColorPrecisionLowp() -> i
    java.lang.String getColorPrecision() -> j
    boolean getGammaCorrection() -> k
    void setGammaCorrection(boolean) -> d
    void useDiffuseLight(boolean) -> e
com.badlogic.gdx.Application -> com.badlogic.gdx.a:
    int LOG_NONE -> a
    int LOG_DEBUG -> b
    int LOG_INFO -> c
    int LOG_ERROR -> d
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.Audio getAudio() -> c
    com.badlogic.gdx.Input getInput() -> d
    com.badlogic.gdx.Files getFiles() -> e
    com.badlogic.gdx.Net getNet() -> f
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Exception) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void debug(java.lang.String,java.lang.String) -> c
    void debug(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void setLogLevel(int) -> a
    com.badlogic.gdx.Application$ApplicationType getType() -> g
    int getVersion() -> h
    long getJavaHeap() -> i
    long getNativeHeap() -> j
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.utils.Clipboard getClipboard() -> k
    void postRunnable(java.lang.Runnable) -> a
    void exit() -> l
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
com.badlogic.gdx.Application$ApplicationType -> com.badlogic.gdx.b:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType Applet -> c
    com.badlogic.gdx.Application$ApplicationType WebGL -> d
    com.badlogic.gdx.Application$ApplicationType iOS -> e
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> f
    com.badlogic.gdx.Application$ApplicationType[] values() -> values
    com.badlogic.gdx.Application$ApplicationType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.ApplicationAdapter -> com.badlogic.gdx.c:
    void create() -> a
    void resize(int,int) -> a
    void render() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.ApplicationListener -> com.badlogic.gdx.d:
    void create() -> a
    void resize(int,int) -> a
    void render() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.Audio -> com.badlogic.gdx.e:
    com.badlogic.gdx.audio.AudioDevice newAudioDevice(int,boolean) -> a
    com.badlogic.gdx.audio.AudioRecorder newAudioRecorder(int,boolean) -> b
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.Files -> com.badlogic.gdx.f:
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle external(java.lang.String) -> c
    com.badlogic.gdx.files.FileHandle absolute(java.lang.String) -> d
    com.badlogic.gdx.files.FileHandle local(java.lang.String) -> e
    java.lang.String getExternalStoragePath() -> a
    boolean isExternalStorageAvailable() -> b
    java.lang.String getLocalStoragePath() -> c
    boolean isLocalStorageAvailable() -> d
com.badlogic.gdx.Files$FileType -> com.badlogic.gdx.g:
    com.badlogic.gdx.Files$FileType Classpath -> a
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType[] values() -> values
    com.badlogic.gdx.Files$FileType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Game -> com.badlogic.gdx.h:
    com.badlogic.gdx.Screen screen -> a
    void dispose() -> e
    void pause() -> c
    void resume() -> d
    void render() -> b
    void resize(int,int) -> a
    void setScreen(com.badlogic.gdx.Screen) -> a
    com.badlogic.gdx.Screen getScreen() -> f
com.badlogic.gdx.Gdx -> com.badlogic.gdx.i:
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.graphics.GLCommon gl -> g
    com.badlogic.gdx.graphics.GL10 gl10 -> h
    com.badlogic.gdx.graphics.GL11 gl11 -> i
    com.badlogic.gdx.graphics.GL20 gl20 -> j
com.badlogic.gdx.Graphics -> com.badlogic.gdx.j:
    boolean isGL11Available() -> a
    boolean isGL20Available() -> b
    com.badlogic.gdx.graphics.GLCommon getGLCommon() -> c
    com.badlogic.gdx.graphics.GL10 getGL10() -> d
    com.badlogic.gdx.graphics.GL11 getGL11() -> e
    com.badlogic.gdx.graphics.GL20 getGL20() -> f
    int getWidth() -> g
    int getHeight() -> h
    float getDeltaTime() -> i
    float getRawDeltaTime() -> j
    int getFramesPerSecond() -> k
    com.badlogic.gdx.Graphics$GraphicsType getType() -> l
    float getPpiX() -> m
    float getPpiY() -> n
    float getPpcX() -> o
    float getPpcY() -> p
    float getDensity() -> q
    boolean supportsDisplayModeChange() -> r
    com.badlogic.gdx.Graphics$DisplayMode[] getDisplayModes() -> s
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> t
    boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    boolean setDisplayMode(int,int,boolean) -> a
    void setTitle(java.lang.String) -> a
    void setVSync(boolean) -> a
    com.badlogic.gdx.Graphics$BufferFormat getBufferFormat() -> u
    boolean supportsExtension(java.lang.String) -> b
    void setContinuousRendering(boolean) -> b
    boolean isContinuousRendering() -> v
    void requestRendering() -> w
    boolean isFullscreen() -> x
com.badlogic.gdx.Graphics$BufferFormat -> com.badlogic.gdx.k:
    int r -> a
    int g -> b
    int b -> c
    int a -> d
    int depth -> e
    int stencil -> f
    int samples -> g
    boolean coverageSampling -> h
    java.lang.String toString() -> toString
com.badlogic.gdx.Graphics$DisplayMode -> com.badlogic.gdx.l:
    int width -> a
    int height -> b
    int refreshRate -> c
    int bitsPerPixel -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.Graphics$GraphicsType -> com.badlogic.gdx.m:
    com.badlogic.gdx.Graphics$GraphicsType AndroidGL -> a
    com.badlogic.gdx.Graphics$GraphicsType LWJGL -> b
    com.badlogic.gdx.Graphics$GraphicsType Angle -> c
    com.badlogic.gdx.Graphics$GraphicsType WebGL -> d
    com.badlogic.gdx.Graphics$GraphicsType iOSGL -> e
    com.badlogic.gdx.Graphics$GraphicsType JGLFW -> f
    com.badlogic.gdx.Graphics$GraphicsType[] $VALUES -> g
    com.badlogic.gdx.Graphics$GraphicsType[] values() -> values
    com.badlogic.gdx.Graphics$GraphicsType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Input -> com.badlogic.gdx.n:
    float getAccelerometerX() -> a
    float getAccelerometerY() -> b
    float getAccelerometerZ() -> c
    int getX() -> d
    int getX(int) -> a
    int getDeltaX() -> e
    int getDeltaX(int) -> b
    int getY() -> f
    int getY(int) -> c
    int getDeltaY() -> g
    int getDeltaY(int) -> d
    boolean isTouched() -> h
    boolean justTouched() -> i
    boolean isTouched(int) -> e
    boolean isButtonPressed(int) -> f
    boolean isKeyPressed(int) -> g
    void getTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> a
    void getPlaceholderTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> b
    void setOnscreenKeyboardVisible(boolean) -> a
    void vibrate(int) -> h
    void vibrate(long[],int) -> a
    void cancelVibrate() -> j
    float getAzimuth() -> k
    float getPitch() -> l
    float getRoll() -> m
    void getRotationMatrix(float[]) -> a
    long getCurrentEventTime() -> n
    void setCatchBackKey(boolean) -> b
    void setCatchMenuKey(boolean) -> c
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    com.badlogic.gdx.InputProcessor getInputProcessor() -> o
    boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral) -> a
    int getRotation() -> p
    com.badlogic.gdx.Input$Orientation getNativeOrientation() -> q
    void setCursorCatched(boolean) -> d
    boolean isCursorCatched() -> r
    void setCursorPosition(int,int) -> a
com.badlogic.gdx.Input$Buttons -> com.badlogic.gdx.o:
    int LEFT -> a
    int RIGHT -> b
    int MIDDLE -> c
com.badlogic.gdx.Input$Keys -> com.badlogic.gdx.p:
    int ANY_KEY -> a
    int NUM_0 -> b
    int NUM_1 -> c
    int NUM_2 -> d
    int NUM_3 -> e
    int NUM_4 -> f
    int NUM_5 -> g
    int NUM_6 -> h
    int NUM_7 -> i
    int NUM_8 -> j
    int NUM_9 -> k
    int A -> l
    int ALT_LEFT -> m
    int ALT_RIGHT -> n
    int APOSTROPHE -> o
    int AT -> p
    int B -> q
    int BACK -> r
    int BACKSLASH -> s
    int C -> t
    int CALL -> u
    int CAMERA -> v
    int CLEAR -> w
    int COMMA -> x
    int D -> y
    int DEL -> z
    int BACKSPACE -> A
    int FORWARD_DEL -> B
    int DPAD_CENTER -> C
    int DPAD_DOWN -> D
    int DPAD_LEFT -> E
    int DPAD_RIGHT -> F
    int DPAD_UP -> G
    int CENTER -> H
    int DOWN -> I
    int LEFT -> J
    int RIGHT -> K
    int UP -> L
    int E -> M
    int ENDCALL -> N
    int ENTER -> O
    int ENVELOPE -> P
    int EQUALS -> Q
    int EXPLORER -> R
    int F -> S
    int FOCUS -> T
    int G -> U
    int GRAVE -> V
    int H -> W
    int HEADSETHOOK -> X
    int HOME -> Y
    int I -> Z
    int J -> aa
    int K -> ab
    int L -> ac
    int LEFT_BRACKET -> ad
    int M -> ae
    int MEDIA_FAST_FORWARD -> af
    int MEDIA_NEXT -> ag
    int MEDIA_PLAY_PAUSE -> ah
    int MEDIA_PREVIOUS -> ai
    int MEDIA_REWIND -> aj
    int MEDIA_STOP -> ak
    int MENU -> al
    int MINUS -> am
    int MUTE -> an
    int N -> ao
    int NOTIFICATION -> ap
    int NUM -> aq
    int O -> ar
    int P -> as
    int PERIOD -> at
    int PLUS -> au
    int POUND -> av
    int POWER -> aw
    int Q -> ax
    int R -> ay
    int RIGHT_BRACKET -> az
    int S -> aA
    int SEARCH -> aB
    int SEMICOLON -> aC
    int SHIFT_LEFT -> aD
    int SHIFT_RIGHT -> aE
    int SLASH -> aF
    int SOFT_LEFT -> aG
    int SOFT_RIGHT -> aH
    int SPACE -> aI
    int STAR -> aJ
    int SYM -> aK
    int T -> aL
    int TAB -> aM
    int U -> aN
    int UNKNOWN -> aO
    int V -> aP
    int VOLUME_DOWN -> aQ
    int VOLUME_UP -> aR
    int W -> aS
    int X -> aT
    int Y -> aU
    int Z -> aV
    int META_ALT_LEFT_ON -> aW
    int META_ALT_ON -> aX
    int META_ALT_RIGHT_ON -> aY
    int META_SHIFT_LEFT_ON -> aZ
    int META_SHIFT_ON -> ba
    int META_SHIFT_RIGHT_ON -> bb
    int META_SYM_ON -> bc
    int CONTROL_LEFT -> bd
    int CONTROL_RIGHT -> be
    int ESCAPE -> bf
    int END -> bg
    int INSERT -> bh
    int PAGE_UP -> bi
    int PAGE_DOWN -> bj
    int PICTSYMBOLS -> bk
    int SWITCH_CHARSET -> bl
    int BUTTON_CIRCLE -> bm
    int BUTTON_A -> bn
    int BUTTON_B -> bo
    int BUTTON_C -> bp
    int BUTTON_X -> bq
    int BUTTON_Y -> br
    int BUTTON_Z -> bs
    int BUTTON_L1 -> bt
    int BUTTON_R1 -> bu
    int BUTTON_L2 -> bv
    int BUTTON_R2 -> bw
    int BUTTON_THUMBL -> bx
    int BUTTON_THUMBR -> by
    int BUTTON_START -> bz
    int BUTTON_SELECT -> bA
    int BUTTON_MODE -> bB
    int COLON -> bC
    int F1 -> bD
    int F2 -> bE
    int F3 -> bF
    int F4 -> bG
    int F5 -> bH
    int F6 -> bI
    int F7 -> bJ
    int F8 -> bK
    int F9 -> bL
    int F10 -> bM
    int F11 -> bN
    int F12 -> bO
com.badlogic.gdx.Input$Orientation -> com.badlogic.gdx.q:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation Portrait -> b
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation[] values() -> values
    com.badlogic.gdx.Input$Orientation valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Input$Peripheral -> com.badlogic.gdx.r:
    com.badlogic.gdx.Input$Peripheral HardwareKeyboard -> a
    com.badlogic.gdx.Input$Peripheral OnscreenKeyboard -> b
    com.badlogic.gdx.Input$Peripheral MultitouchScreen -> c
    com.badlogic.gdx.Input$Peripheral Accelerometer -> d
    com.badlogic.gdx.Input$Peripheral Compass -> e
    com.badlogic.gdx.Input$Peripheral Vibrator -> f
    com.badlogic.gdx.Input$Peripheral[] $VALUES -> g
    com.badlogic.gdx.Input$Peripheral[] values() -> values
    com.badlogic.gdx.Input$Peripheral valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Input$TextInputListener -> com.badlogic.gdx.s:
    void input(java.lang.String) -> a
    void canceled() -> a
com.badlogic.gdx.InputAdapter -> com.badlogic.gdx.t:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
com.badlogic.gdx.InputMultiplexer -> com.badlogic.gdx.u:
    com.badlogic.gdx.utils.Array processors -> a
    void addProcessor(int,com.badlogic.gdx.InputProcessor) -> a
    void removeProcessor(int) -> d
    void addProcessor(com.badlogic.gdx.InputProcessor) -> a
    void removeProcessor(com.badlogic.gdx.InputProcessor) -> b
    int size() -> a
    void clear() -> b
    void setProcessors(com.badlogic.gdx.utils.Array) -> a
    com.badlogic.gdx.utils.Array getProcessors() -> c
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
com.badlogic.gdx.InputProcessor -> com.badlogic.gdx.v:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
com.badlogic.gdx.InputProcessorQueue -> com.badlogic.gdx.w:
    int KEY_DOWN -> a
    int KEY_UP -> b
    int KEY_TYPED -> c
    int TOUCH_DOWN -> d
    int TOUCH_UP -> e
    int TOUCH_DRAGGED -> f
    int MOUSE_MOVED -> g
    int SCROLLED -> h
    com.badlogic.gdx.InputProcessor processor -> i
    com.badlogic.gdx.utils.IntArray queue -> j
    com.badlogic.gdx.utils.IntArray processingQueue -> k
    long currentEventTime -> l
    void setProcessor(com.badlogic.gdx.InputProcessor) -> a
    com.badlogic.gdx.InputProcessor getProcessor() -> a
    void drain() -> b
    void queueTime() -> d
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
    long getCurrentEventTime() -> c
com.badlogic.gdx.LifecycleListener -> com.badlogic.gdx.x:
    void pause() -> a
    void resume() -> b
    void dispose() -> c
com.badlogic.gdx.Net -> com.badlogic.gdx.y:
    void sendHttpRequest(com.badlogic.gdx.Net$HttpRequest,com.badlogic.gdx.Net$HttpResponseListener) -> a
    com.badlogic.gdx.net.ServerSocket newServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints) -> a
    com.badlogic.gdx.net.Socket newClientSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints) -> a
    void openURI(java.lang.String) -> a
com.badlogic.gdx.Net$HttpMethods -> com.badlogic.gdx.z:
    java.lang.String GET -> a
    java.lang.String POST -> b
com.badlogic.gdx.Net$HttpRequest -> com.badlogic.gdx.aa:
    java.lang.String httpMethod -> a
    java.lang.String url -> b
    java.util.Map headers -> c
    int timeOut -> d
    java.lang.String content -> e
    java.io.InputStream contentStream -> f
    long contentLength -> g
    void setUrl(java.lang.String) -> a
    void setHeader(java.lang.String,java.lang.String) -> a
    void setContent(java.lang.String) -> b
    void setContent(java.io.InputStream,long) -> a
    void setTimeOut(int) -> a
    int getTimeOut() -> a
    java.lang.String getMethod() -> b
    java.lang.String getUrl() -> c
    java.lang.String getContent() -> d
    java.io.InputStream getContentStream() -> e
    long getContentLength() -> f
    java.util.Map getHeaders() -> g
com.badlogic.gdx.Net$HttpResponse -> com.badlogic.gdx.ab:
    byte[] getResult() -> a
    java.lang.String getResultAsString() -> b
    java.io.InputStream getResultAsStream() -> c
    com.badlogic.gdx.net.HttpStatus getStatus() -> d
com.badlogic.gdx.Net$HttpResponseListener -> com.badlogic.gdx.ac:
    void handleHttpResponse(com.badlogic.gdx.Net$HttpResponse) -> a
    void failed(java.lang.Throwable) -> a
com.badlogic.gdx.Net$Protocol -> com.badlogic.gdx.ad:
    com.badlogic.gdx.Net$Protocol TCP -> a
    com.badlogic.gdx.Net$Protocol[] $VALUES -> b
    com.badlogic.gdx.Net$Protocol[] values() -> values
    com.badlogic.gdx.Net$Protocol valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Preferences -> com.badlogic.gdx.ae:
    void putBoolean(java.lang.String,boolean) -> a
    void putInteger(java.lang.String,int) -> a
    void putLong(java.lang.String,long) -> a
    void putFloat(java.lang.String,float) -> a
    void putString(java.lang.String,java.lang.String) -> a
    void put(java.util.Map) -> a
    boolean getBoolean(java.lang.String) -> a
    int getInteger(java.lang.String) -> b
    long getLong(java.lang.String) -> c
    float getFloat(java.lang.String) -> d
    java.lang.String getString(java.lang.String) -> e
    boolean getBoolean(java.lang.String,boolean) -> b
    int getInteger(java.lang.String,int) -> b
    long getLong(java.lang.String,long) -> b
    float getFloat(java.lang.String,float) -> b
    java.lang.String getString(java.lang.String,java.lang.String) -> b
    java.util.Map get() -> a
    boolean contains(java.lang.String) -> f
    void clear() -> b
    void remove(java.lang.String) -> g
    void flush() -> c
com.badlogic.gdx.Screen -> com.badlogic.gdx.af:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void hide() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.Version -> com.badlogic.gdx.ag:
    java.lang.String VERSION -> a
com.badlogic.gdx.android.AndroidWallpaperListener -> com.badlogic.gdx.a.a:
    void offsetChange(float,float,float,float,int,int) -> a
    void previewStateChange(boolean) -> a
com.badlogic.gdx.assets.AssetDescriptor -> com.badlogic.gdx.b.a:
    java.lang.String fileName -> a
    java.lang.Class type -> b
    com.badlogic.gdx.assets.AssetLoaderParameters params -> c
    java.lang.String toString() -> toString
com.badlogic.gdx.assets.AssetErrorListener -> com.badlogic.gdx.b.b:
    void error(java.lang.String,java.lang.Class,java.lang.Throwable) -> a
com.badlogic.gdx.assets.AssetLoaderParameters -> com.badlogic.gdx.b.c:
    com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback loadedCallback -> a
com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback -> com.badlogic.gdx.b.d:
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.assets.AssetLoadingTask -> com.badlogic.gdx.b.e:
    com.badlogic.gdx.assets.AssetManager manager -> a
    com.badlogic.gdx.assets.AssetDescriptor assetDesc -> b
    com.badlogic.gdx.assets.loaders.AssetLoader loader -> c
    java.util.concurrent.ExecutorService threadPool -> d
    long startTime -> e
    boolean asyncDone -> f
    boolean dependenciesLoaded -> g
    com.badlogic.gdx.utils.Array dependencies -> h
    java.util.concurrent.Future depsFuture -> i
    java.util.concurrent.Future loadFuture -> j
    java.lang.Object asset -> k
    int ticks -> l
    boolean cancel -> m
    java.lang.Void call() -> a
    boolean update() -> b
    void handleSyncLoader() -> d
    void handleAsyncLoader() -> e
    java.lang.Object getAsset() -> c
    java.lang.Object call() -> call
com.badlogic.gdx.assets.AssetManager -> com.badlogic.gdx.b.f:
    com.badlogic.gdx.utils.ObjectMap assets -> a
    com.badlogic.gdx.utils.ObjectMap assetTypes -> b
    com.badlogic.gdx.utils.ObjectMap assetDependencies -> c
    com.badlogic.gdx.utils.ObjectMap loaders -> d
    com.badlogic.gdx.utils.Array loadQueue -> e
    java.util.concurrent.ExecutorService threadPool -> f
    java.util.Stack tasks -> g
    com.badlogic.gdx.assets.AssetErrorListener listener -> h
    int loaded -> i
    int toLoad -> j
    com.badlogic.gdx.utils.Logger log -> k
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    void unload(java.lang.String) -> b
    boolean containsAsset(java.lang.Object) -> a
    java.lang.String getAssetFileName(java.lang.Object) -> b
    boolean isLoaded(java.lang.String) -> c
    boolean isLoaded(java.lang.String,java.lang.Class) -> b
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class) -> a
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class,java.lang.String) -> a
    void load(java.lang.String,java.lang.Class) -> c
    void load(java.lang.String,java.lang.Class,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void load(com.badlogic.gdx.assets.AssetDescriptor) -> a
    void disposeDependencies(java.lang.String) -> g
    boolean update() -> a
    boolean update(int) -> a
    void finishLoading() -> b
    void injectDependency(java.lang.String,com.badlogic.gdx.assets.AssetDescriptor) -> a
    void nextTask() -> k
    void addTask(com.badlogic.gdx.assets.AssetDescriptor) -> b
    void addAsset(java.lang.String,java.lang.Class,java.lang.Object) -> a
    boolean updateTask() -> l
    void incrementRefCountedDependencies(java.lang.String) -> h
    void handleTaskError(java.lang.Throwable) -> a
    void setLoader(java.lang.Class,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setLoader(java.lang.Class,java.lang.String,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    int getLoadedAssets() -> c
    int getQueuedAssets() -> d
    float getProgress() -> f
    void setErrorListener(com.badlogic.gdx.assets.AssetErrorListener) -> a
    void dispose() -> e
    void clear() -> g
    com.badlogic.gdx.utils.Logger getLogger() -> h
    int getReferenceCount(java.lang.String) -> d
    void setReferenceCount(java.lang.String,int) -> a
    java.lang.String getDiagnostics() -> i
    com.badlogic.gdx.utils.Array getAssetNames() -> j
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String) -> e
    java.lang.Class getAssetType(java.lang.String) -> f
com.badlogic.gdx.assets.AssetManager$1 -> com.badlogic.gdx.b.g:
    com.badlogic.gdx.assets.AssetManager this$0 -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
com.badlogic.gdx.assets.RefCountedContainer -> com.badlogic.gdx.b.h:
    java.lang.Object object -> a
    int refCount -> b
    void incRefCount() -> a
    void decRefCount() -> b
    int getRefCount() -> c
    void setRefCount(int) -> a
    java.lang.Object getObject(java.lang.Class) -> a
    void setObject(java.lang.Object) -> a
com.badlogic.gdx.assets.loaders.AssetLoader -> com.badlogic.gdx.b.a.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> com.badlogic.gdx.b.a.b:
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.BitmapFontLoader -> com.badlogic.gdx.b.a.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter -> com.badlogic.gdx.b.a.d:
    boolean flip -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter minFitler -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter maxFilter -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData bitmapFontData -> e
com.badlogic.gdx.assets.loaders.FileHandleResolver -> com.badlogic.gdx.b.a.e:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.MusicLoader -> com.badlogic.gdx.b.a.f:
    com.badlogic.gdx.audio.Music load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter -> com.badlogic.gdx.b.a.g:
com.badlogic.gdx.assets.loaders.PixmapLoader -> com.badlogic.gdx.b.a.h:
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    com.badlogic.gdx.graphics.Pixmap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter -> com.badlogic.gdx.b.a.i:
com.badlogic.gdx.assets.loaders.SkinLoader -> com.badlogic.gdx.b.a.j:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter -> com.badlogic.gdx.b.a.k:
    java.lang.String textureAtlasPath -> b
com.badlogic.gdx.assets.loaders.SoundLoader -> com.badlogic.gdx.b.a.l:
    com.badlogic.gdx.audio.Sound load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter -> com.badlogic.gdx.b.a.m:
com.badlogic.gdx.assets.loaders.SynchronousAssetLoader -> com.badlogic.gdx.b.a.n:
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader -> com.badlogic.gdx.b.a.o:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData data -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter -> com.badlogic.gdx.b.a.p:
    boolean flip -> b
com.badlogic.gdx.assets.loaders.TextureLoader -> com.badlogic.gdx.b.a.q:
    com.badlogic.gdx.graphics.TextureData data -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    com.badlogic.gdx.graphics.Texture loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter -> com.badlogic.gdx.b.a.r:
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.graphics.TextureData textureData -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> i
com.badlogic.gdx.assets.loaders.resolvers.ExternalFileHandleResolver -> com.badlogic.gdx.b.a.a.a:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> com.badlogic.gdx.b.a.a.b:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver -> com.badlogic.gdx.b.a.a.c:
    com.badlogic.gdx.assets.loaders.FileHandleResolver baseResolver -> a
    com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver$Resolution[] descriptors -> b
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
    java.lang.String resolve(com.badlogic.gdx.files.FileHandle,java.lang.String) -> a
    com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver$Resolution choose(com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver$Resolution[]) -> a
com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver$Resolution -> com.badlogic.gdx.b.a.a.d:
    int portraitWidth -> a
    int portraitHeight -> b
    java.lang.String suffix -> c
com.badlogic.gdx.audio.AudioDevice -> com.badlogic.gdx.c.a:
    boolean isMono() -> a
    void writeSamples(short[],int,int) -> a
    void writeSamples(float[],int,int) -> a
    int getLatency() -> b
    void dispose() -> e
    void setVolume(float) -> a
com.badlogic.gdx.audio.AudioRecorder -> com.badlogic.gdx.c.b:
    void read(short[],int,int) -> a
    void dispose() -> e
com.badlogic.gdx.audio.Music -> com.badlogic.gdx.c.c:
    void play() -> a
    void pause() -> b
    void stop() -> c
    boolean isPlaying() -> d
    void setLooping(boolean) -> a
    boolean isLooping() -> f
    void setVolume(float) -> a
    float getVolume() -> g
    float getPosition() -> h
    void dispose() -> e
com.badlogic.gdx.audio.Sound -> com.badlogic.gdx.c.d:
    long play() -> a
    long play(float) -> a
    long play(float,float,float) -> a
    long loop() -> b
    long loop(float) -> b
    long loop(float,float,float) -> b
    void stop() -> c
    void dispose() -> e
    void stop(long) -> a
    void setLooping(long,boolean) -> a
    void setPitch(long,float) -> a
    void setVolume(long,float) -> b
    void setPan(long,float,float) -> a
    void setPriority(long,int) -> a
com.badlogic.gdx.backends.android.AndroidApplication -> com.badlogic.gdx.backends.android.a:
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> e
    com.badlogic.gdx.backends.android.AndroidInput input -> f
    com.badlogic.gdx.backends.android.AndroidAudio audio -> g
    com.badlogic.gdx.backends.android.AndroidFiles files -> h
    com.badlogic.gdx.backends.android.AndroidNet net -> i
    com.badlogic.gdx.ApplicationListener listener -> j
    android.os.Handler handler -> k
    boolean firstResume -> l
    com.badlogic.gdx.utils.Array runnables -> m
    com.badlogic.gdx.utils.Array executedRunnables -> n
    com.badlogic.gdx.utils.Array lifecycleListeners -> o
    android.os.PowerManager$WakeLock wakeLock -> p
    int logLevel -> q
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> r
    void initialize(com.badlogic.gdx.ApplicationListener,boolean) -> a
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> m
    void createWakeLock(com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void hideStatusBar(com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> b
    android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,boolean) -> b
    android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> b
    void onPause() -> onPause
    void onResume() -> onResume
    void onDestroy() -> onDestroy
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Audio getAudio() -> c
    com.badlogic.gdx.Files getFiles() -> e
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.Input getInput() -> d
    com.badlogic.gdx.Net getNet() -> f
    com.badlogic.gdx.Application$ApplicationType getType() -> g
    int getVersion() -> h
    long getJavaHeap() -> i
    long getNativeHeap() -> j
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.utils.Clipboard getClipboard() -> k
    void postRunnable(java.lang.Runnable) -> a
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void exit() -> l
    void debug(java.lang.String,java.lang.String) -> c
    void debug(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Exception) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void setLogLevel(int) -> a
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
com.badlogic.gdx.backends.android.AndroidApplication$1 -> com.badlogic.gdx.backends.android.b:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> com.badlogic.gdx.backends.android.c:
    boolean useGL20 -> a
    int r -> b
    int g -> c
    int b -> d
    int a -> e
    int depth -> f
    int stencil -> g
    int numSamples -> h
    boolean useAccelerometer -> i
    boolean useCompass -> j
    int touchSleepTime -> k
    boolean useWakelock -> l
    boolean hideStatusBar -> m
    int maxSimultaneousSounds -> n
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> o
    boolean getTouchEventsForLiveWallpaper -> p
com.badlogic.gdx.backends.android.AndroidAudio -> com.badlogic.gdx.backends.android.d:
    android.media.SoundPool soundPool -> b
    android.media.AudioManager manager -> c
    java.util.List musics -> a
    void pause() -> a
    void resume() -> b
    com.badlogic.gdx.audio.AudioDevice newAudioDevice(int,boolean) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.audio.AudioRecorder newAudioRecorder(int,boolean) -> b
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidAudioDevice -> com.badlogic.gdx.backends.android.e:
    android.media.AudioTrack track -> a
    short[] buffer -> b
    boolean isMono -> c
    int latency -> d
    void dispose() -> e
    boolean isMono() -> a
    void writeSamples(short[],int,int) -> a
    void writeSamples(float[],int,int) -> a
    int getLatency() -> b
    void setVolume(float) -> a
com.badlogic.gdx.backends.android.AndroidAudioRecorder -> com.badlogic.gdx.backends.android.f:
    android.media.AudioRecord recorder -> a
    void dispose() -> e
    void read(short[],int,int) -> a
com.badlogic.gdx.backends.android.AndroidClipboard -> com.badlogic.gdx.backends.android.g:
    android.content.Context context -> a
    java.lang.String contents -> b
    java.lang.String getContents() -> a
    void setContents(java.lang.String) -> a
com.badlogic.gdx.backends.android.AndroidDaydream -> com.badlogic.gdx.backends.android.h:
    com.badlogic.gdx.backends.android.AndroidGraphicsDaydream graphics -> e
    com.badlogic.gdx.backends.android.AndroidInput input -> f
    com.badlogic.gdx.backends.android.AndroidAudio audio -> g
    com.badlogic.gdx.backends.android.AndroidFiles files -> h
    com.badlogic.gdx.backends.android.AndroidNet net -> i
    com.badlogic.gdx.ApplicationListener listener -> j
    android.os.Handler handler -> k
    boolean firstResume -> l
    com.badlogic.gdx.utils.Array runnables -> m
    com.badlogic.gdx.utils.Array executedRunnables -> n
    com.badlogic.gdx.utils.Array lifecycleListeners -> o
    android.os.PowerManager$WakeLock wakeLock -> p
    int logLevel -> q
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> r
    void initialize(com.badlogic.gdx.ApplicationListener,boolean) -> a
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> m
    void createWakeLock(com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void hideStatusBar(com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> b
    android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,boolean) -> b
    android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> b
    void onDreamingStopped() -> n
    void onDreamingStarted() -> o
    void onDetachedFromWindow() -> p
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Audio getAudio() -> c
    com.badlogic.gdx.Files getFiles() -> e
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.Input getInput() -> d
    com.badlogic.gdx.Net getNet() -> f
    com.badlogic.gdx.Application$ApplicationType getType() -> g
    int getVersion() -> h
    long getJavaHeap() -> i
    long getNativeHeap() -> j
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.utils.Clipboard getClipboard() -> k
    void postRunnable(java.lang.Runnable) -> a
    void onConfigurationChanged(android.content.res.Configuration) -> a
    void exit() -> l
    void debug(java.lang.String,java.lang.String) -> c
    void debug(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Exception) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void setLogLevel(int) -> a
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
com.badlogic.gdx.backends.android.AndroidDaydream$1 -> com.badlogic.gdx.backends.android.i:
    com.badlogic.gdx.backends.android.AndroidDaydream this$0 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidFileHandle -> com.badlogic.gdx.backends.android.j:
    android.content.res.AssetManager assets -> a
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    java.io.InputStream read() -> b
    com.badlogic.gdx.files.FileHandle[] list() -> c
    com.badlogic.gdx.files.FileHandle[] list(java.lang.String) -> c
    boolean isDirectory() -> d
    boolean exists() -> e
    long length() -> f
    long lastModified() -> g
com.badlogic.gdx.backends.android.AndroidFiles -> com.badlogic.gdx.backends.android.k:
    java.lang.String sdcard -> a
    java.lang.String localpath -> b
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle external(java.lang.String) -> c
    com.badlogic.gdx.files.FileHandle absolute(java.lang.String) -> d
    com.badlogic.gdx.files.FileHandle local(java.lang.String) -> e
    java.lang.String getExternalStoragePath() -> a
    boolean isExternalStorageAvailable() -> b
    java.lang.String getLocalStoragePath() -> c
    boolean isLocalStorageAvailable() -> d
com.badlogic.gdx.backends.android.AndroidGL10 -> com.badlogic.gdx.backends.android.l:
    javax.microedition.khronos.opengles.GL10 gl -> a_
    void glActiveTexture(int) -> glActiveTexture
    void glAlphaFunc(int,float) -> a
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glClearDepthf(float) -> glClearDepthf
    void glClearStencil(int) -> glClearStencil
    void glClientActiveTexture(int) -> a
    void glColor4f(float,float,float,float) -> a
    void glColorMask(boolean,boolean,boolean,boolean) -> glColorMask
    void glColorPointer(int,int,int,java.nio.Buffer) -> a
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glCompressedTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexSubImage2D
    void glCopyTexImage2D(int,int,int,int,int,int,int,int) -> glCopyTexImage2D
    void glCopyTexSubImage2D(int,int,int,int,int,int,int,int) -> glCopyTexSubImage2D
    void glCullFace(int) -> glCullFace
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthFunc(int) -> glDepthFunc
    void glDepthMask(boolean) -> glDepthMask
    void glDepthRangef(float,float) -> glDepthRangef
    void glDisable(int) -> glDisable
    void glDisableClientState(int) -> b
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableClientState(int) -> c
    void glFinish() -> glFinish
    void glFlush() -> glFlush
    void glFogf(int,float) -> b
    void glFogfv(int,java.nio.FloatBuffer) -> a
    void glFrontFace(int) -> glFrontFace
    void glFrustumf(float,float,float,float,float,float) -> a
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    int glGetError() -> glGetError
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glHint(int,int) -> glHint
    void glLightModelf(int,float) -> c
    void glLightModelfv(int,java.nio.FloatBuffer) -> b
    void glLightf(int,int,float) -> a
    void glLightfv(int,int,java.nio.FloatBuffer) -> a
    void glLineWidth(float) -> glLineWidth
    void glLoadIdentity() -> a
    void glLoadMatrixf(java.nio.FloatBuffer) -> a
    void glLogicOp(int) -> d
    void glMaterialf(int,int,float) -> b
    void glMaterialfv(int,int,java.nio.FloatBuffer) -> b
    void glMatrixMode(int) -> e
    void glMultMatrixf(java.nio.FloatBuffer) -> b
    void glMultiTexCoord4f(int,float,float,float,float) -> a
    void glNormal3f(float,float,float) -> a
    void glNormalPointer(int,int,java.nio.Buffer) -> a
    void glOrthof(float,float,float,float,float,float) -> b
    void glPixelStorei(int,int) -> glPixelStorei
    void glPointSize(float) -> a
    void glPolygonOffset(float,float) -> glPolygonOffset
    void glPopMatrix() -> b
    void glPushMatrix() -> c
    void glReadPixels(int,int,int,int,int,int,java.nio.Buffer) -> glReadPixels
    void glRotatef(float,float,float,float) -> b
    void glSampleCoverage(float,boolean) -> a
    void glScalef(float,float,float) -> b
    void glScissor(int,int,int,int) -> glScissor
    void glShadeModel(int) -> f
    void glStencilFunc(int,int,int) -> glStencilFunc
    void glStencilMask(int) -> glStencilMask
    void glStencilOp(int,int,int) -> glStencilOp
    void glTexCoordPointer(int,int,int,java.nio.Buffer) -> b
    void glTexEnvf(int,int,float) -> c
    void glTexEnvfv(int,int,java.nio.FloatBuffer) -> c
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexSubImage2D
    void glTranslatef(float,float,float) -> c
    void glVertexPointer(int,int,int,java.nio.Buffer) -> c
    void glViewport(int,int,int,int) -> glViewport
    void glDeleteTextures(int,int[],int) -> a
    void glFogfv(int,float[],int) -> a
    void glGenTextures(int,int[],int) -> b
    void glGetIntegerv(int,int[],int) -> c
    void glLightModelfv(int,float[],int) -> b
    void glLightfv(int,int,float[],int) -> a
    void glLoadMatrixf(float[],int) -> a
    void glMaterialfv(int,int,float[],int) -> b
    void glMultMatrixf(float[],int) -> b
    void glTexEnvfv(int,int,float[],int) -> c
    void glPolygonMode(int,int) -> a
com.badlogic.gdx.backends.android.AndroidGL11 -> com.badlogic.gdx.backends.android.m:
    javax.microedition.khronos.opengles.GL11 gl -> gg
    void glBindBuffer(int,int) -> b
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glBufferSubData(int,int,int,java.nio.Buffer) -> d
    void glClipPlanef(int,java.nio.FloatBuffer) -> c
    void glColor4ub(byte,byte,byte,byte) -> a
    void glDeleteBuffers(int,java.nio.IntBuffer) -> a
    void glGenBuffers(int,java.nio.IntBuffer) -> b
    void glGetBooleanv(int,java.nio.IntBuffer) -> c
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> a
    void glGetClipPlanef(int,java.nio.FloatBuffer) -> d
    void glGetFloatv(int,java.nio.FloatBuffer) -> e
    void glGetLightfv(int,int,java.nio.FloatBuffer) -> d
    void glGetMaterialfv(int,int,java.nio.FloatBuffer) -> e
    void glGetPointerv(int,java.nio.Buffer[]) -> a
    void glGetTexEnviv(int,int,java.nio.IntBuffer) -> b
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> f
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> c
    boolean glIsBuffer(int) -> g
    boolean glIsEnabled(int) -> h
    boolean glIsTexture(int) -> i
    void glPointParameterf(int,float) -> d
    void glPointParameterfv(int,java.nio.FloatBuffer) -> f
    void glPointSizePointerOES(int,int,java.nio.Buffer) -> b
    void glTexEnvi(int,int,int) -> a
    void glTexEnviv(int,int,java.nio.IntBuffer) -> d
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> g
    void glTexParameteri(int,int,int) -> b
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> e
    void glClipPlanef(int,float[],int) -> c
    void glDeleteBuffers(int,int[],int) -> d
    void glGenBuffers(int,int[],int) -> e
    void glGetBooleanv(int,boolean[],int) -> a
    void glGetBufferParameteriv(int,int,int[],int) -> a
    void glGetClipPlanef(int,float[],int) -> d
    void glGetFloatv(int,float[],int) -> e
    void glGetLightfv(int,int,float[],int) -> d
    void glGetMaterialfv(int,int,float[],int) -> e
    void glGetTexEnviv(int,int,int[],int) -> b
    void glGetTexParameterfv(int,int,float[],int) -> f
    void glGetTexParameteriv(int,int,int[],int) -> c
    void glPointParameterfv(int,float[],int) -> f
    void glTexEnviv(int,int,int[],int) -> d
    void glTexParameterfv(int,int,float[],int) -> g
    void glTexParameteriv(int,int,int[],int) -> e
    void glColorPointer(int,int,int,int) -> a
    void glNormalPointer(int,int,int) -> c
    void glTexCoordPointer(int,int,int,int) -> b
    void glVertexPointer(int,int,int,int) -> c
    void glDrawElements(int,int,int,int) -> d
com.badlogic.gdx.backends.android.AndroidGL20 -> com.badlogic.gdx.backends.android.AndroidGL20:
    void init() -> init
    void glActiveTexture(int) -> glActiveTexture
    void glAttachShader(int,int) -> glAttachShader
    void glBindAttribLocation(int,int,java.lang.String) -> glBindAttribLocation
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBindTexture(int,int) -> glBindTexture
    void glBlendColor(float,float,float,float) -> glBlendColor
    void glBlendEquation(int) -> glBlendEquation
    void glBlendEquationSeparate(int,int) -> glBlendEquationSeparate
    void glBlendFunc(int,int) -> glBlendFunc
    void glBlendFuncSeparate(int,int,int,int) -> glBlendFuncSeparate
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glClearDepthf(float) -> glClearDepthf
    void glClearStencil(int) -> glClearStencil
    void glColorMask(boolean,boolean,boolean,boolean) -> glColorMask
    void glCompileShader(int) -> glCompileShader
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glCompressedTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexSubImage2D
    void glCopyTexImage2D(int,int,int,int,int,int,int,int) -> glCopyTexImage2D
    void glCopyTexSubImage2D(int,int,int,int,int,int,int,int) -> glCopyTexSubImage2D
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glCullFace(int) -> glCullFace
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthFunc(int) -> glDepthFunc
    void glDepthMask(boolean) -> glDepthMask
    void glDepthRangef(float,float) -> glDepthRangef
    void glDetachShader(int,int) -> glDetachShader
    void glDisable(int) -> glDisable
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFinish() -> glFinish
    void glFlush() -> glFlush
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glFrontFace(int) -> glFrontFace
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    void glGetAttachedShaders(int,int,java.nio.Buffer,java.nio.IntBuffer) -> glGetAttachedShaders
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetBooleanv(int,java.nio.Buffer) -> glGetBooleanv
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> glGetBufferParameteriv
    int glGetError() -> glGetError
    void glGetFloatv(int,java.nio.FloatBuffer) -> glGetFloatv
    void glGetFramebufferAttachmentParameteriv(int,int,int,java.nio.IntBuffer) -> glGetFramebufferAttachmentParameteriv
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetRenderbufferParameteriv(int,int,java.nio.IntBuffer) -> glGetRenderbufferParameteriv
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    void glGetShaderPrecisionFormat(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> glGetShaderPrecisionFormat
    void glGetShaderSource(int,int,java.nio.Buffer,java.lang.String) -> glGetShaderSource
    java.lang.String glGetString(int) -> glGetString
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> glGetTexParameterfv
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> glGetTexParameteriv
    void glGetUniformfv(int,int,java.nio.FloatBuffer) -> glGetUniformfv
    void glGetUniformiv(int,int,java.nio.IntBuffer) -> glGetUniformiv
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glGetVertexAttribfv(int,int,java.nio.FloatBuffer) -> glGetVertexAttribfv
    void glGetVertexAttribiv(int,int,java.nio.IntBuffer) -> glGetVertexAttribiv
    void glGetVertexAttribPointerv(int,int,java.nio.Buffer) -> glGetVertexAttribPointerv
    void glHint(int,int) -> glHint
    boolean glIsBuffer(int) -> glIsBuffer
    boolean glIsEnabled(int) -> glIsEnabled
    boolean glIsFramebuffer(int) -> glIsFramebuffer
    boolean glIsProgram(int) -> glIsProgram
    boolean glIsRenderbuffer(int) -> glIsRenderbuffer
    boolean glIsShader(int) -> glIsShader
    boolean glIsTexture(int) -> glIsTexture
    void glLineWidth(float) -> glLineWidth
    void glLinkProgram(int) -> glLinkProgram
    void glPixelStorei(int,int) -> glPixelStorei
    void glPolygonOffset(float,float) -> glPolygonOffset
    void glReadPixels(int,int,int,int,int,int,java.nio.Buffer) -> glReadPixels
    void glReleaseShaderCompiler() -> glReleaseShaderCompiler
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glSampleCoverage(float,boolean) -> glSampleCoverage
    void glScissor(int,int,int,int) -> glScissor
    void glShaderBinary(int,java.nio.IntBuffer,int,java.nio.Buffer,int) -> glShaderBinary
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glStencilFunc(int,int,int) -> glStencilFunc
    void glStencilFuncSeparate(int,int,int,int) -> glStencilFuncSeparate
    void glStencilMask(int) -> glStencilMask
    void glStencilMaskSeparate(int,int) -> glStencilMaskSeparate
    void glStencilOp(int,int,int) -> glStencilOp
    void glStencilOpSeparate(int,int,int,int) -> glStencilOpSeparate
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> glTexParameterfv
    void glTexParameteri(int,int,int) -> glTexParameteri
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> glTexParameteriv
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexSubImage2D
    void glUniform1f(int,float) -> glUniform1f
    void glUniform1fv(int,int,java.nio.FloatBuffer) -> glUniform1fv
    void glUniform1i(int,int) -> glUniform1i
    void glUniform1iv(int,int,java.nio.IntBuffer) -> glUniform1iv
    void glUniform2f(int,float,float) -> glUniform2f
    void glUniform2fv(int,int,java.nio.FloatBuffer) -> glUniform2fv
    void glUniform2i(int,int,int) -> glUniform2i
    void glUniform2iv(int,int,java.nio.IntBuffer) -> glUniform2iv
    void glUniform3f(int,float,float,float) -> glUniform3f
    void glUniform3fv(int,int,java.nio.FloatBuffer) -> glUniform3fv
    void glUniform3i(int,int,int,int) -> glUniform3i
    void glUniform3iv(int,int,java.nio.IntBuffer) -> glUniform3iv
    void glUniform4f(int,float,float,float,float) -> glUniform4f
    void glUniform4fv(int,int,java.nio.FloatBuffer) -> glUniform4fv
    void glUniform4i(int,int,int,int,int) -> glUniform4i
    void glUniform4iv(int,int,java.nio.IntBuffer) -> glUniform4iv
    void glUniformMatrix2fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix2fv
    void glUniformMatrix3fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix3fv
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glValidateProgram(int) -> glValidateProgram
    void glVertexAttrib1f(int,float) -> glVertexAttrib1f
    void glVertexAttrib1fv(int,java.nio.FloatBuffer) -> glVertexAttrib1fv
    void glVertexAttrib2f(int,float,float) -> glVertexAttrib2f
    void glVertexAttrib2fv(int,java.nio.FloatBuffer) -> glVertexAttrib2fv
    void glVertexAttrib3f(int,float,float,float) -> glVertexAttrib3f
    void glVertexAttrib3fv(int,java.nio.FloatBuffer) -> glVertexAttrib3fv
    void glVertexAttrib4f(int,float,float,float,float) -> glVertexAttrib4f
    void glVertexAttrib4fv(int,java.nio.FloatBuffer) -> glVertexAttrib4fv
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
    void glViewport(int,int,int,int) -> glViewport
com.badlogic.gdx.backends.android.AndroidGraphics -> com.badlogic.gdx.backends.android.n:
    android.view.View view -> a
    int width -> b
    int height -> c
    com.badlogic.gdx.backends.android.AndroidApplication app -> d
    com.badlogic.gdx.graphics.GLCommon gl -> e
    com.badlogic.gdx.graphics.GL10 gl10 -> f
    com.badlogic.gdx.graphics.GL11 gl11 -> g
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    javax.microedition.khronos.egl.EGLContext eglContext -> i
    java.lang.String extensions -> j
    long lastFrameTime -> r
    float deltaTime -> s
    long frameStart -> t
    int frames -> u
    int fps -> v
    com.badlogic.gdx.math.WindowedMean mean -> w
    boolean created -> k
    boolean running -> l
    boolean pause -> m
    boolean resume -> n
    boolean destroy -> o
    float ppiX -> x
    float ppiY -> y
    float ppcX -> z
    float ppcY -> A
    float density -> B
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> C
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> D
    boolean isContinuous -> E
    int[] value -> p
    java.lang.Object synch -> q
    void setPreserveContext(android.view.View) -> a
    android.view.View createGLSurfaceView(android.app.Activity,boolean,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> D
    void updatePpi() -> E
    boolean checkGL20() -> F
    com.badlogic.gdx.graphics.GL10 getGL10() -> d
    com.badlogic.gdx.graphics.GL11 getGL11() -> e
    com.badlogic.gdx.graphics.GL20 getGL20() -> f
    int getHeight() -> h
    int getWidth() -> g
    boolean isGL11Available() -> a
    boolean isGL20Available() -> b
    boolean isPowerOfTwo(int) -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void resume() -> y
    void pause() -> z
    void destroy() -> A
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    float getDeltaTime() -> i
    float getRawDeltaTime() -> j
    com.badlogic.gdx.Graphics$GraphicsType getType() -> l
    int getFramesPerSecond() -> k
    void clearManagedCaches() -> B
    android.view.View getView() -> C
    com.badlogic.gdx.graphics.GLCommon getGLCommon() -> c
    float getPpiX() -> m
    float getPpiY() -> n
    float getPpcX() -> o
    float getPpcY() -> p
    float getDensity() -> q
    boolean supportsDisplayModeChange() -> r
    boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    com.badlogic.gdx.Graphics$DisplayMode[] getDisplayModes() -> s
    boolean setDisplayMode(int,int,boolean) -> a
    void setTitle(java.lang.String) -> a
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> t
    com.badlogic.gdx.Graphics$BufferFormat getBufferFormat() -> u
    void setVSync(boolean) -> a
    boolean supportsExtension(java.lang.String) -> b
    void setContinuousRendering(boolean) -> b
    boolean isContinuousRendering() -> v
    void requestRendering() -> w
    boolean isFullscreen() -> x
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> com.badlogic.gdx.backends.android.o:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy val$resolutionStrategy -> a
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> b
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
com.badlogic.gdx.backends.android.AndroidGraphics$1$1 -> com.badlogic.gdx.backends.android.p:
    com.badlogic.gdx.backends.android.AndroidGraphics$1 this$1 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> com.badlogic.gdx.backends.android.q:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidGraphicsDaydream -> com.badlogic.gdx.backends.android.r:
    android.view.View view -> a
    int width -> b
    int height -> c
    com.badlogic.gdx.backends.android.AndroidDaydream app -> d
    com.badlogic.gdx.graphics.GLCommon gl -> e
    com.badlogic.gdx.graphics.GL10 gl10 -> f
    com.badlogic.gdx.graphics.GL11 gl11 -> g
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    javax.microedition.khronos.egl.EGLContext eglContext -> i
    java.lang.String extensions -> j
    long lastFrameTime -> r
    float deltaTime -> s
    long frameStart -> t
    int frames -> u
    int fps -> v
    com.badlogic.gdx.math.WindowedMean mean -> w
    boolean created -> k
    boolean running -> l
    boolean pause -> m
    boolean resume -> n
    boolean destroy -> o
    float ppiX -> x
    float ppiY -> y
    float ppcX -> z
    float ppcY -> A
    float density -> B
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> C
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> D
    boolean isContinuous -> E
    int[] value -> p
    java.lang.Object synch -> q
    void setPreserveContext(android.view.View) -> a
    android.view.View createGLSurfaceView(android.service.dreams.DreamService,boolean,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> D
    void updatePpi() -> E
    boolean checkGL20() -> F
    com.badlogic.gdx.graphics.GL10 getGL10() -> d
    com.badlogic.gdx.graphics.GL11 getGL11() -> e
    com.badlogic.gdx.graphics.GL20 getGL20() -> f
    int getHeight() -> h
    int getWidth() -> g
    boolean isGL11Available() -> a
    boolean isGL20Available() -> b
    boolean isPowerOfTwo(int) -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void resume() -> y
    void pause() -> z
    void destroy() -> A
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    float getDeltaTime() -> i
    float getRawDeltaTime() -> j
    com.badlogic.gdx.Graphics$GraphicsType getType() -> l
    int getFramesPerSecond() -> k
    void clearManagedCaches() -> B
    android.view.View getView() -> C
    com.badlogic.gdx.graphics.GLCommon getGLCommon() -> c
    float getPpiX() -> m
    float getPpiY() -> n
    float getPpcX() -> o
    float getPpcY() -> p
    float getDensity() -> q
    boolean supportsDisplayModeChange() -> r
    boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    com.badlogic.gdx.Graphics$DisplayMode[] getDisplayModes() -> s
    boolean setDisplayMode(int,int,boolean) -> a
    void setTitle(java.lang.String) -> a
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> t
    com.badlogic.gdx.Graphics$BufferFormat getBufferFormat() -> u
    void setVSync(boolean) -> a
    boolean supportsExtension(java.lang.String) -> b
    void setContinuousRendering(boolean) -> b
    boolean isContinuousRendering() -> v
    void requestRendering() -> w
    boolean isFullscreen() -> x
com.badlogic.gdx.backends.android.AndroidGraphicsDaydream$1 -> com.badlogic.gdx.backends.android.s:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy val$resolutionStrategy -> a
    com.badlogic.gdx.backends.android.AndroidGraphicsDaydream this$0 -> b
    void onMeasure(int,int) -> onMeasure
com.badlogic.gdx.backends.android.AndroidGraphicsDaydream$AndroidDisplayMode -> com.badlogic.gdx.backends.android.t:
    com.badlogic.gdx.backends.android.AndroidGraphicsDaydream this$0 -> e
com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper -> com.badlogic.gdx.backends.android.u:
    android.view.View view -> a
    int width -> b
    int height -> c
    com.badlogic.gdx.backends.android.AndroidLiveWallpaper app -> d
    com.badlogic.gdx.graphics.GLCommon gl -> e
    com.badlogic.gdx.graphics.GL10 gl10 -> f
    com.badlogic.gdx.graphics.GL11 gl11 -> g
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    android.opengl.GLU glu -> i
    javax.microedition.khronos.egl.EGLContext eglContext -> j
    java.lang.String extensions -> k
    long lastFrameTime -> l
    float deltaTime -> m
    long frameStart -> n
    int frames -> o
    int fps -> p
    com.badlogic.gdx.math.WindowedMean mean -> q
    boolean created -> r
    boolean running -> s
    boolean pause -> t
    boolean resume -> u
    boolean destroy -> v
    float ppiX -> w
    float ppiY -> x
    float ppcX -> y
    float ppcY -> z
    float density -> A
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> F
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> G
    boolean isContinuous -> B
    boolean configLogged -> C
    int[] value -> D
    java.lang.Object synch -> E
    void setPreserveContext(java.lang.Object) -> a
    android.view.SurfaceHolder getSurfaceHolder() -> y
    android.view.View createGLSurfaceView(android.content.Context,boolean,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> F
    void updatePpi() -> G
    boolean checkGL20() -> z
    com.badlogic.gdx.graphics.GL10 getGL10() -> d
    com.badlogic.gdx.graphics.GL11 getGL11() -> e
    com.badlogic.gdx.graphics.GL20 getGL20() -> f
    int getHeight() -> h
    int getWidth() -> g
    boolean isGL11Available() -> a
    boolean isGL20Available() -> b
    boolean isPowerOfTwo(int) -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void resume() -> A
    void pause() -> B
    void destroy() -> C
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    float getDeltaTime() -> i
    float getRawDeltaTime() -> j
    com.badlogic.gdx.Graphics$GraphicsType getType() -> l
    int getFramesPerSecond() -> k
    void clearManagedCaches() -> D
    android.view.View getView() -> E
    com.badlogic.gdx.graphics.GLCommon getGLCommon() -> c
    float getPpiX() -> m
    float getPpiY() -> n
    float getPpcX() -> o
    float getPpcY() -> p
    float getDensity() -> q
    boolean supportsDisplayModeChange() -> r
    boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode) -> a
    com.badlogic.gdx.Graphics$DisplayMode[] getDisplayModes() -> s
    boolean setDisplayMode(int,int,boolean) -> a
    void setTitle(java.lang.String) -> a
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> t
    com.badlogic.gdx.Graphics$BufferFormat getBufferFormat() -> u
    void setVSync(boolean) -> a
    boolean supportsExtension(java.lang.String) -> b
    void setContinuousRendering(boolean) -> b
    boolean isContinuousRendering() -> v
    void requestRendering() -> w
    boolean isFullscreen() -> x
com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper$1 -> com.badlogic.gdx.backends.android.v:
    com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper this$0 -> a
    android.view.SurfaceHolder getHolder() -> getHolder
    void onDestroy() -> a
com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper$2 -> com.badlogic.gdx.backends.android.w:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy val$resolutionStrategy -> a
    com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper this$0 -> b
    void onMeasure(int,int) -> onMeasure
    android.view.SurfaceHolder getHolder() -> getHolder
    void onDestroy() -> a
com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper$3 -> com.badlogic.gdx.backends.android.x:
    com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper this$0 -> a
    android.view.SurfaceHolder getHolder() -> getHolder
com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper$AndroidDisplayMode -> com.badlogic.gdx.backends.android.y:
    com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper this$0 -> e
com.badlogic.gdx.backends.android.AndroidInput -> com.badlogic.gdx.backends.android.z:
    com.badlogic.gdx.utils.Pool usedKeyEvents -> a
    com.badlogic.gdx.utils.Pool usedTouchEvents -> b
    java.util.ArrayList keyListeners -> c
    java.util.ArrayList keyEvents -> d
    java.util.ArrayList touchEvents -> e
    int[] touchX -> f
    int[] touchY -> g
    int[] deltaX -> h
    int[] deltaY -> i
    boolean[] touched -> j
    int[] realId -> k
    boolean hasMultitouch -> l
    com.badlogic.gdx.utils.IntMap keys -> u
    android.hardware.SensorManager manager -> v
    boolean accelerometerAvailable -> m
    float[] accelerometerValues -> w
    java.lang.String text -> x
    com.badlogic.gdx.Input$TextInputListener textListener -> y
    android.os.Handler handle -> z
    com.badlogic.gdx.Application app -> n
    android.content.Context context -> o
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> A
    int sleepTime -> B
    boolean catchBack -> C
    boolean catchMenu -> D
    android.os.Vibrator vibrator -> p
    boolean compassAvailable -> E
    boolean keyboardAvailable -> q
    float[] magneticFieldValues -> F
    float azimuth -> G
    float pitch -> H
    float roll -> I
    float inclination -> J
    boolean justTouched -> K
    com.badlogic.gdx.InputProcessor processor -> L
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> M
    com.badlogic.gdx.Input$Orientation nativeOrientation -> N
    long currentEventTimeStamp -> O
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard onscreenKeyboard -> P
    android.hardware.SensorEventListener accelerometerListener -> Q
    android.hardware.SensorEventListener compassListener -> R
    boolean requestFocus -> r
    float[] R -> s
    float[] orientation -> t
    float getAccelerometerX() -> a
    float getAccelerometerY() -> b
    float getAccelerometerZ() -> c
    void getTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> a
    void getPlaceholderTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> b
    int getX() -> d
    int getY() -> f
    int getX(int) -> a
    int getY(int) -> c
    boolean isTouched(int) -> e
    boolean isKeyPressed(int) -> g
    boolean isTouched() -> h
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    void processEvents() -> s
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    void onTap(int,int) -> b
    void onDrop(int,int) -> c
    void postTap(int,int) -> d
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
    void setOnscreenKeyboardVisible(boolean) -> a
    void setCatchBackKey(boolean) -> b
    void setCatchMenuKey(boolean) -> c
    void vibrate(int) -> h
    void vibrate(long[],int) -> a
    void cancelVibrate() -> j
    boolean justTouched() -> i
    boolean isButtonPressed(int) -> f
    void updateOrientation() -> w
    void getRotationMatrix(float[]) -> a
    float getAzimuth() -> k
    float getPitch() -> l
    float getRoll() -> m
    void registerSensorListeners() -> t
    void unregisterSensorListeners() -> u
    com.badlogic.gdx.InputProcessor getInputProcessor() -> o
    boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral) -> a
    int getFreePointerIndex() -> v
    int lookUpPointerIndex(int) -> i
    int getRotation() -> p
    com.badlogic.gdx.Input$Orientation getNativeOrientation() -> q
    void setCursorCatched(boolean) -> d
    boolean isCursorCatched() -> r
    int getDeltaX() -> e
    int getDeltaX(int) -> b
    int getDeltaY() -> g
    int getDeltaY(int) -> d
    void setCursorPosition(int,int) -> a
    long getCurrentEventTime() -> n
    void addKeyListener(android.view.View$OnKeyListener) -> a
com.badlogic.gdx.backends.android.AndroidInput$1 -> com.badlogic.gdx.backends.android.aa:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$KeyEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$2 -> com.badlogic.gdx.backends.android.ab:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$TouchEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$3 -> com.badlogic.gdx.backends.android.ac:
    java.lang.String val$title -> a
    java.lang.String val$text -> b
    com.badlogic.gdx.Input$TextInputListener val$listener -> c
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> d
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$3$1 -> com.badlogic.gdx.backends.android.ad:
    android.widget.EditText val$input -> a
    com.badlogic.gdx.backends.android.AndroidInput$3 this$1 -> b
    void onClick(android.content.DialogInterface,int) -> onClick
com.badlogic.gdx.backends.android.AndroidInput$3$1$1 -> com.badlogic.gdx.backends.android.ae:
    com.badlogic.gdx.backends.android.AndroidInput$3$1 this$2 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$3$2 -> com.badlogic.gdx.backends.android.af:
    com.badlogic.gdx.backends.android.AndroidInput$3 this$1 -> a
    void onClick(android.content.DialogInterface,int) -> onClick
com.badlogic.gdx.backends.android.AndroidInput$3$2$1 -> com.badlogic.gdx.backends.android.ag:
    com.badlogic.gdx.backends.android.AndroidInput$3$2 this$2 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$3$3 -> com.badlogic.gdx.backends.android.ah:
    com.badlogic.gdx.backends.android.AndroidInput$3 this$1 -> a
    void onCancel(android.content.DialogInterface) -> onCancel
com.badlogic.gdx.backends.android.AndroidInput$3$3$1 -> com.badlogic.gdx.backends.android.ai:
    com.badlogic.gdx.backends.android.AndroidInput$3$3 this$2 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$4 -> com.badlogic.gdx.backends.android.aj:
    java.lang.String val$title -> a
    java.lang.String val$placeholder -> b
    com.badlogic.gdx.Input$TextInputListener val$listener -> c
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> d
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$4$1 -> com.badlogic.gdx.backends.android.ak:
    android.widget.EditText val$input -> a
    com.badlogic.gdx.backends.android.AndroidInput$4 this$1 -> b
    void onClick(android.content.DialogInterface,int) -> onClick
com.badlogic.gdx.backends.android.AndroidInput$4$1$1 -> com.badlogic.gdx.backends.android.al:
    com.badlogic.gdx.backends.android.AndroidInput$4$1 this$2 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$4$2 -> com.badlogic.gdx.backends.android.am:
    com.badlogic.gdx.backends.android.AndroidInput$4 this$1 -> a
    void onCancel(android.content.DialogInterface) -> onCancel
com.badlogic.gdx.backends.android.AndroidInput$4$2$1 -> com.badlogic.gdx.backends.android.an:
    com.badlogic.gdx.backends.android.AndroidInput$4$2 this$2 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$5 -> com.badlogic.gdx.backends.android.ao:
    boolean val$visible -> a
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> b
    void run() -> run
com.badlogic.gdx.backends.android.AndroidInput$KeyEvent -> com.badlogic.gdx.backends.android.ap:
    int KEY_DOWN -> a
    int KEY_UP -> b
    int KEY_TYPED -> c
    long timeStamp -> d
    int type -> e
    int keyCode -> f
    char keyChar -> g
com.badlogic.gdx.backends.android.AndroidInput$SensorListener -> com.badlogic.gdx.backends.android.aq:
    float[] accelerometerValues -> a
    float[] magneticFieldValues -> b
    com.badlogic.gdx.Input$Orientation nativeOrientation -> c
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> d
    void onAccuracyChanged(android.hardware.Sensor,int) -> onAccuracyChanged
    void onSensorChanged(android.hardware.SensorEvent) -> onSensorChanged
com.badlogic.gdx.backends.android.AndroidInput$TouchEvent -> com.badlogic.gdx.backends.android.ar:
    int TOUCH_DOWN -> a
    int TOUCH_UP -> b
    int TOUCH_DRAGGED -> c
    long timeStamp -> d
    int type -> e
    int x -> f
    int y -> g
    int pointer -> h
com.badlogic.gdx.backends.android.AndroidInputFactory -> com.badlogic.gdx.backends.android.as:
    com.badlogic.gdx.backends.android.AndroidInput newAndroidInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
com.badlogic.gdx.backends.android.AndroidInputThreePlus -> com.badlogic.gdx.backends.android.at:
    java.util.ArrayList genericMotionListeners -> u
    boolean onGenericMotion(android.view.View,android.view.MotionEvent) -> onGenericMotion
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> a
com.badlogic.gdx.backends.android.AndroidLiveWallpaper -> com.badlogic.gdx.backends.android.au:
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService service -> e
    com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper graphics -> f
    com.badlogic.gdx.backends.android.AndroidInput input -> g
    com.badlogic.gdx.backends.android.AndroidAudio audio -> h
    com.badlogic.gdx.backends.android.AndroidFiles files -> i
    com.badlogic.gdx.backends.android.AndroidNet net -> j
    com.badlogic.gdx.ApplicationListener listener -> k
    boolean firstResume -> l
    com.badlogic.gdx.utils.Array runnables -> m
    com.badlogic.gdx.utils.Array executedRunnables -> n
    com.badlogic.gdx.utils.Array lifecycleListeners -> o
    int logLevel -> p
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> q
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void onPause() -> m
    void onResume() -> n
    void onDestroy() -> o
    android.view.WindowManager getWindowManager() -> p
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService getService() -> q
    com.badlogic.gdx.ApplicationListener getListener() -> r
    void postRunnable(java.lang.Runnable) -> a
    com.badlogic.gdx.Audio getAudio() -> c
    com.badlogic.gdx.Files getFiles() -> e
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.Input getInput() -> d
    com.badlogic.gdx.Net getNet() -> f
    com.badlogic.gdx.Application$ApplicationType getType() -> g
    int getVersion() -> h
    long getJavaHeap() -> i
    long getNativeHeap() -> j
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    com.badlogic.gdx.utils.Clipboard getClipboard() -> k
    void debug(java.lang.String,java.lang.String) -> c
    void debug(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Exception) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void setLogLevel(int) -> a
    void exit() -> l
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> b
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
com.badlogic.gdx.backends.android.AndroidLiveWallpaperService -> com.badlogic.gdx.backends.android.av:
    java.lang.String TAG -> a
    boolean DEBUG -> b
    com.badlogic.gdx.backends.android.AndroidLiveWallpaper app -> c
    android.view.SurfaceHolder$Callback view -> d
    int viewFormat -> e
    int viewWidth -> f
    int viewHeight -> g
    int engines -> h
    int visibleEngines -> i
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine linkedEngine -> j
    boolean isPreviewNotified -> k
    boolean notifiedPreviewState -> l
    int[] sync -> m
    void setLinkedEngine(com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine) -> a
    void onCreate() -> onCreate
    android.service.wallpaper.WallpaperService$Engine onCreateEngine() -> onCreateEngine
    void onCreateApplication() -> a
    void initialize(com.badlogic.gdx.ApplicationListener,boolean) -> a
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    android.view.SurfaceHolder getSurfaceHolder() -> b
    void onDeepPauseApplication() -> c
    void onDestroy() -> onDestroy
    void finalize() -> finalize
    com.badlogic.gdx.backends.android.AndroidLiveWallpaper getLiveWallpaper() -> d
    android.view.WindowManager getWindowManager() -> e
com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine -> com.badlogic.gdx.backends.android.aw:
    boolean engineIsVisible -> a
    int engineFormat -> b
    int engineWidth -> c
    int engineHeight -> d
    boolean offsetsConsumed -> e
    float xOffset -> f
    float yOffset -> g
    float xOffsetStep -> h
    float yOffsetStep -> i
    int xPixelOffset -> j
    int yPixelOffset -> k
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService this$0 -> l
    void onCreate(android.view.SurfaceHolder) -> onCreate
    void onSurfaceCreated(android.view.SurfaceHolder) -> onSurfaceCreated
    void onSurfaceChanged(android.view.SurfaceHolder,int,int,int) -> onSurfaceChanged
    void notifySurfaceChanged(int,int,int,boolean) -> a
    void onVisibilityChanged(boolean) -> onVisibilityChanged
    void notifyVisibilityChanged(boolean) -> a
    void onResume() -> a
    void onPause() -> b
    void onSurfaceDestroyed(android.view.SurfaceHolder) -> onSurfaceDestroyed
    void onDestroy() -> onDestroy
    android.os.Bundle onCommand(java.lang.String,int,int,int,android.os.Bundle,boolean) -> onCommand
    void onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void onOffsetsChanged(float,float,float,float,int,int) -> onOffsetsChanged
    void notifyOffsetsChanged() -> c
    void notifyPreviewState() -> d
com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine$1 -> com.badlogic.gdx.backends.android.ax:
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine this$1 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine$2 -> com.badlogic.gdx.backends.android.ay:
    boolean val$currentPreviewState -> a
    com.badlogic.gdx.backends.android.AndroidLiveWallpaperService$AndroidWallpaperEngine this$1 -> b
    void run() -> run
com.badlogic.gdx.backends.android.AndroidMultiTouchHandler -> com.badlogic.gdx.backends.android.az:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    void logAction(int,int) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.AndroidInput,int,int,int,int,long) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidMusic -> com.badlogic.gdx.backends.android.ba:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> b
    android.media.MediaPlayer player -> c
    boolean isPrepared -> d
    boolean wasPlaying -> a
    float volume -> e
    void dispose() -> e
    boolean isLooping() -> f
    boolean isPlaying() -> d
    void pause() -> b
    void play() -> a
    void setLooping(boolean) -> a
    void setVolume(float) -> a
    float getVolume() -> g
    void stop() -> c
    float getPosition() -> h
com.badlogic.gdx.backends.android.AndroidNet -> com.badlogic.gdx.backends.android.bb:
    com.badlogic.gdx.backends.android.AndroidApplication app -> a
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
    void sendHttpRequest(com.badlogic.gdx.Net$HttpRequest,com.badlogic.gdx.Net$HttpResponseListener) -> a
    com.badlogic.gdx.net.ServerSocket newServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints) -> a
    com.badlogic.gdx.net.Socket newClientSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints) -> a
    void openURI(java.lang.String) -> a
com.badlogic.gdx.backends.android.AndroidNet$1 -> com.badlogic.gdx.backends.android.bc:
    android.net.Uri val$uri -> a
    com.badlogic.gdx.backends.android.AndroidNet this$0 -> b
    void run() -> run
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard -> com.badlogic.gdx.backends.android.bd:
    android.content.Context context -> a
    android.os.Handler handler -> b
    com.badlogic.gdx.backends.android.AndroidInput input -> c
    android.app.Dialog dialog -> d
    android.widget.TextView textView -> e
    android.app.Dialog createDialog() -> a
    android.widget.TextView createView(android.content.Context) -> a
    void setVisible(boolean) -> a
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$1 -> com.badlogic.gdx.backends.android.be:
    android.text.Editable editable -> a
    boolean getDefaultEditable() -> getDefaultEditable
    android.text.Editable getEditableText() -> getEditableText
    android.text.method.MovementMethod getDefaultMovementMethod() -> getDefaultMovementMethod
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    boolean onKeyUp(int,android.view.KeyEvent) -> onKeyUp
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$2 -> com.badlogic.gdx.backends.android.bf:
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard this$0 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$2$1 -> com.badlogic.gdx.backends.android.bg:
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$2 this$1 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$2$2 -> com.badlogic.gdx.backends.android.bh:
    int[] screenloc -> a
    int keyboardHeight -> d
    boolean keyboardShowing -> e
    android.view.View val$content -> b
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$2 this$1 -> c
    boolean onPreDraw() -> onPreDraw
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard$PassThroughEditable -> com.badlogic.gdx.backends.android.bi:
    char charAt(int) -> charAt
    int length() -> length
    java.lang.CharSequence subSequence(int,int) -> subSequence
    void getChars(int,int,char[],int) -> getChars
    void removeSpan(java.lang.Object) -> removeSpan
    void setSpan(java.lang.Object,int,int,int) -> setSpan
    int getSpanEnd(java.lang.Object) -> getSpanEnd
    int getSpanFlags(java.lang.Object) -> getSpanFlags
    int getSpanStart(java.lang.Object) -> getSpanStart
    java.lang.Object[] getSpans(int,int,java.lang.Class) -> getSpans
    int nextSpanTransition(int,int,java.lang.Class) -> nextSpanTransition
    android.text.Editable append(java.lang.CharSequence) -> append
    android.text.Editable append(char) -> append
    android.text.Editable append(java.lang.CharSequence,int,int) -> append
    void clear() -> clear
    void clearSpans() -> clearSpans
    android.text.Editable delete(int,int) -> delete
    android.text.InputFilter[] getFilters() -> getFilters
    android.text.Editable insert(int,java.lang.CharSequence) -> insert
    android.text.Editable insert(int,java.lang.CharSequence,int,int) -> insert
    android.text.Editable replace(int,int,java.lang.CharSequence) -> replace
    android.text.Editable replace(int,int,java.lang.CharSequence,int,int) -> replace
    void setFilters(android.text.InputFilter[]) -> setFilters
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
com.badlogic.gdx.backends.android.AndroidPreferences -> com.badlogic.gdx.backends.android.bj:
    android.content.SharedPreferences sharedPrefs -> a
    android.content.SharedPreferences$Editor editor -> b
    void putBoolean(java.lang.String,boolean) -> a
    void putInteger(java.lang.String,int) -> a
    void putLong(java.lang.String,long) -> a
    void putFloat(java.lang.String,float) -> a
    void putString(java.lang.String,java.lang.String) -> a
    void put(java.util.Map) -> a
    boolean getBoolean(java.lang.String) -> a
    int getInteger(java.lang.String) -> b
    long getLong(java.lang.String) -> c
    float getFloat(java.lang.String) -> d
    java.lang.String getString(java.lang.String) -> e
    boolean getBoolean(java.lang.String,boolean) -> b
    int getInteger(java.lang.String,int) -> b
    long getLong(java.lang.String,long) -> b
    float getFloat(java.lang.String,float) -> b
    java.lang.String getString(java.lang.String,java.lang.String) -> b
    java.util.Map get() -> a
    boolean contains(java.lang.String) -> f
    void clear() -> b
    void flush() -> c
    void remove(java.lang.String) -> g
    void edit() -> d
com.badlogic.gdx.backends.android.AndroidServerSocket -> com.badlogic.gdx.backends.android.bk:
    com.badlogic.gdx.Net$Protocol protocol -> a
    java.net.ServerSocket server -> b
    com.badlogic.gdx.Net$Protocol getProtocol() -> a
    com.badlogic.gdx.net.Socket accept(com.badlogic.gdx.net.SocketHints) -> a
    void dispose() -> e
com.badlogic.gdx.backends.android.AndroidSingleTouchHandler -> com.badlogic.gdx.backends.android.bl:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.AndroidInput,int,int,int,int,long) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidSocket -> com.badlogic.gdx.backends.android.bm:
    java.net.Socket socket -> a
    void applyHints(com.badlogic.gdx.net.SocketHints) -> a
    boolean isConnected() -> a
    java.io.InputStream getInputStream() -> b
    java.io.OutputStream getOutputStream() -> c
    void dispose() -> e
com.badlogic.gdx.backends.android.AndroidSound -> com.badlogic.gdx.backends.android.bn:
    android.media.SoundPool soundPool -> a
    android.media.AudioManager manager -> b
    int soundId -> c
    com.badlogic.gdx.utils.IntArray streamIds -> d
    void dispose() -> e
    long play() -> a
    long play(float) -> a
    void stop() -> c
    void stop(long) -> a
    void setPitch(long,float) -> a
    void setVolume(long,float) -> b
    long loop() -> b
    long loop(float) -> b
    void setLooping(long,boolean) -> a
    void setPan(long,float,float) -> a
    long play(float,float,float) -> a
    long loop(float,float,float) -> b
    void setPriority(long,int) -> a
com.badlogic.gdx.backends.android.AndroidTouchHandler -> com.badlogic.gdx.backends.android.bo:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.InputProcessorLW -> com.badlogic.gdx.backends.android.bp:
    void touchDrop(int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.DefaultGLSurfaceView -> com.badlogic.gdx.backends.android.a.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    void onMeasure(int,int) -> onMeasure
com.badlogic.gdx.backends.android.surfaceview.DefaultGLSurfaceViewLW -> com.badlogic.gdx.backends.android.a.b:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
com.badlogic.gdx.backends.android.surfaceview.EGLLogWrapper -> com.badlogic.gdx.backends.android.a.c:
    javax.microedition.khronos.egl.EGL10 mEgl10 -> d
    java.io.Writer mLog -> a
    boolean mLogArgumentNames -> b
    boolean mCheckError -> c
    int mArgCount -> e
    boolean eglChooseConfig(javax.microedition.khronos.egl.EGLDisplay,int[],javax.microedition.khronos.egl.EGLConfig[],int,int[]) -> eglChooseConfig
    boolean eglCopyBuffers(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface,java.lang.Object) -> eglCopyBuffers
    javax.microedition.khronos.egl.EGLContext eglCreateContext(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,javax.microedition.khronos.egl.EGLContext,int[]) -> eglCreateContext
    javax.microedition.khronos.egl.EGLSurface eglCreatePbufferSurface(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int[]) -> eglCreatePbufferSurface
    javax.microedition.khronos.egl.EGLSurface eglCreatePixmapSurface(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object,int[]) -> eglCreatePixmapSurface
    javax.microedition.khronos.egl.EGLSurface eglCreateWindowSurface(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object,int[]) -> eglCreateWindowSurface
    boolean eglDestroyContext(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> eglDestroyContext
    boolean eglDestroySurface(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> eglDestroySurface
    boolean eglGetConfigAttrib(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int[]) -> eglGetConfigAttrib
    boolean eglGetConfigs(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[],int,int[]) -> eglGetConfigs
    javax.microedition.khronos.egl.EGLContext eglGetCurrentContext() -> eglGetCurrentContext
    javax.microedition.khronos.egl.EGLDisplay eglGetCurrentDisplay() -> eglGetCurrentDisplay
    javax.microedition.khronos.egl.EGLSurface eglGetCurrentSurface(int) -> eglGetCurrentSurface
    javax.microedition.khronos.egl.EGLDisplay eglGetDisplay(java.lang.Object) -> eglGetDisplay
    int eglGetError() -> eglGetError
    boolean eglInitialize(javax.microedition.khronos.egl.EGLDisplay,int[]) -> eglInitialize
    boolean eglMakeCurrent(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface,javax.microedition.khronos.egl.EGLSurface,javax.microedition.khronos.egl.EGLContext) -> eglMakeCurrent
    boolean eglQueryContext(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext,int,int[]) -> eglQueryContext
    java.lang.String eglQueryString(javax.microedition.khronos.egl.EGLDisplay,int) -> eglQueryString
    boolean eglQuerySurface(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface,int,int[]) -> eglQuerySurface
    boolean eglSwapBuffers(javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> eglSwapBuffers
    boolean eglTerminate(javax.microedition.khronos.egl.EGLDisplay) -> eglTerminate
    boolean eglWaitGL() -> eglWaitGL
    boolean eglWaitNative(int,java.lang.Object) -> eglWaitNative
    void checkError() -> a
    void logLine(java.lang.String) -> a
    void log(java.lang.String) -> b
    void begin(java.lang.String) -> c
    void arg(java.lang.String,java.lang.String) -> a
    void end() -> b
    void flush() -> c
    void arg(java.lang.String,int) -> a
    void arg(java.lang.String,java.lang.Object) -> a
    void arg(java.lang.String,javax.microedition.khronos.egl.EGLDisplay) -> a
    void arg(java.lang.String,javax.microedition.khronos.egl.EGLContext) -> a
    void arg(java.lang.String,javax.microedition.khronos.egl.EGLSurface) -> a
    void returns(java.lang.String) -> d
    void returns(int) -> b
    void returns(boolean) -> a
    void returns(java.lang.Object) -> a
    java.lang.String toString(java.lang.Object) -> b
    void arg(java.lang.String,int[]) -> a
    void arg(java.lang.String,java.lang.Object[]) -> a
    java.lang.String toString(int,int[],int) -> a
    java.lang.String toString(int,java.lang.Object[],int) -> a
    java.lang.String getHex(int) -> c
    java.lang.String getErrorString(int) -> a
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> com.badlogic.gdx.backends.android.a.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.FixedResolutionStrategy -> com.badlogic.gdx.backends.android.a.e:
    int width -> a
    int height -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView -> com.badlogic.gdx.backends.android.a.f:
    boolean LOG_THREADS -> l
    boolean LOG_SURFACE -> m
    boolean LOG_RENDERER -> n
    boolean DRAW_TWICE_AFTER_SIZE_CHANGED -> o
    int RENDERMODE_WHEN_DIRTY -> a
    int RENDERMODE_CONTINUOUSLY -> b
    int DEBUG_CHECK_GL_ERROR -> c
    int DEBUG_LOG_GL_CALLS -> d
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThreadManager sGLThreadManager -> e
    boolean mSizeChanged -> f
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread mGLThread -> p
    android.opengl.GLSurfaceView$EGLConfigChooser mEGLConfigChooser -> g
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLContextFactory mEGLContextFactory -> h
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLWindowSurfaceFactory mEGLWindowSurfaceFactory -> i
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLWrapper mGLWrapper -> j
    int mDebugFlags -> k
    void init() -> a
    void setGLWrapper(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLWrapper) -> setGLWrapper
    void setDebugFlags(int) -> setDebugFlags
    int getDebugFlags() -> getDebugFlags
    void setRenderer(android.opengl.GLSurfaceView$Renderer) -> setRenderer
    void setEGLContextFactory(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLContextFactory) -> setEGLContextFactory
    void setEGLWindowSurfaceFactory(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLWindowSurfaceFactory) -> setEGLWindowSurfaceFactory
    void setEGLConfigChooser(android.opengl.GLSurfaceView$EGLConfigChooser) -> setEGLConfigChooser
    void setEGLConfigChooser(boolean) -> setEGLConfigChooser
    void setEGLConfigChooser(int,int,int,int,int,int) -> setEGLConfigChooser
    void setRenderMode(int) -> setRenderMode
    int getRenderMode() -> getRenderMode
    void requestRender() -> requestRender
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    void onPause() -> onPause
    void onResume() -> onResume
    void queueEvent(java.lang.Runnable) -> queueEvent
    void onDetachedFromWindow() -> onDetachedFromWindow
    void checkRenderThreadState() -> b
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$BaseConfigChooser -> com.badlogic.gdx.backends.android.a.g:
    int[] mConfigSpec -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$ComponentSizeChooser -> com.badlogic.gdx.backends.android.a.h:
    int[] mValue -> h
    int mRedSize -> b
    int mGreenSize -> c
    int mBlueSize -> d
    int mAlphaSize -> e
    int mDepthSize -> f
    int mStencilSize -> g
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$DefaultContextFactory -> com.badlogic.gdx.backends.android.a.i:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$DefaultWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.j:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLContextFactory -> com.badlogic.gdx.backends.android.a.k:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EGLWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.l:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EglHelper -> com.badlogic.gdx.backends.android.a.m:
    javax.microedition.khronos.egl.EGL10 mEgl -> a
    javax.microedition.khronos.egl.EGLDisplay mEglDisplay -> b
    javax.microedition.khronos.egl.EGLSurface mEglSurface -> c
    javax.microedition.khronos.egl.EGLConfig mEglConfig -> d
    javax.microedition.khronos.egl.EGLContext mEglContext -> e
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView this$0 -> f
    void start() -> a
    javax.microedition.khronos.opengles.GL createSurface(android.view.SurfaceHolder) -> a
    boolean swap() -> b
    void destroySurface() -> c
    void finish() -> d
    void throwEglException(java.lang.String) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread -> com.badlogic.gdx.backends.android.a.n:
    boolean mShouldExit -> c
    boolean mExited -> a
    boolean mPaused -> d
    boolean mHasSurface -> e
    boolean mWaitingForSurface -> f
    boolean mHaveEgl -> g
    int mWidth -> h
    int mHeight -> i
    int mRenderMode -> j
    boolean mRequestRender -> k
    boolean mRenderComplete -> l
    java.util.ArrayList mEventQueue -> m
    android.opengl.GLSurfaceView$Renderer mRenderer -> n
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$EglHelper mEglHelper -> o
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView this$0 -> b
    void run() -> run
    void stopEglLocked() -> h
    void guardedRun() -> i
    void setRenderMode(int) -> a
    int getRenderMode() -> a
    void requestRender() -> b
    void surfaceCreated() -> c
    void surfaceDestroyed() -> d
    void onPause() -> e
    void onResume() -> f
    void onWindowResize(int,int) -> a
    void requestExitAndWait() -> g
    void queueEvent(java.lang.Runnable) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThreadManager -> com.badlogic.gdx.backends.android.a.o:
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread mEglOwner -> a
    void threadExiting(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread) -> a
    boolean tryAcquireEglSurfaceLocked(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread) -> b
    void releaseEglSurfaceLocked(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLThread) -> c
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$GLWrapper -> com.badlogic.gdx.backends.android.a.p:
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$LogWriter -> com.badlogic.gdx.backends.android.a.q:
    java.lang.StringBuilder mBuilder -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceView$SimpleEGLConfigChooser -> com.badlogic.gdx.backends.android.a.r:
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW -> com.badlogic.gdx.backends.android.a.s:
    java.lang.String TAG -> a
    boolean LOG_VIEW -> n
    boolean LOG_THREADS -> o
    boolean LOG_SURFACE -> p
    boolean LOG_RENDERER -> q
    boolean DRAW_TWICE_AFTER_SIZE_CHANGED -> r
    int RENDERMODE_WHEN_DIRTY -> b
    int RENDERMODE_CONTINUOUSLY -> c
    int DEBUG_CHECK_GL_ERROR -> d
    int DEBUG_LOG_GL_CALLS -> e
    android.service.wallpaper.WallpaperService$Engine engine -> f
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThreadManager sGLThreadManager -> g
    boolean mSizeChanged -> h
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread mGLThread -> s
    android.opengl.GLSurfaceView$EGLConfigChooser mEGLConfigChooser -> i
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EGLContextFactory mEGLContextFactory -> j
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EGLWindowSurfaceFactory mEGLWindowSurfaceFactory -> k
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLWrapper mGLWrapper -> l
    int mDebugFlags -> m
    void init() -> h
    android.view.SurfaceHolder getHolder() -> a
    void setGLWrapper(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLWrapper) -> a
    void setDebugFlags(int) -> a
    int getDebugFlags() -> b
    void setRenderer(android.opengl.GLSurfaceView$Renderer) -> a
    void setEGLContextFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20LW$ContextFactory) -> a
    void setEGLWindowSurfaceFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20LW$ContextFactory) -> b
    void setEGLConfigChooser(android.opengl.GLSurfaceView$EGLConfigChooser) -> a
    void setEGLConfigChooser(boolean) -> a
    void setEGLConfigChooser(int,int,int,int,int,int) -> a
    void setRenderMode(int) -> b
    int getRenderMode() -> c
    void requestRender() -> d
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    void onPause() -> e
    void onResume() -> f
    void queueEvent(java.lang.Runnable) -> a
    void onDestroy() -> g
    void checkRenderThreadState() -> i
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$BaseConfigChooser -> com.badlogic.gdx.backends.android.a.t:
    int[] mConfigSpec -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$ComponentSizeChooser -> com.badlogic.gdx.backends.android.a.u:
    int[] mValue -> h
    int mRedSize -> b
    int mGreenSize -> c
    int mBlueSize -> d
    int mAlphaSize -> e
    int mDepthSize -> f
    int mStencilSize -> g
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$DefaultContextFactory -> com.badlogic.gdx.backends.android.a.v:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$DefaultWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.w:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EGLContextFactory -> com.badlogic.gdx.backends.android.a.x:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EGLWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.y:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EglHelper -> com.badlogic.gdx.backends.android.a.z:
    javax.microedition.khronos.egl.EGL10 mEgl -> a
    javax.microedition.khronos.egl.EGLDisplay mEglDisplay -> b
    javax.microedition.khronos.egl.EGLSurface mEglSurface -> c
    javax.microedition.khronos.egl.EGLConfig mEglConfig -> d
    javax.microedition.khronos.egl.EGLContext mEglContext -> e
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW this$0 -> f
    void start() -> a
    javax.microedition.khronos.opengles.GL createSurface(android.view.SurfaceHolder) -> a
    boolean swap() -> b
    void destroySurface() -> c
    void finish() -> d
    void throwEglException(java.lang.String) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread -> com.badlogic.gdx.backends.android.a.aa:
    boolean mShouldExit -> c
    boolean mExited -> a
    boolean mPaused -> d
    boolean mHasSurface -> e
    boolean mWaitingForSurface -> f
    boolean mHaveEgl -> g
    int mWidth -> h
    int mHeight -> i
    int mRenderMode -> j
    boolean mRequestRender -> k
    boolean mRenderComplete -> l
    java.util.ArrayList mEventQueue -> m
    android.opengl.GLSurfaceView$Renderer mRenderer -> n
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$EglHelper mEglHelper -> o
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW this$0 -> b
    void run() -> run
    void stopEglLocked() -> h
    void guardedRun() -> i
    void setRenderMode(int) -> a
    int getRenderMode() -> a
    void requestRender() -> b
    void surfaceCreated() -> c
    void surfaceDestroyed() -> d
    void onPause() -> e
    void onResume() -> f
    void onWindowResize(int,int) -> a
    void requestExitAndWait() -> g
    void queueEvent(java.lang.Runnable) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThreadManager -> com.badlogic.gdx.backends.android.a.ab:
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread mEglOwner -> b
    com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW this$0 -> a
    void threadExiting(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread) -> a
    boolean tryAcquireEglSurfaceLocked(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread) -> b
    void releaseEglSurfaceLocked(com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLThread) -> c
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$GLWrapper -> com.badlogic.gdx.backends.android.a.ac:
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL) -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$LogWriter -> com.badlogic.gdx.backends.android.a.ad:
    java.lang.StringBuilder mBuilder -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
com.badlogic.gdx.backends.android.surfaceview.GLBaseSurfaceViewLW$SimpleEGLConfigChooser -> com.badlogic.gdx.backends.android.a.ae:
com.badlogic.gdx.backends.android.surfaceview.GLDebugHelper -> com.badlogic.gdx.backends.android.a.af:
    int CONFIG_CHECK_GL_ERROR -> a
    int CONFIG_CHECK_THREAD -> b
    int CONFIG_LOG_ARGUMENT_NAMES -> c
    int ERROR_WRONG_THREAD -> d
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL,int,java.io.Writer) -> a
    javax.microedition.khronos.egl.EGL wrap(javax.microedition.khronos.egl.EGL,int,java.io.Writer) -> a
com.badlogic.gdx.backends.android.surfaceview.GLErrorWrapper -> com.badlogic.gdx.backends.android.a.ag:
    boolean mCheckError -> a
    boolean mCheckThread -> b
    java.lang.Thread mOurThread -> c
    void checkThread() -> a
    void checkError() -> b
    void glActiveTexture(int) -> glActiveTexture
    void glAlphaFunc(int,float) -> glAlphaFunc
    void glAlphaFuncx(int,int) -> glAlphaFuncx
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glClearColorx(int,int,int,int) -> glClearColorx
    void glClearDepthf(float) -> glClearDepthf
    void glClearDepthx(int) -> glClearDepthx
    void glClearStencil(int) -> glClearStencil
    void glClientActiveTexture(int) -> glClientActiveTexture
    void glColor4f(float,float,float,float) -> glColor4f
    void glColor4x(int,int,int,int) -> glColor4x
    void glColorMask(boolean,boolean,boolean,boolean) -> glColorMask
    void glColorPointer(int,int,int,java.nio.Buffer) -> glColorPointer
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glCompressedTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexSubImage2D
    void glCopyTexImage2D(int,int,int,int,int,int,int,int) -> glCopyTexImage2D
    void glCopyTexSubImage2D(int,int,int,int,int,int,int,int) -> glCopyTexSubImage2D
    void glCullFace(int) -> glCullFace
    void glDeleteTextures(int,int[],int) -> glDeleteTextures
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthFunc(int) -> glDepthFunc
    void glDepthMask(boolean) -> glDepthMask
    void glDepthRangef(float,float) -> glDepthRangef
    void glDepthRangex(int,int) -> glDepthRangex
    void glDisable(int) -> glDisable
    void glDisableClientState(int) -> glDisableClientState
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableClientState(int) -> glEnableClientState
    void glFinish() -> glFinish
    void glFlush() -> glFlush
    void glFogf(int,float) -> glFogf
    void glFogfv(int,float[],int) -> glFogfv
    void glFogfv(int,java.nio.FloatBuffer) -> glFogfv
    void glFogx(int,int) -> glFogx
    void glFogxv(int,int[],int) -> glFogxv
    void glFogxv(int,java.nio.IntBuffer) -> glFogxv
    void glFrontFace(int) -> glFrontFace
    void glFrustumf(float,float,float,float,float,float) -> glFrustumf
    void glFrustumx(int,int,int,int,int,int) -> glFrustumx
    void glGenTextures(int,int[],int) -> glGenTextures
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    int glGetError() -> glGetError
    void glGetIntegerv(int,int[],int) -> glGetIntegerv
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glHint(int,int) -> glHint
    void glLightModelf(int,float) -> glLightModelf
    void glLightModelfv(int,float[],int) -> glLightModelfv
    void glLightModelfv(int,java.nio.FloatBuffer) -> glLightModelfv
    void glLightModelx(int,int) -> glLightModelx
    void glLightModelxv(int,int[],int) -> glLightModelxv
    void glLightModelxv(int,java.nio.IntBuffer) -> glLightModelxv
    void glLightf(int,int,float) -> glLightf
    void glLightfv(int,int,float[],int) -> glLightfv
    void glLightfv(int,int,java.nio.FloatBuffer) -> glLightfv
    void glLightx(int,int,int) -> glLightx
    void glLightxv(int,int,int[],int) -> glLightxv
    void glLightxv(int,int,java.nio.IntBuffer) -> glLightxv
    void glLineWidth(float) -> glLineWidth
    void glLineWidthx(int) -> glLineWidthx
    void glLoadIdentity() -> glLoadIdentity
    void glLoadMatrixf(float[],int) -> glLoadMatrixf
    void glLoadMatrixf(java.nio.FloatBuffer) -> glLoadMatrixf
    void glLoadMatrixx(int[],int) -> glLoadMatrixx
    void glLoadMatrixx(java.nio.IntBuffer) -> glLoadMatrixx
    void glLogicOp(int) -> glLogicOp
    void glMaterialf(int,int,float) -> glMaterialf
    void glMaterialfv(int,int,float[],int) -> glMaterialfv
    void glMaterialfv(int,int,java.nio.FloatBuffer) -> glMaterialfv
    void glMaterialx(int,int,int) -> glMaterialx
    void glMaterialxv(int,int,int[],int) -> glMaterialxv
    void glMaterialxv(int,int,java.nio.IntBuffer) -> glMaterialxv
    void glMatrixMode(int) -> glMatrixMode
    void glMultMatrixf(float[],int) -> glMultMatrixf
    void glMultMatrixf(java.nio.FloatBuffer) -> glMultMatrixf
    void glMultMatrixx(int[],int) -> glMultMatrixx
    void glMultMatrixx(java.nio.IntBuffer) -> glMultMatrixx
    void glMultiTexCoord4f(int,float,float,float,float) -> glMultiTexCoord4f
    void glMultiTexCoord4x(int,int,int,int,int) -> glMultiTexCoord4x
    void glNormal3f(float,float,float) -> glNormal3f
    void glNormal3x(int,int,int) -> glNormal3x
    void glNormalPointer(int,int,java.nio.Buffer) -> glNormalPointer
    void glOrthof(float,float,float,float,float,float) -> glOrthof
    void glOrthox(int,int,int,int,int,int) -> glOrthox
    void glPixelStorei(int,int) -> glPixelStorei
    void glPointSize(float) -> glPointSize
    void glPointSizex(int) -> glPointSizex
    void glPolygonOffset(float,float) -> glPolygonOffset
    void glPolygonOffsetx(int,int) -> glPolygonOffsetx
    void glPopMatrix() -> glPopMatrix
    void glPushMatrix() -> glPushMatrix
    void glReadPixels(int,int,int,int,int,int,java.nio.Buffer) -> glReadPixels
    void glRotatef(float,float,float,float) -> glRotatef
    void glRotatex(int,int,int,int) -> glRotatex
    void glSampleCoverage(float,boolean) -> glSampleCoverage
    void glSampleCoveragex(int,boolean) -> glSampleCoveragex
    void glScalef(float,float,float) -> glScalef
    void glScalex(int,int,int) -> glScalex
    void glScissor(int,int,int,int) -> glScissor
    void glShadeModel(int) -> glShadeModel
    void glStencilFunc(int,int,int) -> glStencilFunc
    void glStencilMask(int) -> glStencilMask
    void glStencilOp(int,int,int) -> glStencilOp
    void glTexCoordPointer(int,int,int,java.nio.Buffer) -> glTexCoordPointer
    void glTexEnvf(int,int,float) -> glTexEnvf
    void glTexEnvfv(int,int,float[],int) -> glTexEnvfv
    void glTexEnvfv(int,int,java.nio.FloatBuffer) -> glTexEnvfv
    void glTexEnvx(int,int,int) -> glTexEnvx
    void glTexEnvxv(int,int,int[],int) -> glTexEnvxv
    void glTexEnvxv(int,int,java.nio.IntBuffer) -> glTexEnvxv
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glTexParameterx(int,int,int) -> glTexParameterx
    void glTexParameteriv(int,int,int[],int) -> glTexParameteriv
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> glTexParameteriv
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexSubImage2D
    void glTranslatef(float,float,float) -> glTranslatef
    void glTranslatex(int,int,int) -> glTranslatex
    void glVertexPointer(int,int,int,java.nio.Buffer) -> glVertexPointer
    void glViewport(int,int,int,int) -> glViewport
    void glClipPlanef(int,float[],int) -> glClipPlanef
    void glClipPlanef(int,java.nio.FloatBuffer) -> glClipPlanef
    void glClipPlanex(int,int[],int) -> glClipPlanex
    void glClipPlanex(int,java.nio.IntBuffer) -> glClipPlanex
    void glDrawTexfOES(float,float,float,float,float) -> glDrawTexfOES
    void glDrawTexfvOES(float[],int) -> glDrawTexfvOES
    void glDrawTexfvOES(java.nio.FloatBuffer) -> glDrawTexfvOES
    void glDrawTexiOES(int,int,int,int,int) -> glDrawTexiOES
    void glDrawTexivOES(int[],int) -> glDrawTexivOES
    void glDrawTexivOES(java.nio.IntBuffer) -> glDrawTexivOES
    void glDrawTexsOES(short,short,short,short,short) -> glDrawTexsOES
    void glDrawTexsvOES(short[],int) -> glDrawTexsvOES
    void glDrawTexsvOES(java.nio.ShortBuffer) -> glDrawTexsvOES
    void glDrawTexxOES(int,int,int,int,int) -> glDrawTexxOES
    void glDrawTexxvOES(int[],int) -> glDrawTexxvOES
    void glDrawTexxvOES(java.nio.IntBuffer) -> glDrawTexxvOES
    int glQueryMatrixxOES(int[],int,int[],int) -> glQueryMatrixxOES
    int glQueryMatrixxOES(java.nio.IntBuffer,java.nio.IntBuffer) -> glQueryMatrixxOES
com.badlogic.gdx.backends.android.surfaceview.GLException -> com.badlogic.gdx.backends.android.a.ah:
    int mError -> a
    java.lang.String getErrorString(int) -> a
    int getError() -> a
com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper -> com.badlogic.gdx.backends.android.a.ai:
    int FORMAT_INT -> k
    int FORMAT_FLOAT -> l
    int FORMAT_FIXED -> m
    java.io.Writer mLog -> n
    boolean mLogArgumentNames -> o
    int mArgCount -> p
    com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo mColorPointer -> q
    com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo mNormalPointer -> r
    com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo mTexCoordPointer -> s
    com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo mVertexPointer -> t
    boolean mColorArrayEnabled -> a
    boolean mNormalArrayEnabled -> b
    boolean mTextureCoordArrayEnabled -> c
    boolean mVertexArrayEnabled -> d
    java.lang.StringBuilder mStringBuilder -> e
    void checkError() -> a
    void logLine(java.lang.String) -> a
    void log(java.lang.String) -> b
    void begin(java.lang.String) -> c
    void arg(java.lang.String,java.lang.String) -> a
    void end() -> b
    void flush() -> c
    void arg(java.lang.String,boolean) -> a
    void arg(java.lang.String,int) -> a
    void arg(java.lang.String,float) -> a
    void returns(java.lang.String) -> d
    void returns(int) -> g
    void arg(java.lang.String,int,int[],int) -> a
    void arg(java.lang.String,int,short[],int) -> a
    void arg(java.lang.String,int,float[],int) -> a
    void formattedAppend(java.lang.StringBuilder,int,int) -> a
    java.lang.String toString(int,int,int[],int) -> f
    java.lang.String toString(int,short[],int) -> a
    java.lang.String toString(int,float[],int) -> a
    java.lang.String toString(int,java.nio.FloatBuffer) -> a
    java.lang.String toString(int,int,java.nio.IntBuffer) -> f
    java.lang.String toString(int,java.nio.ShortBuffer) -> a
    void arg(java.lang.String,int,java.nio.FloatBuffer) -> a
    void arg(java.lang.String,int,java.nio.IntBuffer) -> a
    void arg(java.lang.String,int,java.nio.ShortBuffer) -> a
    void argPointer(int,int,int,java.nio.Buffer) -> a
    java.lang.String getHex(int) -> h
    java.lang.String getErrorString(int) -> a
    java.lang.String getClearBufferMask(int) -> i
    java.lang.String getFactor(int) -> j
    java.lang.String getShadeModel(int) -> k
    java.lang.String getTextureTarget(int) -> l
    java.lang.String getTextureEnvTarget(int) -> m
    java.lang.String getTextureEnvPName(int) -> n
    int getTextureEnvParamCount(int) -> o
    java.lang.String getTextureEnvParamName(float) -> a
    java.lang.String getMatrixMode(int) -> p
    java.lang.String getClientState(int) -> q
    java.lang.String getCap(int) -> r
    java.lang.String getTexturePName(int) -> s
    java.lang.String getTextureParamName(float) -> b
    java.lang.String getFogPName(int) -> t
    int getFogParamCount(int) -> u
    java.lang.String getBeginMode(int) -> v
    java.lang.String getIndexType(int) -> w
    java.lang.String getIntegerStateName(int) -> x
    int getIntegerStateSize(int) -> y
    int getIntegerStateFormat(int) -> z
    java.lang.String getHintTarget(int) -> A
    java.lang.String getHintMode(int) -> B
    java.lang.String getFaceName(int) -> C
    java.lang.String getMaterialPName(int) -> D
    int getMaterialParamCount(int) -> E
    java.lang.String getLightName(int) -> F
    java.lang.String getLightPName(int) -> G
    int getLightParamCount(int) -> H
    java.lang.String getLightModelPName(int) -> I
    int getLightModelParamCount(int) -> J
    java.lang.String getPointerTypeName(int) -> K
    java.nio.ByteBuffer toByteBuffer(int,java.nio.Buffer) -> a
    char[] toCharIndices(int,int,java.nio.Buffer) -> a
    void doArrayElement(java.lang.StringBuilder,boolean,java.lang.String,com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo,int) -> a
    void doElement(java.lang.StringBuilder,int,int) -> b
    void bindArrays() -> d
    void unbindArrays() -> e
    void startLogIndices() -> f
    void endLogIndices() -> g
    void glActiveTexture(int) -> glActiveTexture
    void glAlphaFunc(int,float) -> glAlphaFunc
    void glAlphaFuncx(int,int) -> glAlphaFuncx
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glClearColorx(int,int,int,int) -> glClearColorx
    void glClearDepthf(float) -> glClearDepthf
    void glClearDepthx(int) -> glClearDepthx
    void glClearStencil(int) -> glClearStencil
    void glClientActiveTexture(int) -> glClientActiveTexture
    void glColor4f(float,float,float,float) -> glColor4f
    void glColor4x(int,int,int,int) -> glColor4x
    void glColorMask(boolean,boolean,boolean,boolean) -> glColorMask
    void glColorPointer(int,int,int,java.nio.Buffer) -> glColorPointer
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glCompressedTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexSubImage2D
    void glCopyTexImage2D(int,int,int,int,int,int,int,int) -> glCopyTexImage2D
    void glCopyTexSubImage2D(int,int,int,int,int,int,int,int) -> glCopyTexSubImage2D
    void glCullFace(int) -> glCullFace
    void glDeleteTextures(int,int[],int) -> glDeleteTextures
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthFunc(int) -> glDepthFunc
    void glDepthMask(boolean) -> glDepthMask
    void glDepthRangef(float,float) -> glDepthRangef
    void glDepthRangex(int,int) -> glDepthRangex
    void glDisable(int) -> glDisable
    void glDisableClientState(int) -> glDisableClientState
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableClientState(int) -> glEnableClientState
    void glFinish() -> glFinish
    void glFlush() -> glFlush
    void glFogf(int,float) -> glFogf
    void glFogfv(int,float[],int) -> glFogfv
    void glFogfv(int,java.nio.FloatBuffer) -> glFogfv
    void glFogx(int,int) -> glFogx
    void glFogxv(int,int[],int) -> glFogxv
    void glFogxv(int,java.nio.IntBuffer) -> glFogxv
    void glFrontFace(int) -> glFrontFace
    void glFrustumf(float,float,float,float,float,float) -> glFrustumf
    void glFrustumx(int,int,int,int,int,int) -> glFrustumx
    void glGenTextures(int,int[],int) -> glGenTextures
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    int glGetError() -> glGetError
    void glGetIntegerv(int,int[],int) -> glGetIntegerv
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glHint(int,int) -> glHint
    void glLightModelf(int,float) -> glLightModelf
    void glLightModelfv(int,float[],int) -> glLightModelfv
    void glLightModelfv(int,java.nio.FloatBuffer) -> glLightModelfv
    void glLightModelx(int,int) -> glLightModelx
    void glLightModelxv(int,int[],int) -> glLightModelxv
    void glLightModelxv(int,java.nio.IntBuffer) -> glLightModelxv
    void glLightf(int,int,float) -> glLightf
    void glLightfv(int,int,float[],int) -> glLightfv
    void glLightfv(int,int,java.nio.FloatBuffer) -> glLightfv
    void glLightx(int,int,int) -> glLightx
    void glLightxv(int,int,int[],int) -> glLightxv
    void glLightxv(int,int,java.nio.IntBuffer) -> glLightxv
    void glLineWidth(float) -> glLineWidth
    void glLineWidthx(int) -> glLineWidthx
    void glLoadIdentity() -> glLoadIdentity
    void glLoadMatrixf(float[],int) -> glLoadMatrixf
    void glLoadMatrixf(java.nio.FloatBuffer) -> glLoadMatrixf
    void glLoadMatrixx(int[],int) -> glLoadMatrixx
    void glLoadMatrixx(java.nio.IntBuffer) -> glLoadMatrixx
    void glLogicOp(int) -> glLogicOp
    void glMaterialf(int,int,float) -> glMaterialf
    void glMaterialfv(int,int,float[],int) -> glMaterialfv
    void glMaterialfv(int,int,java.nio.FloatBuffer) -> glMaterialfv
    void glMaterialx(int,int,int) -> glMaterialx
    void glMaterialxv(int,int,int[],int) -> glMaterialxv
    void glMaterialxv(int,int,java.nio.IntBuffer) -> glMaterialxv
    void glMatrixMode(int) -> glMatrixMode
    void glMultMatrixf(float[],int) -> glMultMatrixf
    void glMultMatrixf(java.nio.FloatBuffer) -> glMultMatrixf
    void glMultMatrixx(int[],int) -> glMultMatrixx
    void glMultMatrixx(java.nio.IntBuffer) -> glMultMatrixx
    void glMultiTexCoord4f(int,float,float,float,float) -> glMultiTexCoord4f
    void glMultiTexCoord4x(int,int,int,int,int) -> glMultiTexCoord4x
    void glNormal3f(float,float,float) -> glNormal3f
    void glNormal3x(int,int,int) -> glNormal3x
    void glNormalPointer(int,int,java.nio.Buffer) -> glNormalPointer
    void glOrthof(float,float,float,float,float,float) -> glOrthof
    void glOrthox(int,int,int,int,int,int) -> glOrthox
    void glPixelStorei(int,int) -> glPixelStorei
    void glPointSize(float) -> glPointSize
    void glPointSizex(int) -> glPointSizex
    void glPolygonOffset(float,float) -> glPolygonOffset
    void glPolygonOffsetx(int,int) -> glPolygonOffsetx
    void glPopMatrix() -> glPopMatrix
    void glPushMatrix() -> glPushMatrix
    void glReadPixels(int,int,int,int,int,int,java.nio.Buffer) -> glReadPixels
    void glRotatef(float,float,float,float) -> glRotatef
    void glRotatex(int,int,int,int) -> glRotatex
    void glSampleCoverage(float,boolean) -> glSampleCoverage
    void glSampleCoveragex(int,boolean) -> glSampleCoveragex
    void glScalef(float,float,float) -> glScalef
    void glScalex(int,int,int) -> glScalex
    void glScissor(int,int,int,int) -> glScissor
    void glShadeModel(int) -> glShadeModel
    void glStencilFunc(int,int,int) -> glStencilFunc
    void glStencilMask(int) -> glStencilMask
    void glStencilOp(int,int,int) -> glStencilOp
    void glTexCoordPointer(int,int,int,java.nio.Buffer) -> glTexCoordPointer
    void glTexEnvf(int,int,float) -> glTexEnvf
    void glTexEnvfv(int,int,float[],int) -> glTexEnvfv
    void glTexEnvfv(int,int,java.nio.FloatBuffer) -> glTexEnvfv
    void glTexEnvx(int,int,int) -> glTexEnvx
    void glTexEnvxv(int,int,int[],int) -> glTexEnvxv
    void glTexEnvxv(int,int,java.nio.IntBuffer) -> glTexEnvxv
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glTexParameterx(int,int,int) -> glTexParameterx
    void glTexParameteriv(int,int,int[],int) -> glTexParameteriv
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> glTexParameteriv
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexSubImage2D
    void glTranslatef(float,float,float) -> glTranslatef
    void glTranslatex(int,int,int) -> glTranslatex
    void glVertexPointer(int,int,int,java.nio.Buffer) -> glVertexPointer
    void glViewport(int,int,int,int) -> glViewport
    void glClipPlanef(int,float[],int) -> glClipPlanef
    void glClipPlanef(int,java.nio.FloatBuffer) -> glClipPlanef
    void glClipPlanex(int,int[],int) -> glClipPlanex
    void glClipPlanex(int,java.nio.IntBuffer) -> glClipPlanex
    void glDrawTexfOES(float,float,float,float,float) -> glDrawTexfOES
    void glDrawTexfvOES(float[],int) -> glDrawTexfvOES
    void glDrawTexfvOES(java.nio.FloatBuffer) -> glDrawTexfvOES
    void glDrawTexiOES(int,int,int,int,int) -> glDrawTexiOES
    void glDrawTexivOES(int[],int) -> glDrawTexivOES
    void glDrawTexivOES(java.nio.IntBuffer) -> glDrawTexivOES
    void glDrawTexsOES(short,short,short,short,short) -> glDrawTexsOES
    void glDrawTexsvOES(short[],int) -> glDrawTexsvOES
    void glDrawTexsvOES(java.nio.ShortBuffer) -> glDrawTexsvOES
    void glDrawTexxOES(int,int,int,int,int) -> glDrawTexxOES
    void glDrawTexxvOES(int[],int) -> glDrawTexxvOES
    void glDrawTexxvOES(java.nio.IntBuffer) -> glDrawTexxvOES
    int glQueryMatrixxOES(int[],int,int[],int) -> glQueryMatrixxOES
    int glQueryMatrixxOES(java.nio.IntBuffer,java.nio.IntBuffer) -> glQueryMatrixxOES
    void glBindBuffer(int,int) -> glBindBuffer
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    void glColor4ub(byte,byte,byte,byte) -> glColor4ub
    void glDeleteBuffers(int,int[],int) -> glDeleteBuffers
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glGenBuffers(int,int[],int) -> glGenBuffers
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGetBooleanv(int,boolean[],int) -> glGetBooleanv
    void glGetBooleanv(int,java.nio.IntBuffer) -> glGetBooleanv
    void glGetBufferParameteriv(int,int,int[],int) -> glGetBufferParameteriv
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> glGetBufferParameteriv
    void glGetClipPlanef(int,float[],int) -> glGetClipPlanef
    void glGetClipPlanef(int,java.nio.FloatBuffer) -> glGetClipPlanef
    void glGetClipPlanex(int,int[],int) -> glGetClipPlanex
    void glGetClipPlanex(int,java.nio.IntBuffer) -> glGetClipPlanex
    void glGetFixedv(int,int[],int) -> glGetFixedv
    void glGetFixedv(int,java.nio.IntBuffer) -> glGetFixedv
    void glGetFloatv(int,float[],int) -> glGetFloatv
    void glGetFloatv(int,java.nio.FloatBuffer) -> glGetFloatv
    void glGetLightfv(int,int,float[],int) -> glGetLightfv
    void glGetLightfv(int,int,java.nio.FloatBuffer) -> glGetLightfv
    void glGetLightxv(int,int,int[],int) -> glGetLightxv
    void glGetLightxv(int,int,java.nio.IntBuffer) -> glGetLightxv
    void glGetMaterialfv(int,int,float[],int) -> glGetMaterialfv
    void glGetMaterialfv(int,int,java.nio.FloatBuffer) -> glGetMaterialfv
    void glGetMaterialxv(int,int,int[],int) -> glGetMaterialxv
    void glGetMaterialxv(int,int,java.nio.IntBuffer) -> glGetMaterialxv
    void glGetTexEnviv(int,int,int[],int) -> glGetTexEnviv
    void glGetTexEnviv(int,int,java.nio.IntBuffer) -> glGetTexEnviv
    void glGetTexEnvxv(int,int,int[],int) -> glGetTexEnvxv
    void glGetTexEnvxv(int,int,java.nio.IntBuffer) -> glGetTexEnvxv
    void glGetTexParameterfv(int,int,float[],int) -> glGetTexParameterfv
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> glGetTexParameterfv
    void glGetTexParameteriv(int,int,int[],int) -> glGetTexParameteriv
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> glGetTexParameteriv
    void glGetTexParameterxv(int,int,int[],int) -> glGetTexParameterxv
    void glGetTexParameterxv(int,int,java.nio.IntBuffer) -> glGetTexParameterxv
    boolean glIsBuffer(int) -> glIsBuffer
    boolean glIsEnabled(int) -> glIsEnabled
    boolean glIsTexture(int) -> glIsTexture
    void glPointParameterf(int,float) -> glPointParameterf
    void glPointParameterfv(int,float[],int) -> glPointParameterfv
    void glPointParameterfv(int,java.nio.FloatBuffer) -> glPointParameterfv
    void glPointParameterx(int,int) -> glPointParameterx
    void glPointParameterxv(int,int[],int) -> glPointParameterxv
    void glPointParameterxv(int,java.nio.IntBuffer) -> glPointParameterxv
    void glPointSizePointerOES(int,int,java.nio.Buffer) -> glPointSizePointerOES
    void glTexEnvi(int,int,int) -> glTexEnvi
    void glTexEnviv(int,int,int[],int) -> glTexEnviv
    void glTexEnviv(int,int,java.nio.IntBuffer) -> glTexEnviv
    void glTexParameterfv(int,int,float[],int) -> glTexParameterfv
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> glTexParameterfv
    void glTexParameteri(int,int,int) -> glTexParameteri
    void glTexParameterxv(int,int,int[],int) -> glTexParameterxv
    void glTexParameterxv(int,int,java.nio.IntBuffer) -> glTexParameterxv
com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper$PointerInfo -> com.badlogic.gdx.backends.android.a.aj:
    int mSize -> a
    int mType -> b
    int mStride -> c
    java.nio.Buffer mPointer -> d
    java.nio.ByteBuffer mTempByteBuffer -> e
    com.badlogic.gdx.backends.android.surfaceview.GLLogWrapper this$0 -> f
    int sizeof(int) -> a
    int getStride() -> a
    void bindByteBuffer() -> b
    void unbindByteBuffer() -> c
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> com.badlogic.gdx.backends.android.a.ak:
    java.lang.String TAG -> b
    boolean DEBUG -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> c
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> com.badlogic.gdx.backends.android.a.al:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> com.badlogic.gdx.backends.android.a.am:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void printConfigs(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> b
    void printConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> com.badlogic.gdx.backends.android.a.an:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> createContext
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> destroyContext
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20LW -> com.badlogic.gdx.backends.android.a.ao:
    java.lang.String TAG -> n
    boolean DEBUG -> p
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> o
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20LW$ConfigChooser -> com.badlogic.gdx.backends.android.a.ap:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void printConfigs(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> b
    void printConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20LW$ContextFactory -> com.badlogic.gdx.backends.android.a.aq:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake -> com.badlogic.gdx.backends.android.a.ar:
    int RENDERMODE_WHEN_DIRTY -> b
    int RENDERMODE_CONTINUOUSLY -> c
    int DEBUG_CHECK_GL_ERROR -> d
    int DEBUG_LOG_GL_CALLS -> e
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> f
    java.lang.Object sEglLock -> g
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$GLThread mGLThread -> a
    android.opengl.GLSurfaceView$EGLConfigChooser mEGLConfigChooser -> h
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$GLWrapper mGLWrapper -> i
    int mDebugFlags -> j
    int mRenderMode -> k
    android.opengl.GLSurfaceView$Renderer mRenderer -> l
    int mSurfaceWidth -> m
    int mSurfaceHeight -> n
    boolean mHasSurface -> o
    void onMeasure(int,int) -> onMeasure
    void init() -> d
    void setGLWrapper(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$GLWrapper) -> setGLWrapper
    void setDebugFlags(int) -> setDebugFlags
    int getDebugFlags() -> getDebugFlags
    void setRenderer(android.opengl.GLSurfaceView$Renderer) -> setRenderer
    void setEGLConfigChooser(android.opengl.GLSurfaceView$EGLConfigChooser) -> setEGLConfigChooser
    void setEGLConfigChooser(boolean) -> setEGLConfigChooser
    void setEGLConfigChooser(int,int,int,int,int,int) -> a
    void setRenderMode(int) -> setRenderMode
    int getRenderMode() -> getRenderMode
    void requestRender() -> a
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    void onPause() -> b
    void onResume() -> c
    void queueEvent(java.lang.Runnable) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$BaseConfigChooser -> com.badlogic.gdx.backends.android.a.as:
    int[] mConfigSpec -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$ComponentSizeChooser -> com.badlogic.gdx.backends.android.a.at:
    int[] mValue -> h
    int mRedSize -> b
    int mGreenSize -> c
    int mBlueSize -> d
    int mAlphaSize -> e
    int mDepthSize -> f
    int mStencilSize -> g
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$EglHelper -> com.badlogic.gdx.backends.android.a.au:
    javax.microedition.khronos.egl.EGL10 mEgl -> a
    javax.microedition.khronos.egl.EGLDisplay mEglDisplay -> b
    javax.microedition.khronos.egl.EGLSurface mEglSurface -> c
    javax.microedition.khronos.egl.EGLConfig mEglConfig -> d
    javax.microedition.khronos.egl.EGLContext mEglContext -> e
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake this$0 -> f
    void start() -> a
    javax.microedition.khronos.opengles.GL createSurface(android.view.SurfaceHolder) -> a
    boolean swap() -> b
    void finish() -> c
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$GLThread -> com.badlogic.gdx.backends.android.a.av:
    boolean mDone -> b
    boolean mPaused -> c
    boolean mHasSurface -> d
    int mWidth -> e
    int mHeight -> f
    int mRenderMode -> g
    boolean mRequestRender -> h
    android.opengl.GLSurfaceView$Renderer mRenderer -> i
    java.util.ArrayList mEventQueue -> j
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$EglHelper mEglHelper -> k
    boolean mSizeChanged -> l
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake this$0 -> a
    void run() -> run
    void guardedRun() -> h
    boolean needToWait() -> i
    void setRenderMode(int) -> a
    int getRenderMode() -> a
    void requestRender() -> b
    void surfaceCreated() -> c
    void surfaceDestroyed() -> d
    void onPause() -> e
    void onResume() -> f
    void onWindowResize(int,int) -> a
    void requestExitAndWait() -> g
    void queueEvent(java.lang.Runnable) -> a
    java.lang.Runnable getEvent() -> j
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$GLWrapper -> com.badlogic.gdx.backends.android.a.aw:
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$LogWriter -> com.badlogic.gdx.backends.android.a.ax:
    java.lang.StringBuilder mBuilder -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake$SimpleEGLConfigChooser -> com.badlogic.gdx.backends.android.a.ay:
com.badlogic.gdx.backends.android.surfaceview.GLWrapperBase -> com.badlogic.gdx.backends.android.a.az:
    javax.microedition.khronos.opengles.GL10 mgl -> f
    javax.microedition.khronos.opengles.GL10Ext mgl10Ext -> g
    javax.microedition.khronos.opengles.GL11 mgl11 -> h
    javax.microedition.khronos.opengles.GL11Ext mgl11Ext -> i
    javax.microedition.khronos.opengles.GL11ExtensionPack mgl11ExtensionPack -> j
    void glGetPointerv(int,java.nio.Buffer[]) -> glGetPointerv
    void glColorPointer(int,int,int,int) -> glColorPointer
    void glNormalPointer(int,int,int) -> glNormalPointer
    void glTexCoordPointer(int,int,int,int) -> glTexCoordPointer
    void glVertexPointer(int,int,int,int) -> glVertexPointer
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glBindBuffer(int,int) -> glBindBuffer
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    void glColor4ub(byte,byte,byte,byte) -> glColor4ub
    void glDeleteBuffers(int,int[],int) -> glDeleteBuffers
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glGenBuffers(int,int[],int) -> glGenBuffers
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGetBooleanv(int,boolean[],int) -> glGetBooleanv
    void glGetBooleanv(int,java.nio.IntBuffer) -> glGetBooleanv
    void glGetBufferParameteriv(int,int,int[],int) -> glGetBufferParameteriv
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> glGetBufferParameteriv
    void glGetClipPlanef(int,float[],int) -> glGetClipPlanef
    void glGetClipPlanef(int,java.nio.FloatBuffer) -> glGetClipPlanef
    void glGetClipPlanex(int,int[],int) -> glGetClipPlanex
    void glGetClipPlanex(int,java.nio.IntBuffer) -> glGetClipPlanex
    void glGetFixedv(int,int[],int) -> glGetFixedv
    void glGetFixedv(int,java.nio.IntBuffer) -> glGetFixedv
    void glGetFloatv(int,float[],int) -> glGetFloatv
    void glGetFloatv(int,java.nio.FloatBuffer) -> glGetFloatv
    void glGetLightfv(int,int,float[],int) -> glGetLightfv
    void glGetLightfv(int,int,java.nio.FloatBuffer) -> glGetLightfv
    void glGetLightxv(int,int,int[],int) -> glGetLightxv
    void glGetLightxv(int,int,java.nio.IntBuffer) -> glGetLightxv
    void glGetMaterialfv(int,int,float[],int) -> glGetMaterialfv
    void glGetMaterialfv(int,int,java.nio.FloatBuffer) -> glGetMaterialfv
    void glGetMaterialxv(int,int,int[],int) -> glGetMaterialxv
    void glGetMaterialxv(int,int,java.nio.IntBuffer) -> glGetMaterialxv
    void glGetTexEnviv(int,int,int[],int) -> glGetTexEnviv
    void glGetTexEnviv(int,int,java.nio.IntBuffer) -> glGetTexEnviv
    void glGetTexEnvxv(int,int,int[],int) -> glGetTexEnvxv
    void glGetTexEnvxv(int,int,java.nio.IntBuffer) -> glGetTexEnvxv
    void glGetTexParameterfv(int,int,float[],int) -> glGetTexParameterfv
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> glGetTexParameterfv
    void glGetTexParameteriv(int,int,int[],int) -> glGetTexParameteriv
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> glGetTexParameteriv
    void glGetTexParameterxv(int,int,int[],int) -> glGetTexParameterxv
    void glGetTexParameterxv(int,int,java.nio.IntBuffer) -> glGetTexParameterxv
    boolean glIsBuffer(int) -> glIsBuffer
    boolean glIsEnabled(int) -> glIsEnabled
    boolean glIsTexture(int) -> glIsTexture
    void glPointParameterf(int,float) -> glPointParameterf
    void glPointParameterfv(int,float[],int) -> glPointParameterfv
    void glPointParameterfv(int,java.nio.FloatBuffer) -> glPointParameterfv
    void glPointParameterx(int,int) -> glPointParameterx
    void glPointParameterxv(int,int[],int) -> glPointParameterxv
    void glPointParameterxv(int,java.nio.IntBuffer) -> glPointParameterxv
    void glPointSizePointerOES(int,int,java.nio.Buffer) -> glPointSizePointerOES
    void glTexEnvi(int,int,int) -> glTexEnvi
    void glTexEnviv(int,int,int[],int) -> glTexEnviv
    void glTexEnviv(int,int,java.nio.IntBuffer) -> glTexEnviv
    void glTexParameterfv(int,int,float[],int) -> glTexParameterfv
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> glTexParameterfv
    void glTexParameteri(int,int,int) -> glTexParameteri
    void glTexParameterxv(int,int,int[],int) -> glTexParameterxv
    void glTexParameterxv(int,int,java.nio.IntBuffer) -> glTexParameterxv
    void glCurrentPaletteMatrixOES(int) -> glCurrentPaletteMatrixOES
    void glLoadPaletteFromModelViewMatrixOES() -> glLoadPaletteFromModelViewMatrixOES
    void glMatrixIndexPointerOES(int,int,int,java.nio.Buffer) -> glMatrixIndexPointerOES
    void glMatrixIndexPointerOES(int,int,int,int) -> glMatrixIndexPointerOES
    void glWeightPointerOES(int,int,int,java.nio.Buffer) -> glWeightPointerOES
    void glWeightPointerOES(int,int,int,int) -> glWeightPointerOES
    void glBindFramebufferOES(int,int) -> a
    void glBindRenderbufferOES(int,int) -> b
    void glBlendEquation(int) -> b
    void glBlendEquationSeparate(int,int) -> c
    void glBlendFuncSeparate(int,int,int,int) -> a
    int glCheckFramebufferStatusOES(int) -> c
    void glCompressedTexImage2D(int,int,int,int,int,int,int) -> a
    void glDeleteFramebuffersOES(int,int[],int) -> a
    void glDeleteFramebuffersOES(int,java.nio.IntBuffer) -> a
    void glDeleteRenderbuffersOES(int,int[],int) -> b
    void glDeleteRenderbuffersOES(int,java.nio.IntBuffer) -> b
    void glFramebufferRenderbufferOES(int,int,int,int) -> b
    void glFramebufferTexture2DOES(int,int,int,int,int) -> a
    void glGenerateMipmapOES(int) -> d
    void glGenFramebuffersOES(int,int[],int) -> c
    void glGenFramebuffersOES(int,java.nio.IntBuffer) -> c
    void glGenRenderbuffersOES(int,int[],int) -> d
    void glGenRenderbuffersOES(int,java.nio.IntBuffer) -> d
    void glGetFramebufferAttachmentParameterivOES(int,int,int,int[],int) -> a
    void glGetFramebufferAttachmentParameterivOES(int,int,int,java.nio.IntBuffer) -> a
    void glGetRenderbufferParameterivOES(int,int,int[],int) -> a
    void glGetRenderbufferParameterivOES(int,int,java.nio.IntBuffer) -> a
    void glGetTexGenfv(int,int,float[],int) -> a
    void glGetTexGenfv(int,int,java.nio.FloatBuffer) -> a
    void glGetTexGeniv(int,int,int[],int) -> b
    void glGetTexGeniv(int,int,java.nio.IntBuffer) -> b
    void glGetTexGenxv(int,int,int[],int) -> c
    void glGetTexGenxv(int,int,java.nio.IntBuffer) -> c
    boolean glIsFramebufferOES(int) -> e
    boolean glIsRenderbufferOES(int) -> f
    void glRenderbufferStorageOES(int,int,int,int) -> c
    void glTexGenf(int,int,float) -> a
    void glTexGenfv(int,int,float[],int) -> b
    void glTexGenfv(int,int,java.nio.FloatBuffer) -> b
    void glTexGeni(int,int,int) -> a
    void glTexGeniv(int,int,int[],int) -> d
    void glTexGeniv(int,int,java.nio.IntBuffer) -> d
    void glTexGenx(int,int,int) -> b
    void glTexGenxv(int,int,int[],int) -> e
    void glTexGenxv(int,int,java.nio.IntBuffer) -> e
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> com.badlogic.gdx.backends.android.a.ba:
    int EGL_OPENGL_ES2_BIT -> l
    int EGL_COVERAGE_BUFFERS_NV -> a
    int EGL_COVERAGE_SAMPLES_NV -> b
    java.lang.String TAG -> m
    int mRedSize -> c
    int mGreenSize -> d
    int mBlueSize -> e
    int mAlphaSize -> f
    int mDepthSize -> g
    int mStencilSize -> h
    int mNumSamples -> i
    boolean mUseGL20 -> j
    int[] mConfigAttribs -> k
    int[] mValue -> n
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void printConfigs(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> b
    void printConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
com.badlogic.gdx.backends.android.surfaceview.RatioResolutionStrategy -> com.badlogic.gdx.backends.android.a.bb:
    float ratio -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> com.badlogic.gdx.backends.android.a.bc:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> com.badlogic.gdx.backends.android.a.bd:
    int width -> a
    int height -> b
com.badlogic.gdx.files.FileHandle -> com.badlogic.gdx.d.a:
    java.io.File file -> b
    com.badlogic.gdx.Files$FileType type -> c
    java.lang.String path() -> h
    java.lang.String name() -> i
    java.lang.String extension() -> j
    java.lang.String nameWithoutExtension() -> k
    java.lang.String pathWithoutExtension() -> l
    com.badlogic.gdx.Files$FileType type() -> m
    java.io.File file() -> n
    java.io.InputStream read() -> b
    java.io.BufferedInputStream read(int) -> a
    java.io.Reader reader() -> o
    java.io.Reader reader(java.lang.String) -> d
    java.io.BufferedReader reader(int) -> b
    java.io.BufferedReader reader(int,java.lang.String) -> a
    java.lang.String readString() -> p
    java.lang.String readString(java.lang.String) -> e
    byte[] readBytes() -> q
    int readBytes(byte[],int,int) -> a
    java.io.OutputStream write(boolean) -> a
    void write(java.io.InputStream,boolean) -> a
    java.io.Writer writer(boolean) -> b
    java.io.Writer writer(boolean,java.lang.String) -> a
    void writeString(java.lang.String,boolean) -> a
    void writeString(java.lang.String,boolean,java.lang.String) -> a
    void writeBytes(byte[],boolean) -> a
    void writeBytes(byte[],int,int,boolean) -> a
    com.badlogic.gdx.files.FileHandle[] list() -> c
    com.badlogic.gdx.files.FileHandle[] list(java.lang.String) -> c
    boolean isDirectory() -> d
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    void mkdirs() -> r
    boolean exists() -> e
    boolean delete() -> s
    boolean deleteDirectory() -> t
    void emptyDirectory() -> u
    void emptyDirectory(boolean) -> c
    void copyTo(com.badlogic.gdx.files.FileHandle) -> a
    void moveTo(com.badlogic.gdx.files.FileHandle) -> b
    long length() -> f
    long lastModified() -> g
    java.lang.String toString() -> toString
    com.badlogic.gdx.files.FileHandle tempFile(java.lang.String) -> f
    com.badlogic.gdx.files.FileHandle tempDirectory(java.lang.String) -> g
    void emptyDirectory(java.io.File,boolean) -> a
    boolean deleteDirectory(java.io.File) -> a
    void copyFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> a
    void copyDirectory(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.files.FileHandle$1 -> com.badlogic.gdx.d.b:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.files.FileHandleStream -> com.badlogic.gdx.d.c:
    boolean isDirectory() -> d
    long length() -> f
    boolean exists() -> e
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    java.io.InputStream read() -> b
    java.io.OutputStream write(boolean) -> a
    com.badlogic.gdx.files.FileHandle[] list() -> c
    void mkdirs() -> r
    boolean delete() -> s
    boolean deleteDirectory() -> t
    void copyTo(com.badlogic.gdx.files.FileHandle) -> a
    void moveTo(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.files.package-info -> com.badlogic.gdx.d.d:
com.badlogic.gdx.graphics.Camera -> com.badlogic.gdx.graphics.a:
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    float near -> h
    float far -> i
    float viewportWidth -> j
    float viewportHeight -> k
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 tmpVec -> o
    com.badlogic.gdx.math.Vector3 right -> m
    com.badlogic.gdx.math.collision.Ray ray -> n
    void update() -> a
    void update(boolean) -> a
    void apply(com.badlogic.gdx.graphics.GL10) -> a
    void lookAt(float,float,float) -> a
    void lookAt(com.badlogic.gdx.math.Vector3) -> a
    void normalizeUp() -> b
    void rotate(float,float,float,float) -> a
    void rotate(com.badlogic.gdx.math.Vector3,float) -> a
    void rotate(com.badlogic.gdx.math.Matrix4) -> a
    void rotate(com.badlogic.gdx.math.Quaternion) -> a
    void rotateAround(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,float) -> a
    void transform(com.badlogic.gdx.math.Matrix4) -> b
    void translate(float,float,float) -> b
    void translate(com.badlogic.gdx.math.Vector3) -> b
    void unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    void unproject(com.badlogic.gdx.math.Vector3) -> c
    void project(com.badlogic.gdx.math.Vector3) -> d
    void project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
    com.badlogic.gdx.math.collision.Ray getPickRay(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.collision.Ray getPickRay(float,float) -> a
com.badlogic.gdx.graphics.Color -> com.badlogic.gdx.graphics.b:
    com.badlogic.gdx.graphics.Color CLEAR -> a
    com.badlogic.gdx.graphics.Color WHITE -> b
    com.badlogic.gdx.graphics.Color BLACK -> c
    com.badlogic.gdx.graphics.Color RED -> d
    com.badlogic.gdx.graphics.Color GREEN -> e
    com.badlogic.gdx.graphics.Color BLUE -> f
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> g
    com.badlogic.gdx.graphics.Color GRAY -> h
    com.badlogic.gdx.graphics.Color DARK_GRAY -> i
    com.badlogic.gdx.graphics.Color PINK -> j
    com.badlogic.gdx.graphics.Color ORANGE -> k
    com.badlogic.gdx.graphics.Color YELLOW -> l
    com.badlogic.gdx.graphics.Color MAGENTA -> m
    com.badlogic.gdx.graphics.Color CYAN -> n
    com.badlogic.gdx.graphics.Color tmp -> o
    float r -> p
    float g -> q
    float b -> r
    float a -> s
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> b
    com.badlogic.gdx.graphics.Color mul(float) -> a
    com.badlogic.gdx.graphics.Color add(com.badlogic.gdx.graphics.Color) -> c
    com.badlogic.gdx.graphics.Color sub(com.badlogic.gdx.graphics.Color) -> d
    com.badlogic.gdx.graphics.Color clamp() -> a
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color add(float,float,float,float) -> b
    com.badlogic.gdx.graphics.Color sub(float,float,float,float) -> c
    com.badlogic.gdx.graphics.Color mul(float,float,float,float) -> d
    com.badlogic.gdx.graphics.Color lerp(com.badlogic.gdx.graphics.Color,float) -> a
    com.badlogic.gdx.graphics.Color lerp(float,float,float,float,float) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    float toFloatBits() -> b
    int toIntBits() -> c
    java.lang.String toString() -> toString
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> a
    float toFloatBits(int,int,int,int) -> a
    float toFloatBits(float,float,float,float) -> e
    int toIntBits(int,int,int,int) -> b
    int alpha(float) -> b
    int luminanceAlpha(float,float) -> a
    int rgb565(float,float,float) -> a
    int rgba4444(float,float,float,float) -> f
    int rgb888(float,float,float) -> b
    int rgba8888(float,float,float,float) -> g
    int rgb565(com.badlogic.gdx.graphics.Color) -> e
    int rgba4444(com.badlogic.gdx.graphics.Color) -> f
    int rgb888(com.badlogic.gdx.graphics.Color) -> g
    int rgba8888(com.badlogic.gdx.graphics.Color) -> h
    void rgb565ToColor(com.badlogic.gdx.graphics.Color,int) -> a
    void rgba4444ToColor(com.badlogic.gdx.graphics.Color,int) -> b
    void rgb888ToColor(com.badlogic.gdx.graphics.Color,int) -> c
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> d
    com.badlogic.gdx.graphics.Color tmp() -> d
    com.badlogic.gdx.graphics.Color cpy() -> e
com.badlogic.gdx.graphics.FPSLogger -> com.badlogic.gdx.graphics.c:
    long startTime -> a
    void log() -> a
com.badlogic.gdx.graphics.GL10 -> com.badlogic.gdx.graphics.d:
    int GL_OES_VERSION_1_0 -> b
    int GL_OES_read_format -> c
    int GL_OES_compressed_paletted_texture -> d
    int GL_DEPTH_BUFFER_BIT -> e
    int GL_STENCIL_BUFFER_BIT -> f
    int GL_COLOR_BUFFER_BIT -> g
    int GL_FALSE -> h
    int GL_TRUE -> i
    int GL_POINTS -> j
    int GL_LINES -> k
    int GL_LINE_LOOP -> l
    int GL_LINE_STRIP -> m
    int GL_TRIANGLES -> n
    int GL_TRIANGLE_STRIP -> o
    int GL_TRIANGLE_FAN -> p
    int GL_NEVER -> q
    int GL_LESS -> r
    int GL_EQUAL -> s
    int GL_LEQUAL -> t
    int GL_GREATER -> u
    int GL_NOTEQUAL -> v
    int GL_GEQUAL -> w
    int GL_ALWAYS -> x
    int GL_ZERO -> y
    int GL_ONE -> z
    int GL_SRC_COLOR -> A
    int GL_ONE_MINUS_SRC_COLOR -> B
    int GL_SRC_ALPHA -> C
    int GL_ONE_MINUS_SRC_ALPHA -> D
    int GL_DST_ALPHA -> E
    int GL_ONE_MINUS_DST_ALPHA -> F
    int GL_DST_COLOR -> G
    int GL_ONE_MINUS_DST_COLOR -> H
    int GL_SRC_ALPHA_SATURATE -> I
    int GL_FRONT -> J
    int GL_BACK -> K
    int GL_FRONT_AND_BACK -> L
    int GL_FOG -> M
    int GL_LIGHTING -> N
    int GL_TEXTURE_2D -> O
    int GL_CULL_FACE -> P
    int GL_ALPHA_TEST -> Q
    int GL_BLEND -> R
    int GL_COLOR_LOGIC_OP -> S
    int GL_DITHER -> T
    int GL_STENCIL_TEST -> U
    int GL_DEPTH_TEST -> V
    int GL_POINT_SMOOTH -> W
    int GL_LINE_SMOOTH -> X
    int GL_SCISSOR_TEST -> Y
    int GL_COLOR_MATERIAL -> Z
    int GL_NORMALIZE -> aa
    int GL_RESCALE_NORMAL -> ab
    int GL_POLYGON_OFFSET_FILL -> ac
    int GL_VERTEX_ARRAY -> ad
    int GL_NORMAL_ARRAY -> ae
    int GL_COLOR_ARRAY -> af
    int GL_TEXTURE_COORD_ARRAY -> ag
    int GL_MULTISAMPLE -> ah
    int GL_SAMPLE_ALPHA_TO_COVERAGE -> ai
    int GL_SAMPLE_ALPHA_TO_ONE -> aj
    int GL_SAMPLE_COVERAGE -> ak
    int GL_NO_ERROR -> al
    int GL_INVALID_ENUM -> am
    int GL_INVALID_VALUE -> an
    int GL_INVALID_OPERATION -> ao
    int GL_STACK_OVERFLOW -> ap
    int GL_STACK_UNDERFLOW -> aq
    int GL_OUT_OF_MEMORY -> ar
    int GL_EXP -> as
    int GL_EXP2 -> at
    int GL_FOG_DENSITY -> au
    int GL_FOG_START -> av
    int GL_FOG_END -> aw
    int GL_FOG_MODE -> ax
    int GL_FOG_COLOR -> ay
    int GL_CW -> az
    int GL_CCW -> aA
    int GL_SMOOTH_POINT_SIZE_RANGE -> aB
    int GL_SMOOTH_LINE_WIDTH_RANGE -> aC
    int GL_ALIASED_POINT_SIZE_RANGE -> aD
    int GL_ALIASED_LINE_WIDTH_RANGE -> aE
    int GL_IMPLEMENTATION_COLOR_READ_TYPE_OES -> aF
    int GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES -> aG
    int GL_MAX_LIGHTS -> aH
    int GL_MAX_TEXTURE_SIZE -> aI
    int GL_MAX_MODELVIEW_STACK_DEPTH -> aJ
    int GL_MAX_PROJECTION_STACK_DEPTH -> aK
    int GL_MAX_TEXTURE_STACK_DEPTH -> aL
    int GL_MAX_VIEWPORT_DIMS -> aM
    int GL_MAX_ELEMENTS_VERTICES -> aN
    int GL_MAX_ELEMENTS_INDICES -> aO
    int GL_MAX_TEXTURE_UNITS -> aP
    int GL_NUM_COMPRESSED_TEXTURE_FORMATS -> aQ
    int GL_COMPRESSED_TEXTURE_FORMATS -> aR
    int GL_SUBPIXEL_BITS -> aS
    int GL_RED_BITS -> aT
    int GL_GREEN_BITS -> aU
    int GL_BLUE_BITS -> aV
    int GL_ALPHA_BITS -> aW
    int GL_DEPTH_BITS -> aX
    int GL_STENCIL_BITS -> aY
    int GL_DONT_CARE -> aZ
    int GL_FASTEST -> ba
    int GL_NICEST -> bb
    int GL_PERSPECTIVE_CORRECTION_HINT -> bc
    int GL_POINT_SMOOTH_HINT -> bd
    int GL_LINE_SMOOTH_HINT -> be
    int GL_POLYGON_SMOOTH_HINT -> bf
    int GL_FOG_HINT -> bg
    int GL_LIGHT_MODEL_AMBIENT -> bh
    int GL_LIGHT_MODEL_TWO_SIDE -> bi
    int GL_AMBIENT -> bj
    int GL_DIFFUSE -> bk
    int GL_SPECULAR -> bl
    int GL_POSITION -> bm
    int GL_SPOT_DIRECTION -> bn
    int GL_SPOT_EXPONENT -> bo
    int GL_SPOT_CUTOFF -> bp
    int GL_CONSTANT_ATTENUATION -> bq
    int GL_LINEAR_ATTENUATION -> br
    int GL_QUADRATIC_ATTENUATION -> bs
    int GL_BYTE -> bt
    int GL_UNSIGNED_BYTE -> bu
    int GL_SHORT -> bv
    int GL_UNSIGNED_SHORT -> bw
    int GL_FLOAT -> bx
    int GL_CLEAR -> by
    int GL_AND -> bz
    int GL_AND_REVERSE -> bA
    int GL_COPY -> bB
    int GL_AND_INVERTED -> bC
    int GL_NOOP -> bD
    int GL_XOR -> bE
    int GL_OR -> bF
    int GL_NOR -> bG
    int GL_EQUIV -> bH
    int GL_INVERT -> bI
    int GL_OR_REVERSE -> bJ
    int GL_COPY_INVERTED -> bK
    int GL_OR_INVERTED -> bL
    int GL_NAND -> bM
    int GL_SET -> bN
    int GL_EMISSION -> bO
    int GL_SHININESS -> bP
    int GL_AMBIENT_AND_DIFFUSE -> bQ
    int GL_MODELVIEW -> bR
    int GL_PROJECTION -> bS
    int GL_TEXTURE -> bT
    int GL_ALPHA -> bU
    int GL_RGB -> bV
    int GL_RGBA -> bW
    int GL_LUMINANCE -> bX
    int GL_LUMINANCE_ALPHA -> bY
    int GL_UNPACK_ALIGNMENT -> bZ
    int GL_PACK_ALIGNMENT -> ca
    int GL_UNSIGNED_SHORT_4_4_4_4 -> cb
    int GL_UNSIGNED_SHORT_5_5_5_1 -> cc
    int GL_UNSIGNED_SHORT_5_6_5 -> cd
    int GL_FLAT -> ce
    int GL_SMOOTH -> cf
    int GL_KEEP -> cg
    int GL_REPLACE -> ch
    int GL_INCR -> ci
    int GL_DECR -> cj
    int GL_VENDOR -> ck
    int GL_RENDERER -> cl
    int GL_VERSION -> cm
    int GL_EXTENSIONS -> cn
    int GL_MODULATE -> co
    int GL_DECAL -> cp
    int GL_ADD -> cq
    int GL_TEXTURE_ENV_MODE -> cr
    int GL_TEXTURE_ENV_COLOR -> cs
    int GL_TEXTURE_ENV -> ct
    int GL_NEAREST -> cu
    int GL_LINEAR -> cv
    int GL_NEAREST_MIPMAP_NEAREST -> cw
    int GL_LINEAR_MIPMAP_NEAREST -> cx
    int GL_NEAREST_MIPMAP_LINEAR -> cy
    int GL_LINEAR_MIPMAP_LINEAR -> cz
    int GL_TEXTURE_MAG_FILTER -> cA
    int GL_TEXTURE_MIN_FILTER -> cB
    int GL_TEXTURE_WRAP_S -> cC
    int GL_TEXTURE_WRAP_T -> cD
    int GL_TEXTURE0 -> cE
    int GL_TEXTURE1 -> cF
    int GL_TEXTURE2 -> cG
    int GL_TEXTURE3 -> cH
    int GL_TEXTURE4 -> cI
    int GL_TEXTURE5 -> cJ
    int GL_TEXTURE6 -> cK
    int GL_TEXTURE7 -> cL
    int GL_TEXTURE8 -> cM
    int GL_TEXTURE9 -> cN
    int GL_TEXTURE10 -> cO
    int GL_TEXTURE11 -> cP
    int GL_TEXTURE12 -> cQ
    int GL_TEXTURE13 -> cR
    int GL_TEXTURE14 -> cS
    int GL_TEXTURE15 -> cT
    int GL_TEXTURE16 -> cU
    int GL_TEXTURE17 -> cV
    int GL_TEXTURE18 -> cW
    int GL_TEXTURE19 -> cX
    int GL_TEXTURE20 -> cY
    int GL_TEXTURE21 -> cZ
    int GL_TEXTURE22 -> da
    int GL_TEXTURE23 -> db
    int GL_TEXTURE24 -> dc
    int GL_TEXTURE25 -> dd
    int GL_TEXTURE26 -> de
    int GL_TEXTURE27 -> df
    int GL_TEXTURE28 -> dg
    int GL_TEXTURE29 -> dh
    int GL_TEXTURE30 -> di
    int GL_TEXTURE31 -> dj
    int GL_REPEAT -> dk
    int GL_CLAMP_TO_EDGE -> dl
    int GL_PALETTE4_RGB8_OES -> dm
    int GL_PALETTE4_RGBA8_OES -> dn
    int GL_PALETTE4_R5_G6_B5_OES -> do
    int GL_PALETTE4_RGBA4_OES -> dp
    int GL_PALETTE4_RGB5_A1_OES -> dq
    int GL_PALETTE8_RGB8_OES -> dr
    int GL_PALETTE8_RGBA8_OES -> ds
    int GL_PALETTE8_R5_G6_B5_OES -> dt
    int GL_PALETTE8_RGBA4_OES -> du
    int GL_PALETTE8_RGB5_A1_OES -> dv
    int GL_LIGHT0 -> dw
    int GL_LIGHT1 -> dx
    int GL_LIGHT2 -> dy
    int GL_LIGHT3 -> dz
    int GL_LIGHT4 -> dA
    int GL_LIGHT5 -> dB
    int GL_LIGHT6 -> dC
    int GL_LIGHT7 -> dD
    int GL_POINT -> dE
    int GL_LINE -> dF
    int GL_FILL -> dG
    void glAlphaFunc(int,float) -> a
    void glClientActiveTexture(int) -> a
    void glColor4f(float,float,float,float) -> a
    void glColorPointer(int,int,int,java.nio.Buffer) -> a
    void glDeleteTextures(int,int[],int) -> a
    void glDisableClientState(int) -> b
    void glEnableClientState(int) -> c
    void glFogf(int,float) -> b
    void glFogfv(int,float[],int) -> a
    void glFogfv(int,java.nio.FloatBuffer) -> a
    void glFrustumf(float,float,float,float,float,float) -> a
    void glGenTextures(int,int[],int) -> b
    void glGetIntegerv(int,int[],int) -> c
    void glLightModelf(int,float) -> c
    void glLightModelfv(int,float[],int) -> b
    void glLightModelfv(int,java.nio.FloatBuffer) -> b
    void glLightf(int,int,float) -> a
    void glLightfv(int,int,float[],int) -> a
    void glLightfv(int,int,java.nio.FloatBuffer) -> a
    void glLoadIdentity() -> a
    void glLoadMatrixf(float[],int) -> a
    void glLoadMatrixf(java.nio.FloatBuffer) -> a
    void glLogicOp(int) -> d
    void glMaterialf(int,int,float) -> b
    void glMaterialfv(int,int,float[],int) -> b
    void glMaterialfv(int,int,java.nio.FloatBuffer) -> b
    void glMatrixMode(int) -> e
    void glMultMatrixf(float[],int) -> b
    void glMultMatrixf(java.nio.FloatBuffer) -> b
    void glMultiTexCoord4f(int,float,float,float,float) -> a
    void glNormal3f(float,float,float) -> a
    void glNormalPointer(int,int,java.nio.Buffer) -> a
    void glOrthof(float,float,float,float,float,float) -> b
    void glPointSize(float) -> a
    void glPopMatrix() -> b
    void glPushMatrix() -> c
    void glRotatef(float,float,float,float) -> b
    void glSampleCoverage(float,boolean) -> a
    void glScalef(float,float,float) -> b
    void glShadeModel(int) -> f
    void glTexCoordPointer(int,int,int,java.nio.Buffer) -> b
    void glTexEnvf(int,int,float) -> c
    void glTexEnvfv(int,int,float[],int) -> c
    void glTexEnvfv(int,int,java.nio.FloatBuffer) -> c
    void glTranslatef(float,float,float) -> c
    void glVertexPointer(int,int,int,java.nio.Buffer) -> c
    void glPolygonMode(int,int) -> a
com.badlogic.gdx.graphics.GL11 -> com.badlogic.gdx.graphics.e:
    int GL_OES_VERSION_1_0 -> a
    int GL_MAX_ELEMENTS_VERTICES -> dH
    int GL_MAX_ELEMENTS_INDICES -> dI
    int GL_POLYGON_SMOOTH_HINT -> dJ
    int GL_VERSION_ES_CM_1_0 -> dK
    int GL_VERSION_ES_CL_1_0 -> dL
    int GL_VERSION_ES_CM_1_1 -> dM
    int GL_VERSION_ES_CL_1_1 -> dN
    int GL_CLIP_PLANE0 -> dO
    int GL_CLIP_PLANE1 -> dP
    int GL_CLIP_PLANE2 -> dQ
    int GL_CLIP_PLANE3 -> dR
    int GL_CLIP_PLANE4 -> dS
    int GL_CLIP_PLANE5 -> dT
    int GL_CURRENT_COLOR -> dU
    int GL_CURRENT_NORMAL -> dV
    int GL_CURRENT_TEXTURE_COORDS -> dW
    int GL_POINT_SIZE -> dX
    int GL_POINT_SIZE_MIN -> dY
    int GL_POINT_SIZE_MAX -> dZ
    int GL_POINT_FADE_THRESHOLD_SIZE -> ea
    int GL_POINT_DISTANCE_ATTENUATION -> eb
    int GL_LINE_WIDTH -> ec
    int GL_CULL_FACE_MODE -> ed
    int GL_FRONT_FACE -> ee
    int GL_SHADE_MODEL -> ef
    int GL_DEPTH_RANGE -> eg
    int GL_DEPTH_WRITEMASK -> eh
    int GL_DEPTH_CLEAR_VALUE -> ei
    int GL_DEPTH_FUNC -> ej
    int GL_STENCIL_CLEAR_VALUE -> ek
    int GL_STENCIL_FUNC -> el
    int GL_STENCIL_VALUE_MASK -> em
    int GL_STENCIL_FAIL -> en
    int GL_STENCIL_PASS_DEPTH_FAIL -> eo
    int GL_STENCIL_PASS_DEPTH_PASS -> ep
    int GL_STENCIL_REF -> eq
    int GL_STENCIL_WRITEMASK -> er
    int GL_MATRIX_MODE -> es
    int GL_VIEWPORT -> et
    int GL_MODELVIEW_STACK_DEPTH -> eu
    int GL_PROJECTION_STACK_DEPTH -> ev
    int GL_TEXTURE_STACK_DEPTH -> ew
    int GL_MODELVIEW_MATRIX -> ex
    int GL_PROJECTION_MATRIX -> ey
    int GL_TEXTURE_MATRIX -> ez
    int GL_ALPHA_TEST_FUNC -> eA
    int GL_ALPHA_TEST_REF -> eB
    int GL_BLEND_DST -> eC
    int GL_BLEND_SRC -> eD
    int GL_LOGIC_OP_MODE -> eE
    int GL_SCISSOR_BOX -> eF
    int GL_COLOR_CLEAR_VALUE -> eG
    int GL_COLOR_WRITEMASK -> eH
    int GL_MAX_CLIP_PLANES -> eI
    int GL_POLYGON_OFFSET_UNITS -> eJ
    int GL_POLYGON_OFFSET_FACTOR -> eK
    int GL_TEXTURE_BINDING_2D -> eL
    int GL_VERTEX_ARRAY_SIZE -> eM
    int GL_VERTEX_ARRAY_TYPE -> eN
    int GL_VERTEX_ARRAY_STRIDE -> eO
    int GL_NORMAL_ARRAY_TYPE -> eP
    int GL_NORMAL_ARRAY_STRIDE -> eQ
    int GL_COLOR_ARRAY_SIZE -> eR
    int GL_COLOR_ARRAY_TYPE -> eS
    int GL_COLOR_ARRAY_STRIDE -> eT
    int GL_TEXTURE_COORD_ARRAY_SIZE -> eU
    int GL_TEXTURE_COORD_ARRAY_TYPE -> eV
    int GL_TEXTURE_COORD_ARRAY_STRIDE -> eW
    int GL_VERTEX_ARRAY_POINTER -> eX
    int GL_NORMAL_ARRAY_POINTER -> eY
    int GL_COLOR_ARRAY_POINTER -> eZ
    int GL_TEXTURE_COORD_ARRAY_POINTER -> fa
    int GL_SAMPLE_BUFFERS -> fb
    int GL_SAMPLES -> fc
    int GL_SAMPLE_COVERAGE_VALUE -> fd
    int GL_SAMPLE_COVERAGE_INVERT -> fe
    int GL_GENERATE_MIPMAP_HINT -> ff
    int GL_GENERATE_MIPMAP -> fg
    int GL_ACTIVE_TEXTURE -> fh
    int GL_CLIENT_ACTIVE_TEXTURE -> fi
    int GL_ARRAY_BUFFER -> fj
    int GL_ELEMENT_ARRAY_BUFFER -> fk
    int GL_ARRAY_BUFFER_BINDING -> fl
    int GL_ELEMENT_ARRAY_BUFFER_BINDING -> fm
    int GL_VERTEX_ARRAY_BUFFER_BINDING -> fn
    int GL_NORMAL_ARRAY_BUFFER_BINDING -> fo
    int GL_COLOR_ARRAY_BUFFER_BINDING -> fp
    int GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING -> fq
    int GL_STATIC_DRAW -> fr
    int GL_DYNAMIC_DRAW -> fs
    int GL_BUFFER_SIZE -> ft
    int GL_BUFFER_USAGE -> fu
    int GL_SUBTRACT -> fv
    int GL_COMBINE -> fw
    int GL_COMBINE_RGB -> fx
    int GL_COMBINE_ALPHA -> fy
    int GL_RGB_SCALE -> fz
    int GL_ADD_SIGNED -> fA
    int GL_INTERPOLATE -> fB
    int GL_CONSTANT -> fC
    int GL_PRIMARY_COLOR -> fD
    int GL_PREVIOUS -> fE
    int GL_OPERAND0_RGB -> fF
    int GL_OPERAND1_RGB -> fG
    int GL_OPERAND2_RGB -> fH
    int GL_OPERAND0_ALPHA -> fI
    int GL_OPERAND1_ALPHA -> fJ
    int GL_OPERAND2_ALPHA -> fK
    int GL_ALPHA_SCALE -> fL
    int GL_SRC0_RGB -> fM
    int GL_SRC1_RGB -> fN
    int GL_SRC2_RGB -> fO
    int GL_SRC0_ALPHA -> fP
    int GL_SRC1_ALPHA -> fQ
    int GL_SRC2_ALPHA -> fR
    int GL_DOT3_RGB -> fS
    int GL_DOT3_RGBA -> fT
    int GL_POINT_SIZE_ARRAY_OES -> fU
    int GL_POINT_SIZE_ARRAY_TYPE_OES -> fV
    int GL_POINT_SIZE_ARRAY_STRIDE_OES -> fW
    int GL_POINT_SIZE_ARRAY_POINTER_OES -> fX
    int GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES -> fY
    int GL_POINT_SPRITE_OES -> fZ
    int GL_COORD_REPLACE_OES -> ga
    int GL_OES_point_size_array -> gb
    int GL_OES_point_sprite -> gc
    void glClipPlanef(int,float[],int) -> c
    void glClipPlanef(int,java.nio.FloatBuffer) -> c
    void glGetClipPlanef(int,float[],int) -> d
    void glGetClipPlanef(int,java.nio.FloatBuffer) -> d
    void glGetFloatv(int,float[],int) -> e
    void glGetFloatv(int,java.nio.FloatBuffer) -> e
    void glGetLightfv(int,int,float[],int) -> d
    void glGetLightfv(int,int,java.nio.FloatBuffer) -> d
    void glGetMaterialfv(int,int,float[],int) -> e
    void glGetMaterialfv(int,int,java.nio.FloatBuffer) -> e
    void glGetTexParameterfv(int,int,float[],int) -> f
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> f
    void glPointParameterf(int,float) -> d
    void glPointParameterfv(int,float[],int) -> f
    void glPointParameterfv(int,java.nio.FloatBuffer) -> f
    void glTexParameterfv(int,int,float[],int) -> g
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> g
    void glBindBuffer(int,int) -> b
    void glBufferData(int,int,java.nio.Buffer,int) -> a
    void glBufferSubData(int,int,int,java.nio.Buffer) -> d
    void glColor4ub(byte,byte,byte,byte) -> a
    void glDeleteBuffers(int,int[],int) -> d
    void glDeleteBuffers(int,java.nio.IntBuffer) -> a
    void glGetBooleanv(int,boolean[],int) -> a
    void glGetBooleanv(int,java.nio.IntBuffer) -> c
    void glGetBufferParameteriv(int,int,int[],int) -> a
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> a
    void glGenBuffers(int,int[],int) -> e
    void glGenBuffers(int,java.nio.IntBuffer) -> b
    void glGetPointerv(int,java.nio.Buffer[]) -> a
    void glGetTexEnviv(int,int,int[],int) -> b
    void glGetTexEnviv(int,int,java.nio.IntBuffer) -> b
    void glGetTexParameteriv(int,int,int[],int) -> c
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> c
    boolean glIsBuffer(int) -> g
    boolean glIsEnabled(int) -> h
    boolean glIsTexture(int) -> i
    void glTexEnvi(int,int,int) -> a
    void glTexEnviv(int,int,int[],int) -> d
    void glTexEnviv(int,int,java.nio.IntBuffer) -> d
    void glTexParameteri(int,int,int) -> b
    void glTexParameteriv(int,int,int[],int) -> e
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> e
    void glPointSizePointerOES(int,int,java.nio.Buffer) -> b
    void glVertexPointer(int,int,int,int) -> c
    void glColorPointer(int,int,int,int) -> a
    void glNormalPointer(int,int,int) -> c
    void glTexCoordPointer(int,int,int,int) -> b
    void glDrawElements(int,int,int,int) -> d
com.badlogic.gdx.graphics.GL20 -> com.badlogic.gdx.graphics.f:
    int GL_ES_VERSION_2_0 -> a
    int GL_DEPTH_BUFFER_BIT -> b
    int GL_STENCIL_BUFFER_BIT -> c
    int GL_COLOR_BUFFER_BIT -> d
    int GL_FALSE -> e
    int GL_TRUE -> f
    int GL_POINTS -> g
    int GL_LINES -> h
    int GL_LINE_LOOP -> i
    int GL_LINE_STRIP -> j
    int GL_TRIANGLES -> k
    int GL_TRIANGLE_STRIP -> l
    int GL_TRIANGLE_FAN -> m
    int GL_ZERO -> n
    int GL_ONE -> o
    int GL_SRC_COLOR -> p
    int GL_ONE_MINUS_SRC_COLOR -> q
    int GL_SRC_ALPHA -> r
    int GL_ONE_MINUS_SRC_ALPHA -> s
    int GL_DST_ALPHA -> t
    int GL_ONE_MINUS_DST_ALPHA -> u
    int GL_DST_COLOR -> v
    int GL_ONE_MINUS_DST_COLOR -> w
    int GL_SRC_ALPHA_SATURATE -> x
    int GL_FUNC_ADD -> y
    int GL_BLEND_EQUATION -> z
    int GL_BLEND_EQUATION_RGB -> A
    int GL_BLEND_EQUATION_ALPHA -> B
    int GL_FUNC_SUBTRACT -> C
    int GL_FUNC_REVERSE_SUBTRACT -> D
    int GL_BLEND_DST_RGB -> E
    int GL_BLEND_SRC_RGB -> F
    int GL_BLEND_DST_ALPHA -> G
    int GL_BLEND_SRC_ALPHA -> H
    int GL_CONSTANT_COLOR -> I
    int GL_ONE_MINUS_CONSTANT_COLOR -> J
    int GL_CONSTANT_ALPHA -> K
    int GL_ONE_MINUS_CONSTANT_ALPHA -> L
    int GL_BLEND_COLOR -> M
    int GL_ARRAY_BUFFER -> N
    int GL_ELEMENT_ARRAY_BUFFER -> O
    int GL_ARRAY_BUFFER_BINDING -> P
    int GL_ELEMENT_ARRAY_BUFFER_BINDING -> Q
    int GL_STREAM_DRAW -> R
    int GL_STATIC_DRAW -> S
    int GL_DYNAMIC_DRAW -> T
    int GL_BUFFER_SIZE -> U
    int GL_BUFFER_USAGE -> V
    int GL_CURRENT_VERTEX_ATTRIB -> W
    int GL_FRONT -> X
    int GL_BACK -> Y
    int GL_FRONT_AND_BACK -> Z
    int GL_TEXTURE_2D -> aa
    int GL_CULL_FACE -> ab
    int GL_BLEND -> ac
    int GL_DITHER -> ad
    int GL_STENCIL_TEST -> ae
    int GL_DEPTH_TEST -> af
    int GL_SCISSOR_TEST -> ag
    int GL_POLYGON_OFFSET_FILL -> ah
    int GL_SAMPLE_ALPHA_TO_COVERAGE -> ai
    int GL_SAMPLE_COVERAGE -> aj
    int GL_NO_ERROR -> ak
    int GL_INVALID_ENUM -> al
    int GL_INVALID_VALUE -> am
    int GL_INVALID_OPERATION -> an
    int GL_OUT_OF_MEMORY -> ao
    int GL_CW -> ap
    int GL_CCW -> aq
    int GL_LINE_WIDTH -> ar
    int GL_ALIASED_POINT_SIZE_RANGE -> as
    int GL_ALIASED_LINE_WIDTH_RANGE -> at
    int GL_CULL_FACE_MODE -> au
    int GL_FRONT_FACE -> av
    int GL_DEPTH_RANGE -> aw
    int GL_DEPTH_WRITEMASK -> ax
    int GL_DEPTH_CLEAR_VALUE -> ay
    int GL_DEPTH_FUNC -> az
    int GL_STENCIL_CLEAR_VALUE -> aA
    int GL_STENCIL_FUNC -> aB
    int GL_STENCIL_FAIL -> aC
    int GL_STENCIL_PASS_DEPTH_FAIL -> aD
    int GL_STENCIL_PASS_DEPTH_PASS -> aE
    int GL_STENCIL_REF -> aF
    int GL_STENCIL_VALUE_MASK -> aG
    int GL_STENCIL_WRITEMASK -> aH
    int GL_STENCIL_BACK_FUNC -> aI
    int GL_STENCIL_BACK_FAIL -> aJ
    int GL_STENCIL_BACK_PASS_DEPTH_FAIL -> aK
    int GL_STENCIL_BACK_PASS_DEPTH_PASS -> aL
    int GL_STENCIL_BACK_REF -> aM
    int GL_STENCIL_BACK_VALUE_MASK -> aN
    int GL_STENCIL_BACK_WRITEMASK -> aO
    int GL_VIEWPORT -> aP
    int GL_SCISSOR_BOX -> aQ
    int GL_COLOR_CLEAR_VALUE -> aR
    int GL_COLOR_WRITEMASK -> aS
    int GL_UNPACK_ALIGNMENT -> aT
    int GL_PACK_ALIGNMENT -> aU
    int GL_MAX_TEXTURE_SIZE -> aV
    int GL_MAX_TEXTURE_UNITS -> aW
    int GL_MAX_VIEWPORT_DIMS -> aX
    int GL_SUBPIXEL_BITS -> aY
    int GL_RED_BITS -> aZ
    int GL_GREEN_BITS -> ba
    int GL_BLUE_BITS -> bb
    int GL_ALPHA_BITS -> bc
    int GL_DEPTH_BITS -> bd
    int GL_STENCIL_BITS -> be
    int GL_POLYGON_OFFSET_UNITS -> bf
    int GL_POLYGON_OFFSET_FACTOR -> bg
    int GL_TEXTURE_BINDING_2D -> bh
    int GL_SAMPLE_BUFFERS -> bi
    int GL_SAMPLES -> bj
    int GL_SAMPLE_COVERAGE_VALUE -> bk
    int GL_SAMPLE_COVERAGE_INVERT -> bl
    int GL_NUM_COMPRESSED_TEXTURE_FORMATS -> bm
    int GL_COMPRESSED_TEXTURE_FORMATS -> bn
    int GL_DONT_CARE -> bo
    int GL_FASTEST -> bp
    int GL_NICEST -> bq
    int GL_GENERATE_MIPMAP_HINT -> br
    int GL_BYTE -> bs
    int GL_UNSIGNED_BYTE -> bt
    int GL_SHORT -> bu
    int GL_UNSIGNED_SHORT -> bv
    int GL_INT -> bw
    int GL_UNSIGNED_INT -> bx
    int GL_FLOAT -> by
    int GL_FIXED -> bz
    int GL_DEPTH_COMPONENT -> bA
    int GL_ALPHA -> bB
    int GL_RGB -> bC
    int GL_RGBA -> bD
    int GL_LUMINANCE -> bE
    int GL_LUMINANCE_ALPHA -> bF
    int GL_UNSIGNED_SHORT_4_4_4_4 -> bG
    int GL_UNSIGNED_SHORT_5_5_5_1 -> bH
    int GL_UNSIGNED_SHORT_5_6_5 -> bI
    int GL_FRAGMENT_SHADER -> bJ
    int GL_VERTEX_SHADER -> bK
    int GL_MAX_VERTEX_ATTRIBS -> bL
    int GL_MAX_VERTEX_UNIFORM_VECTORS -> bM
    int GL_MAX_VARYING_VECTORS -> bN
    int GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS -> bO
    int GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS -> bP
    int GL_MAX_TEXTURE_IMAGE_UNITS -> bQ
    int GL_MAX_FRAGMENT_UNIFORM_VECTORS -> bR
    int GL_SHADER_TYPE -> bS
    int GL_DELETE_STATUS -> bT
    int GL_LINK_STATUS -> bU
    int GL_VALIDATE_STATUS -> bV
    int GL_ATTACHED_SHADERS -> bW
    int GL_ACTIVE_UNIFORMS -> bX
    int GL_ACTIVE_UNIFORM_MAX_LENGTH -> bY
    int GL_ACTIVE_ATTRIBUTES -> bZ
    int GL_ACTIVE_ATTRIBUTE_MAX_LENGTH -> ca
    int GL_SHADING_LANGUAGE_VERSION -> cb
    int GL_CURRENT_PROGRAM -> cc
    int GL_NEVER -> cd
    int GL_LESS -> ce
    int GL_EQUAL -> cf
    int GL_LEQUAL -> cg
    int GL_GREATER -> ch
    int GL_NOTEQUAL -> ci
    int GL_GEQUAL -> cj
    int GL_ALWAYS -> ck
    int GL_KEEP -> cl
    int GL_REPLACE -> cm
    int GL_INCR -> cn
    int GL_DECR -> co
    int GL_INVERT -> cp
    int GL_INCR_WRAP -> cq
    int GL_DECR_WRAP -> cr
    int GL_VENDOR -> cs
    int GL_RENDERER -> ct
    int GL_VERSION -> cu
    int GL_EXTENSIONS -> cv
    int GL_NEAREST -> cw
    int GL_LINEAR -> cx
    int GL_NEAREST_MIPMAP_NEAREST -> cy
    int GL_LINEAR_MIPMAP_NEAREST -> cz
    int GL_NEAREST_MIPMAP_LINEAR -> cA
    int GL_LINEAR_MIPMAP_LINEAR -> cB
    int GL_TEXTURE_MAG_FILTER -> cC
    int GL_TEXTURE_MIN_FILTER -> cD
    int GL_TEXTURE_WRAP_S -> cE
    int GL_TEXTURE_WRAP_T -> cF
    int GL_TEXTURE -> cG
    int GL_TEXTURE_CUBE_MAP -> cH
    int GL_TEXTURE_BINDING_CUBE_MAP -> cI
    int GL_TEXTURE_CUBE_MAP_POSITIVE_X -> cJ
    int GL_TEXTURE_CUBE_MAP_NEGATIVE_X -> cK
    int GL_TEXTURE_CUBE_MAP_POSITIVE_Y -> cL
    int GL_TEXTURE_CUBE_MAP_NEGATIVE_Y -> cM
    int GL_TEXTURE_CUBE_MAP_POSITIVE_Z -> cN
    int GL_TEXTURE_CUBE_MAP_NEGATIVE_Z -> cO
    int GL_MAX_CUBE_MAP_TEXTURE_SIZE -> cP
    int GL_TEXTURE0 -> cQ
    int GL_TEXTURE1 -> cR
    int GL_TEXTURE2 -> cS
    int GL_TEXTURE3 -> cT
    int GL_TEXTURE4 -> cU
    int GL_TEXTURE5 -> cV
    int GL_TEXTURE6 -> cW
    int GL_TEXTURE7 -> cX
    int GL_TEXTURE8 -> cY
    int GL_TEXTURE9 -> cZ
    int GL_TEXTURE10 -> da
    int GL_TEXTURE11 -> db
    int GL_TEXTURE12 -> dc
    int GL_TEXTURE13 -> dd
    int GL_TEXTURE14 -> de
    int GL_TEXTURE15 -> df
    int GL_TEXTURE16 -> dg
    int GL_TEXTURE17 -> dh
    int GL_TEXTURE18 -> di
    int GL_TEXTURE19 -> dj
    int GL_TEXTURE20 -> dk
    int GL_TEXTURE21 -> dl
    int GL_TEXTURE22 -> dm
    int GL_TEXTURE23 -> dn
    int GL_TEXTURE24 -> do
    int GL_TEXTURE25 -> dp
    int GL_TEXTURE26 -> dq
    int GL_TEXTURE27 -> dr
    int GL_TEXTURE28 -> ds
    int GL_TEXTURE29 -> dt
    int GL_TEXTURE30 -> du
    int GL_TEXTURE31 -> dv
    int GL_ACTIVE_TEXTURE -> dw
    int GL_REPEAT -> dx
    int GL_CLAMP_TO_EDGE -> dy
    int GL_MIRRORED_REPEAT -> dz
    int GL_FLOAT_VEC2 -> dA
    int GL_FLOAT_VEC3 -> dB
    int GL_FLOAT_VEC4 -> dC
    int GL_INT_VEC2 -> dD
    int GL_INT_VEC3 -> dE
    int GL_INT_VEC4 -> dF
    int GL_BOOL -> dG
    int GL_BOOL_VEC2 -> dH
    int GL_BOOL_VEC3 -> dI
    int GL_BOOL_VEC4 -> dJ
    int GL_FLOAT_MAT2 -> dK
    int GL_FLOAT_MAT3 -> dL
    int GL_FLOAT_MAT4 -> dM
    int GL_SAMPLER_2D -> dN
    int GL_SAMPLER_CUBE -> dO
    int GL_VERTEX_ATTRIB_ARRAY_ENABLED -> dP
    int GL_VERTEX_ATTRIB_ARRAY_SIZE -> dQ
    int GL_VERTEX_ATTRIB_ARRAY_STRIDE -> dR
    int GL_VERTEX_ATTRIB_ARRAY_TYPE -> dS
    int GL_VERTEX_ATTRIB_ARRAY_NORMALIZED -> dT
    int GL_VERTEX_ATTRIB_ARRAY_POINTER -> dU
    int GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING -> dV
    int GL_IMPLEMENTATION_COLOR_READ_TYPE -> dW
    int GL_IMPLEMENTATION_COLOR_READ_FORMAT -> dX
    int GL_COMPILE_STATUS -> dY
    int GL_INFO_LOG_LENGTH -> dZ
    int GL_SHADER_SOURCE_LENGTH -> ea
    int GL_SHADER_COMPILER -> eb
    int GL_SHADER_BINARY_FORMATS -> ec
    int GL_NUM_SHADER_BINARY_FORMATS -> ed
    int GL_LOW_FLOAT -> ee
    int GL_MEDIUM_FLOAT -> ef
    int GL_HIGH_FLOAT -> eg
    int GL_LOW_INT -> eh
    int GL_MEDIUM_INT -> ei
    int GL_HIGH_INT -> ej
    int GL_FRAMEBUFFER -> ek
    int GL_RENDERBUFFER -> el
    int GL_RGBA4 -> em
    int GL_RGB5_A1 -> en
    int GL_RGB565 -> eo
    int GL_DEPTH_COMPONENT16 -> ep
    int GL_STENCIL_INDEX -> eq
    int GL_STENCIL_INDEX8 -> er
    int GL_RENDERBUFFER_WIDTH -> es
    int GL_RENDERBUFFER_HEIGHT -> et
    int GL_RENDERBUFFER_INTERNAL_FORMAT -> eu
    int GL_RENDERBUFFER_RED_SIZE -> ev
    int GL_RENDERBUFFER_GREEN_SIZE -> ew
    int GL_RENDERBUFFER_BLUE_SIZE -> ex
    int GL_RENDERBUFFER_ALPHA_SIZE -> ey
    int GL_RENDERBUFFER_DEPTH_SIZE -> ez
    int GL_RENDERBUFFER_STENCIL_SIZE -> eA
    int GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE -> eB
    int GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME -> eC
    int GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL -> eD
    int GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE -> eE
    int GL_COLOR_ATTACHMENT0 -> eF
    int GL_DEPTH_ATTACHMENT -> eG
    int GL_STENCIL_ATTACHMENT -> eH
    int GL_NONE -> eI
    int GL_FRAMEBUFFER_COMPLETE -> eJ
    int GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT -> eK
    int GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT -> eL
    int GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS -> eM
    int GL_FRAMEBUFFER_UNSUPPORTED -> eN
    int GL_FRAMEBUFFER_BINDING -> eO
    int GL_RENDERBUFFER_BINDING -> eP
    int GL_MAX_RENDERBUFFER_SIZE -> eQ
    int GL_INVALID_FRAMEBUFFER_OPERATION -> eR
    int GL_VERTEX_PROGRAM_POINT_SIZE -> eS
    int GL_COVERAGE_BUFFER_BIT_NV -> eT
    void glAttachShader(int,int) -> glAttachShader
    void glBindAttribLocation(int,int,java.lang.String) -> glBindAttribLocation
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBlendColor(float,float,float,float) -> glBlendColor
    void glBlendEquation(int) -> glBlendEquation
    void glBlendEquationSeparate(int,int) -> glBlendEquationSeparate
    void glBlendFuncSeparate(int,int,int,int) -> glBlendFuncSeparate
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glCompileShader(int) -> glCompileShader
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDetachShader(int,int) -> glDetachShader
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    void glGetAttachedShaders(int,int,java.nio.Buffer,java.nio.IntBuffer) -> glGetAttachedShaders
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetBooleanv(int,java.nio.Buffer) -> glGetBooleanv
    void glGetBufferParameteriv(int,int,java.nio.IntBuffer) -> glGetBufferParameteriv
    void glGetFloatv(int,java.nio.FloatBuffer) -> glGetFloatv
    void glGetFramebufferAttachmentParameteriv(int,int,int,java.nio.IntBuffer) -> glGetFramebufferAttachmentParameteriv
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetRenderbufferParameteriv(int,int,java.nio.IntBuffer) -> glGetRenderbufferParameteriv
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    void glGetShaderPrecisionFormat(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> glGetShaderPrecisionFormat
    void glGetShaderSource(int,int,java.nio.Buffer,java.lang.String) -> glGetShaderSource
    void glGetTexParameterfv(int,int,java.nio.FloatBuffer) -> glGetTexParameterfv
    void glGetTexParameteriv(int,int,java.nio.IntBuffer) -> glGetTexParameteriv
    void glGetUniformfv(int,int,java.nio.FloatBuffer) -> glGetUniformfv
    void glGetUniformiv(int,int,java.nio.IntBuffer) -> glGetUniformiv
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glGetVertexAttribfv(int,int,java.nio.FloatBuffer) -> glGetVertexAttribfv
    void glGetVertexAttribiv(int,int,java.nio.IntBuffer) -> glGetVertexAttribiv
    void glGetVertexAttribPointerv(int,int,java.nio.Buffer) -> glGetVertexAttribPointerv
    boolean glIsBuffer(int) -> glIsBuffer
    boolean glIsEnabled(int) -> glIsEnabled
    boolean glIsFramebuffer(int) -> glIsFramebuffer
    boolean glIsProgram(int) -> glIsProgram
    boolean glIsRenderbuffer(int) -> glIsRenderbuffer
    boolean glIsShader(int) -> glIsShader
    boolean glIsTexture(int) -> glIsTexture
    void glLinkProgram(int) -> glLinkProgram
    void glReleaseShaderCompiler() -> glReleaseShaderCompiler
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glSampleCoverage(float,boolean) -> glSampleCoverage
    void glShaderBinary(int,java.nio.IntBuffer,int,java.nio.Buffer,int) -> glShaderBinary
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glStencilFuncSeparate(int,int,int,int) -> glStencilFuncSeparate
    void glStencilMaskSeparate(int,int) -> glStencilMaskSeparate
    void glStencilOpSeparate(int,int,int,int) -> glStencilOpSeparate
    void glTexParameterfv(int,int,java.nio.FloatBuffer) -> glTexParameterfv
    void glTexParameteri(int,int,int) -> glTexParameteri
    void glTexParameteriv(int,int,java.nio.IntBuffer) -> glTexParameteriv
    void glUniform1f(int,float) -> glUniform1f
    void glUniform1fv(int,int,java.nio.FloatBuffer) -> glUniform1fv
    void glUniform1i(int,int) -> glUniform1i
    void glUniform1iv(int,int,java.nio.IntBuffer) -> glUniform1iv
    void glUniform2f(int,float,float) -> glUniform2f
    void glUniform2fv(int,int,java.nio.FloatBuffer) -> glUniform2fv
    void glUniform2i(int,int,int) -> glUniform2i
    void glUniform2iv(int,int,java.nio.IntBuffer) -> glUniform2iv
    void glUniform3f(int,float,float,float) -> glUniform3f
    void glUniform3fv(int,int,java.nio.FloatBuffer) -> glUniform3fv
    void glUniform3i(int,int,int,int) -> glUniform3i
    void glUniform3iv(int,int,java.nio.IntBuffer) -> glUniform3iv
    void glUniform4f(int,float,float,float,float) -> glUniform4f
    void glUniform4fv(int,int,java.nio.FloatBuffer) -> glUniform4fv
    void glUniform4i(int,int,int,int,int) -> glUniform4i
    void glUniform4iv(int,int,java.nio.IntBuffer) -> glUniform4iv
    void glUniformMatrix2fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix2fv
    void glUniformMatrix3fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix3fv
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glValidateProgram(int) -> glValidateProgram
    void glVertexAttrib1f(int,float) -> glVertexAttrib1f
    void glVertexAttrib1fv(int,java.nio.FloatBuffer) -> glVertexAttrib1fv
    void glVertexAttrib2f(int,float,float) -> glVertexAttrib2f
    void glVertexAttrib2fv(int,java.nio.FloatBuffer) -> glVertexAttrib2fv
    void glVertexAttrib3f(int,float,float,float) -> glVertexAttrib3f
    void glVertexAttrib3fv(int,java.nio.FloatBuffer) -> glVertexAttrib3fv
    void glVertexAttrib4f(int,float,float,float,float) -> glVertexAttrib4f
    void glVertexAttrib4fv(int,java.nio.FloatBuffer) -> glVertexAttrib4fv
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
com.badlogic.gdx.graphics.GLCommon -> com.badlogic.gdx.graphics.g:
    int GL_GENERATE_MIPMAP -> gd
    int GL_TEXTURE_MAX_ANISOTROPY_EXT -> ge
    int GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT -> gf
    void glActiveTexture(int) -> glActiveTexture
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glClearDepthf(float) -> glClearDepthf
    void glClearStencil(int) -> glClearStencil
    void glColorMask(boolean,boolean,boolean,boolean) -> glColorMask
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glCompressedTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexSubImage2D
    void glCopyTexImage2D(int,int,int,int,int,int,int,int) -> glCopyTexImage2D
    void glCopyTexSubImage2D(int,int,int,int,int,int,int,int) -> glCopyTexSubImage2D
    void glCullFace(int) -> glCullFace
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthFunc(int) -> glDepthFunc
    void glDepthMask(boolean) -> glDepthMask
    void glDepthRangef(float,float) -> glDepthRangef
    void glDisable(int) -> glDisable
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glFinish() -> glFinish
    void glFlush() -> glFlush
    void glFrontFace(int) -> glFrontFace
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    int glGetError() -> glGetError
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glHint(int,int) -> glHint
    void glLineWidth(float) -> glLineWidth
    void glPixelStorei(int,int) -> glPixelStorei
    void glPolygonOffset(float,float) -> glPolygonOffset
    void glReadPixels(int,int,int,int,int,int,java.nio.Buffer) -> glReadPixels
    void glScissor(int,int,int,int) -> glScissor
    void glStencilFunc(int,int,int) -> glStencilFunc
    void glStencilMask(int) -> glStencilMask
    void glStencilOp(int,int,int) -> glStencilOp
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glTexSubImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexSubImage2D
    void glViewport(int,int,int,int) -> glViewport
com.badlogic.gdx.graphics.Mesh -> com.badlogic.gdx.graphics.h:
    java.util.Map meshes -> a
    boolean forceVBO -> b
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> c
    com.badlogic.gdx.graphics.glutils.IndexData indices -> d
    boolean autoBind -> e
    boolean isVertexArray -> f
    com.badlogic.gdx.graphics.Mesh create(boolean,com.badlogic.gdx.graphics.Mesh,com.badlogic.gdx.math.Matrix4[]) -> a
    com.badlogic.gdx.graphics.Mesh create(boolean,com.badlogic.gdx.graphics.Mesh[]) -> a
    com.badlogic.gdx.graphics.Mesh create(boolean,com.badlogic.gdx.graphics.Mesh[],com.badlogic.gdx.math.Matrix4[]) -> a
    void setVertices(float[]) -> a
    void setVertices(float[],int,int) -> a
    void getVertices(float[]) -> b
    void getVertices(int,float[]) -> a
    void getVertices(int,int,float[]) -> a
    void getVertices(int,int,float[],int) -> a
    void setIndices(short[]) -> a
    void setIndices(short[],int,int) -> a
    void getIndices(short[]) -> b
    void getIndices(short[],int) -> a
    int getNumIndices() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    int getMaxIndices() -> d
    int getVertexSize() -> f
    void setAutoBind(boolean) -> a
    void bind() -> g
    void unbind() -> h
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void render(int) -> a
    void render(int,int,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> a
    void dispose() -> e
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> b
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> i
    java.nio.FloatBuffer getVerticesBuffer() -> j
    com.badlogic.gdx.math.collision.BoundingBox calculateBoundingBox() -> k
    void calculateBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    java.nio.ShortBuffer getIndicesBuffer() -> l
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> a
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> a
    void clearAllMeshes(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> m
    void scale(float,float,float) -> a
    void transform(com.badlogic.gdx.math.Matrix4) -> a
    void transform(com.badlogic.gdx.math.Matrix4,int,int) -> a
    void transform(com.badlogic.gdx.math.Matrix4,float[],int,int,int,int,int) -> a
    com.badlogic.gdx.graphics.Mesh copy(boolean,boolean,int[]) -> a
    com.badlogic.gdx.graphics.Mesh copy(boolean) -> b
com.badlogic.gdx.graphics.Mesh$VertexDataType -> com.badlogic.gdx.graphics.i:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] values() -> values
    com.badlogic.gdx.graphics.Mesh$VertexDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.OrthographicCamera -> com.badlogic.gdx.graphics.j:
    float zoom -> o
    com.badlogic.gdx.math.Vector3 tmp -> p
    void findDirectionForIsoView(float,float,int) -> a
    float calculateAngle(float) -> b
    com.badlogic.gdx.math.Vector3 calculateDirection(float) -> c
    void update() -> a
    void update(boolean) -> a
    void setToOrtho(boolean) -> b
    void setToOrtho(boolean,float,float) -> a
    void rotate(float) -> a
    void translate(float,float) -> b
    void translate(com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.graphics.PerspectiveCamera -> com.badlogic.gdx.graphics.k:
    float fieldOfView -> o
    com.badlogic.gdx.math.Vector3 tmp -> p
    void update() -> a
    void update(boolean) -> a
com.badlogic.gdx.graphics.Pixmap -> com.badlogic.gdx.graphics.l:
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> c
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> a
    int color -> b
    boolean disposed -> d
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> a
    void setFilter(com.badlogic.gdx.graphics.Pixmap$Filter) -> a
    void setColor(int) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void fill() -> a
    void drawLine(int,int,int,int) -> a
    void drawRectangle(int,int,int,int) -> b
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> a
    void fillRectangle(int,int,int,int) -> c
    void drawCircle(int,int,int) -> a
    void fillCircle(int,int,int) -> b
    int getPixel(int,int) -> a
    int getWidth() -> b
    int getHeight() -> c
    void dispose() -> e
    void drawPixel(int,int) -> b
    void drawPixel(int,int,int) -> c
    int getGLFormat() -> d
    int getGLInternalFormat() -> f
    int getGLType() -> g
    java.nio.ByteBuffer getPixels() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    com.badlogic.gdx.graphics.Pixmap$Blending getBlending() -> j
com.badlogic.gdx.graphics.Pixmap$Blending -> com.badlogic.gdx.graphics.m:
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Blending valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.Pixmap$Filter -> com.badlogic.gdx.graphics.n:
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> a
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> b
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Filter[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Filter valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.Pixmap$Format -> com.badlogic.gdx.graphics.o:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Format valueOf(java.lang.String) -> valueOf
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
com.badlogic.gdx.graphics.PixmapIO -> com.badlogic.gdx.graphics.p:
    void writeCIM(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
    void writePNG(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap) -> b
com.badlogic.gdx.graphics.PixmapIO$CIM -> com.badlogic.gdx.graphics.q:
    int BUFFER_SIZE -> a
    byte[] writeBuffer -> b
    byte[] readBuffer -> c
    void write(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$PNG -> com.badlogic.gdx.graphics.r:
    int[] crcTable -> a
    int ZLIB_BLOCK_SIZE -> b
    byte[] write(com.badlogic.gdx.graphics.Pixmap) -> a
    byte[] createHeaderChunk(int,int) -> a
    byte[] createDataChunk(com.badlogic.gdx.graphics.Pixmap) -> b
    byte[] createTrailerChunk() -> a
    byte[] toChunk(java.lang.String,byte[]) -> a
    void createCRCTable() -> b
    int updateCRC(int,byte[]) -> a
    byte[] toZLIB(byte[]) -> a
    void writeUncompressedDeflateBlock(java.io.DataOutputStream,boolean,byte[],int,char) -> a
    int calcADLER32(byte[]) -> b
com.badlogic.gdx.graphics.Texture -> com.badlogic.gdx.graphics.s:
    boolean enforcePotImages -> h
    com.badlogic.gdx.assets.AssetManager assetManager -> i
    java.util.Map managedTextures -> a
    java.nio.IntBuffer buffer -> j
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> e
    int glHandle -> f
    com.badlogic.gdx.graphics.TextureData data -> g
    void create(com.badlogic.gdx.graphics.TextureData) -> b
    int createGLHandle() -> a
    void load(com.badlogic.gdx.graphics.TextureData) -> a
    void uploadImageData(com.badlogic.gdx.graphics.Pixmap) -> a
    void reload() -> o
    void bind() -> b
    void bind(int) -> a
    void draw(com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    int getWidth() -> c
    int getHeight() -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> g
    com.badlogic.gdx.graphics.Texture$TextureWrap getUWrap() -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap getVWrap() -> i
    com.badlogic.gdx.graphics.TextureData getTextureData() -> j
    boolean isManaged() -> k
    int getTextureObjectHandle() -> l
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> a
    void dispose() -> e
    void setEnforcePotImages(boolean) -> a
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> a
    void clearAllTextures(com.badlogic.gdx.Application) -> a
    void invalidateAllTextures(com.badlogic.gdx.Application) -> b
    void setAssetManager(com.badlogic.gdx.assets.AssetManager) -> a
    java.lang.String getManagedStatus() -> m
    int getNumManagedTextures() -> n
com.badlogic.gdx.graphics.Texture$1 -> com.badlogic.gdx.graphics.t:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> com.badlogic.gdx.graphics.u:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> g
    int glEnum -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureFilter valueOf(java.lang.String) -> valueOf
    boolean isMipMap() -> a
    int getGLEnum() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> com.badlogic.gdx.graphics.v:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> a
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> c
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureWrap valueOf(java.lang.String) -> valueOf
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureData -> com.badlogic.gdx.graphics.w:
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    void consumeCompressedData() -> f
    int getWidth() -> g
    int getHeight() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    boolean useMipMaps() -> j
    boolean isManaged() -> k
com.badlogic.gdx.graphics.TextureData$TextureDataType -> com.badlogic.gdx.graphics.x:
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Compressed -> b
    com.badlogic.gdx.graphics.TextureData$TextureDataType Float -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> d
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] values() -> values
    com.badlogic.gdx.graphics.TextureData$TextureDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.TextureDict -> com.badlogic.gdx.graphics.y:
    com.badlogic.gdx.utils.ObjectMap sDictionary -> a
    com.badlogic.gdx.graphics.TextureRef loadTexture(java.lang.String) -> a
    com.badlogic.gdx.graphics.TextureRef loadTexture(java.lang.String,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void removeTexture(java.lang.String) -> b
    void unloadAll() -> a
com.badlogic.gdx.graphics.TextureRef -> com.badlogic.gdx.graphics.z:
    java.lang.String Name -> a
    int mRefCount -> b
    com.badlogic.gdx.graphics.Texture mTexture -> c
    void addRef() -> a
    int unload() -> b
    void dispose() -> c
    void bind() -> d
    com.badlogic.gdx.graphics.Texture get() -> e
com.badlogic.gdx.graphics.VertexAttribute -> com.badlogic.gdx.graphics.aa:
    int usage -> a
    int numComponents -> b
    int offset -> c
    java.lang.String alias -> d
    com.badlogic.gdx.graphics.VertexAttribute Position() -> a
    com.badlogic.gdx.graphics.VertexAttribute TexCoords(int) -> a
    com.badlogic.gdx.graphics.VertexAttribute Normal() -> b
    com.badlogic.gdx.graphics.VertexAttribute Color() -> c
    com.badlogic.gdx.graphics.VertexAttribute ColorUnpacked() -> d
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.VertexAttributes -> com.badlogic.gdx.graphics.ab:
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
    int vertexSize -> a
    int getOffset(int) -> a
    com.badlogic.gdx.graphics.VertexAttribute findByUsage(int) -> b
    int calculateOffsets() -> b
    void checkValidity() -> c
    int size() -> a
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> c
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.VertexAttributes$Usage -> com.badlogic.gdx.graphics.ac:
    int Position -> a
    int Color -> b
    int ColorPacked -> c
    int Normal -> d
    int TextureCoordinates -> e
    int Generic -> f
com.badlogic.gdx.graphics.g2d.Animation -> com.badlogic.gdx.graphics.g2d.a:
    int NORMAL -> a
    int REVERSED -> b
    int LOOP -> c
    int LOOP_REVERSED -> d
    int LOOP_PINGPONG -> e
    int LOOP_RANDOM -> f
    com.badlogic.gdx.graphics.g2d.TextureRegion[] keyFrames -> g
    float frameDuration -> h
    float animationDuration -> i
    int playMode -> j
    com.badlogic.gdx.graphics.g2d.TextureRegion getKeyFrame(float,boolean) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getKeyFrame(float) -> a
    int getKeyFrameIndex(float) -> b
    void setPlayMode(int) -> a
    boolean isAnimationFinished(float) -> c
com.badlogic.gdx.graphics.g2d.BitmapFont -> com.badlogic.gdx.graphics.g2d.b:
    int LOG2_PAGE_SIZE -> e
    int PAGE_SIZE -> f
    int PAGES -> g
    char[] xChars -> a
    char[] capChars -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> d
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> h
    boolean flipped -> i
    boolean integer -> j
    boolean ownsTexture -> k
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float,int,int) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds drawMultiLine(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds drawMultiLine(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds drawWrapped(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds drawWrapped(com.badlogic.gdx.graphics.g2d.SpriteBatch,java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    void computeGlyphAdvancesAndPositions(java.lang.CharSequence,com.badlogic.gdx.utils.FloatArray,com.badlogic.gdx.utils.FloatArray) -> a
    int computeVisibleGlyphs(java.lang.CharSequence,int,int,float) -> a
    void setColor(float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> a
    void setScale(float,float) -> a
    void setScale(float) -> b
    void scale(float) -> c
    float getScaleX() -> b
    float getScaleY() -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> d
    float getLineHeight() -> f
    float getSpaceWidth() -> g
    float getXHeight() -> h
    float getCapHeight() -> i
    float getAscent() -> j
    float getDescent() -> k
    boolean isFlipped() -> l
    void dispose() -> e
    void setFixedWidthGlyphs(java.lang.CharSequence) -> c
    boolean containsCharacter(char) -> a
    void setUseIntegerPositions(boolean) -> a
    boolean usesIntegerPositions() -> m
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData getData() -> n
    boolean ownsTexture() -> o
    void setOwnsTexture(boolean) -> b
    int indexOf(java.lang.CharSequence,char,int) -> a
    boolean isWhitespace(char) -> b
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> com.badlogic.gdx.graphics.g2d.c:
    java.lang.String imagePath -> a
    com.badlogic.gdx.files.FileHandle fontFile -> b
    boolean flipped -> c
    float lineHeight -> d
    float capHeight -> e
    float ascent -> f
    float descent -> g
    float down -> h
    float scaleX -> i
    float scaleY -> j
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> k
    float spaceWidth -> l
    float xHeight -> m
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> a
    java.lang.String getImagePath() -> b
    com.badlogic.gdx.files.FileHandle getFontFile() -> c
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> com.badlogic.gdx.graphics.g2d.d:
    int srcX -> a
    int srcY -> b
    int width -> c
    int height -> d
    float u -> e
    float v -> f
    float u2 -> g
    float v2 -> h
    int xoffset -> i
    int yoffset -> j
    int xadvance -> k
    byte[][] kerning -> l
    int getKerning(char) -> a
    void setKerning(int,int) -> a
com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment -> com.badlogic.gdx.graphics.g2d.e:
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment LEFT -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment CENTER -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment RIGHT -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] values() -> values
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds -> com.badlogic.gdx.graphics.g2d.f:
    float width -> a
    float height -> b
    void set(com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> com.badlogic.gdx.graphics.g2d.g:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[] vertices -> b
    int idx -> c
    float x -> d
    float y -> e
    float color -> f
    com.badlogic.gdx.graphics.Color tempColor -> g
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds textBounds -> h
    boolean integer -> i
    void setPosition(float,float) -> a
    void translate(float,float) -> b
    void setColor(float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color,int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> a
    void clear() -> b
    void require(int) -> a
    float addToCache(java.lang.CharSequence,float,float,int,int) -> c
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setText(java.lang.CharSequence,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setText(java.lang.CharSequence,float,float,int,int) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addText(java.lang.CharSequence,float,float) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addText(java.lang.CharSequence,float,float,int,int) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setMultiLineText(java.lang.CharSequence,float,float) -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addMultiLineText(java.lang.CharSequence,float,float) -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setWrappedText(java.lang.CharSequence,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addWrappedText(java.lang.CharSequence,float,float,float) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds() -> c
    float getX() -> d
    float getY() -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> f
    void setUseIntegerPositions(boolean) -> a
    boolean usesIntegerPositions() -> g
    float[] getVertices() -> h
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    int GDX2D_FORMAT_ALPHA -> a
    int GDX2D_FORMAT_LUMINANCE_ALPHA -> b
    int GDX2D_FORMAT_RGB888 -> c
    int GDX2D_FORMAT_RGBA8888 -> d
    int GDX2D_FORMAT_RGB565 -> e
    int GDX2D_FORMAT_RGBA4444 -> f
    int GDX2D_SCALE_NEAREST -> g
    int GDX2D_SCALE_LINEAR -> h
    int GDX2D_BLEND_NONE -> i
    int GDX2D_BLEND_SRC_OVER -> j
    long basePtr -> k
    int width -> l
    int height -> m
    int format -> n
    java.nio.ByteBuffer pixelPtr -> o
    long[] nativeData -> p
    void dispose() -> e
    void clear(int) -> a
    void setPixel(int,int,int) -> a
    int getPixel(int,int) -> a
    void drawLine(int,int,int,int,int) -> a
    void drawRect(int,int,int,int,int) -> b
    void drawCircle(int,int,int,int) -> a
    void fillRect(int,int,int,int,int) -> c
    void fillCircle(int,int,int,int) -> b
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> a
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap newPixmap(java.io.InputStream,int) -> a
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap newPixmap(int,int,int) -> b
    java.nio.ByteBuffer getPixels() -> a
    int getHeight() -> b
    int getWidth() -> c
    int getFormat() -> d
    int getGLInternalFormat() -> f
    int getGLFormat() -> g
    int getGLType() -> h
    java.lang.String getFormatString() -> i
    java.nio.ByteBuffer load(long[],byte[],int,int,int) -> load
    java.nio.ByteBuffer newPixmap(long[],int,int,int) -> newPixmap
    void free(long) -> free
    void clear(long,int) -> clear
    void setPixel(long,int,int,int) -> setPixel
    int getPixel(long,int,int) -> getPixel
    void drawLine(long,int,int,int,int,int) -> drawLine
    void drawRect(long,int,int,int,int,int) -> drawRect
    void drawCircle(long,int,int,int,int) -> drawCircle
    void fillRect(long,int,int,int,int,int) -> fillRect
    void fillCircle(long,int,int,int,int) -> fillCircle
    void drawPixmap(long,long,int,int,int,int,int,int,int,int) -> drawPixmap
    void setBlend(int) -> setBlend
    void setScale(int) -> setScale
    java.lang.String getFailureReason() -> getFailureReason
com.badlogic.gdx.graphics.g2d.NinePatch -> com.badlogic.gdx.graphics.g2d.h:
    int TOP_LEFT -> a
    int TOP_CENTER -> b
    int TOP_RIGHT -> c
    int MIDDLE_LEFT -> d
    int MIDDLE_CENTER -> e
    int MIDDLE_RIGHT -> f
    int BOTTOM_LEFT -> g
    int BOTTOM_CENTER -> h
    int BOTTOM_RIGHT -> i
    com.badlogic.gdx.graphics.Color tmpDrawColor -> j
    com.badlogic.gdx.graphics.Texture texture -> k
    int bottomLeft -> l
    int bottomCenter -> m
    int bottomRight -> n
    int middleLeft -> o
    int middleCenter -> p
    int middleRight -> q
    int topLeft -> r
    int topCenter -> s
    int topRight -> t
    float leftWidth -> u
    float rightWidth -> v
    float middleWidth -> w
    float middleHeight -> x
    float topHeight -> y
    float bottomHeight -> z
    float[] vertices -> A
    int idx -> B
    com.badlogic.gdx.graphics.Color color -> C
    int padLeft -> D
    int padRight -> E
    int padTop -> F
    int padBottom -> G
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> a
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,float) -> a
    void set(int,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color getColor() -> a
    float getLeftWidth() -> b
    void setLeftWidth(float) -> a
    float getRightWidth() -> c
    void setRightWidth(float) -> b
    float getTopHeight() -> d
    void setTopHeight(float) -> c
    float getBottomHeight() -> e
    void setBottomHeight(float) -> d
    float getMiddleWidth() -> f
    void setMiddleWidth(float) -> e
    float getMiddleHeight() -> g
    void setMiddleHeight(float) -> f
    float getTotalWidth() -> h
    float getTotalHeight() -> i
    void setPadding(int,int,int,int) -> a
    float getPadLeft() -> j
    void setPadLeft(int) -> a
    float getPadRight() -> k
    void setPadRight(int) -> b
    float getPadTop() -> l
    void setPadTop(int) -> c
    float getPadBottom() -> m
    void setPadBottom(int) -> d
    com.badlogic.gdx.graphics.Texture getTexture() -> n
com.badlogic.gdx.graphics.g2d.ParticleEffect -> com.badlogic.gdx.graphics.g2d.i:
    com.badlogic.gdx.utils.Array emitters -> a
    void start() -> a
    void reset() -> b
    void update(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void allowCompletion() -> c
    boolean isComplete() -> d
    void setDuration(int) -> a
    void setPosition(float,float) -> a
    void setFlip(boolean,boolean) -> a
    void flipY() -> f
    com.badlogic.gdx.utils.Array getEmitters() -> g
    com.badlogic.gdx.graphics.g2d.ParticleEmitter findEmitter(java.lang.String) -> a
    void save(java.io.File) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void loadEmitters(com.badlogic.gdx.files.FileHandle) -> a
    void loadEmitterImages(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void loadEmitterImages(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.Texture loadTexture(com.badlogic.gdx.files.FileHandle) -> c
    void dispose() -> e
com.badlogic.gdx.graphics.g2d.ParticleEffectPool -> com.badlogic.gdx.graphics.g2d.j:
    com.badlogic.gdx.graphics.g2d.ParticleEffect effect -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect newObject() -> a
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect obtain() -> c
    java.lang.Object obtain() -> d
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g2d.ParticleEffectPool$PooledEffect -> com.badlogic.gdx.graphics.g2d.k:
    com.badlogic.gdx.graphics.g2d.ParticleEffectPool this$0 -> a
    void reset() -> b
    void free() -> h
com.badlogic.gdx.graphics.g2d.ParticleEmitter -> com.badlogic.gdx.graphics.g2d.l:
    int UPDATE_SCALE -> c
    int UPDATE_ANGLE -> d
    int UPDATE_ROTATION -> e
    int UPDATE_VELOCITY -> f
    int UPDATE_WIND -> g
    int UPDATE_GRAVITY -> h
    int UPDATE_TINT -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue delayValue -> j
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeOffsetValue -> k
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue durationValue -> l
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeValue -> m
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue emissionValue -> n
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue scaleValue -> o
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue rotationValue -> p
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue velocityValue -> q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue angleValue -> r
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue windValue -> s
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue gravityValue -> t
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue transparencyValue -> u
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue tintValue -> v
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue xOffsetValue -> w
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue yOffsetValue -> x
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnWidthValue -> y
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnHeightValue -> z
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue spawnShapeValue -> A
    float accumulator -> B
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> C
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle[] particles -> D
    int minParticleCount -> E
    int maxParticleCount -> F
    float x -> G
    float y -> H
    java.lang.String name -> I
    java.lang.String imagePath -> J
    int activeCount -> K
    boolean[] active -> L
    boolean firstUpdate -> M
    boolean flipX -> N
    boolean flipY -> O
    int updateFlags -> P
    boolean allowCompletion -> Q
    int emission -> R
    int emissionDiff -> S
    int emissionDelta -> T
    int lifeOffset -> U
    int lifeOffsetDiff -> V
    int life -> W
    int lifeDiff -> X
    float spawnWidth -> Y
    float spawnWidthDiff -> Z
    float spawnHeight -> aa
    float spawnHeightDiff -> ab
    float duration -> a
    float durationTimer -> b
    float delay -> ac
    float delayTimer -> ad
    boolean attached -> ae
    boolean continuous -> af
    boolean aligned -> ag
    boolean behind -> ah
    boolean additive -> ai
    void initialize() -> M
    void setMaxParticleCount(int) -> a
    void addParticle() -> a
    void addParticles(int) -> b
    void update(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void start() -> b
    void reset() -> c
    void restart() -> N
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle newParticle(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void activateParticle(int) -> d
    boolean updateParticle(com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle,float,int) -> a
    void setPosition(float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> b
    void allowCompletion() -> d
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> e
    java.lang.String getName() -> f
    void setName(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getLife() -> g
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getScale() -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getRotation() -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue getTint() -> j
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getVelocity() -> k
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getWind() -> l
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getGravity() -> m
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getAngle() -> n
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getEmission() -> o
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getTransparency() -> p
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue getDuration() -> q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue getDelay() -> r
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getLifeOffset() -> s
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue getXOffsetValue() -> t
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue getYOffsetValue() -> u
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getSpawnWidth() -> v
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue getSpawnHeight() -> w
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue getSpawnShape() -> x
    boolean isAttached() -> y
    void setAttached(boolean) -> a
    boolean isContinuous() -> z
    void setContinuous(boolean) -> b
    boolean isAligned() -> A
    void setAligned(boolean) -> c
    boolean isAdditive() -> B
    void setAdditive(boolean) -> d
    boolean isBehind() -> C
    void setBehind(boolean) -> e
    int getMinParticleCount() -> D
    void setMinParticleCount(int) -> c
    int getMaxParticleCount() -> E
    boolean isComplete() -> F
    float getPercentComplete() -> G
    float getX() -> H
    float getY() -> I
    int getActiveCount() -> J
    java.lang.String getImagePath() -> K
    void setImagePath(java.lang.String) -> b
    void setFlip(boolean,boolean) -> a
    void flipY() -> L
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    java.lang.String readString(java.io.BufferedReader,java.lang.String) -> a
    boolean readBoolean(java.io.BufferedReader,java.lang.String) -> b
    int readInt(java.io.BufferedReader,java.lang.String) -> c
    float readFloat(java.io.BufferedReader,java.lang.String) -> d
com.badlogic.gdx.graphics.g2d.ParticleEmitter$1 -> com.badlogic.gdx.graphics.g2d.m:
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnEllipseSide -> a
    int[] $SwitchMap$com$badlogic$gdx$graphics$g2d$ParticleEmitter$SpawnShape -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue -> com.badlogic.gdx.graphics.g2d.n:
    float[] temp -> d
    float[] colors -> e
    float[] timeline -> a
    float[] getTimeline() -> a
    void setTimeline(float[]) -> a
    float[] getColors() -> b
    void setColors(float[]) -> b
    float[] getColor(float) -> a
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$NumericValue -> com.badlogic.gdx.graphics.g2d.o:
    float value -> a
    float getValue() -> a
    void setValue(float) -> a
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$NumericValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle -> com.badlogic.gdx.graphics.g2d.p:
    int life -> a
    int currentLife -> b
    float scale -> c
    float scaleDiff -> d
    float rotation -> e
    float rotationDiff -> f
    float velocity -> g
    float velocityDiff -> h
    float angle -> i
    float angleDiff -> j
    float angleCos -> k
    float angleSin -> l
    float transparency -> m
    float transparencyDiff -> n
    float wind -> o
    float windDiff -> p
    float gravity -> q
    float gravityDiff -> r
    float[] tint -> s
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue -> com.badlogic.gdx.graphics.g2d.q:
    boolean active -> b
    boolean alwaysActive -> c
    void setAlwaysActive(boolean) -> a
    boolean isAlwaysActive() -> c
    boolean isActive() -> d
    void setActive(boolean) -> b
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue -> com.badlogic.gdx.graphics.g2d.r:
    float lowMin -> a
    float lowMax -> d
    float newLowValue() -> a
    void setLow(float) -> a
    void setLow(float,float) -> a
    float getLowMin() -> b
    void setLowMin(float) -> b
    float getLowMax() -> e
    void setLowMax(float) -> c
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue -> com.badlogic.gdx.graphics.g2d.s:
    float[] scaling -> d
    float[] timeline -> a
    float highMin -> e
    float highMax -> f
    boolean relative -> g
    float newHighValue() -> f
    void setHigh(float) -> d
    void setHigh(float,float) -> b
    float getHighMin() -> g
    void setHighMin(float) -> e
    float getHighMax() -> h
    void setHighMax(float) -> f
    float[] getScaling() -> i
    void setScaling(float[]) -> a
    float[] getTimeline() -> j
    void setTimeline(float[]) -> b
    boolean isRelative() -> k
    void setRelative(boolean) -> c
    float getScale(float) -> g
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide -> com.badlogic.gdx.graphics.g2d.t:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide both -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide top -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide bottom -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape -> com.badlogic.gdx.graphics.g2d.u:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape point -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape line -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape square -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape ellipse -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] $VALUES -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue -> com.badlogic.gdx.graphics.g2d.v:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape shape -> a
    boolean edges -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide side -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape getShape() -> a
    void setShape(com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape) -> a
    boolean isEdges() -> b
    void setEdges(boolean) -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide getSide() -> e
    void setSide(com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide) -> a
    void save(java.io.Writer) -> a
    void load(java.io.BufferedReader) -> a
    void load(com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitterBox2D -> com.badlogic.gdx.graphics.g2d.w:
    com.badlogic.gdx.physics.box2d.World world -> c
    com.badlogic.gdx.math.Vector2 startPoint -> d
    com.badlogic.gdx.math.Vector2 endPoint -> e
    boolean particleCollided -> f
    float normalAngle -> g
    float EPSILON -> i
    com.badlogic.gdx.physics.box2d.RayCastCallback rayCallBack -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle newParticle(com.badlogic.gdx.graphics.g2d.Sprite) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitterBox2D$1 -> com.badlogic.gdx.graphics.g2d.x:
    com.badlogic.gdx.graphics.g2d.ParticleEmitterBox2D this$0 -> a
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitterBox2D$ParticleBox2D -> com.badlogic.gdx.graphics.g2d.y:
    com.badlogic.gdx.graphics.g2d.ParticleEmitterBox2D this$0 -> t
    void translate(float,float) -> a
com.badlogic.gdx.graphics.g2d.PixmapPacker -> com.badlogic.gdx.graphics.g2d.z:
    int pageWidth -> a
    int pageHeight -> b
    com.badlogic.gdx.graphics.Pixmap$Format pageFormat -> c
    int padding -> d
    boolean duplicateBorder -> e
    com.badlogic.gdx.utils.Array pages -> f
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page currPage -> g
    boolean disposed -> h
    com.badlogic.gdx.math.Rectangle pack(java.lang.String,com.badlogic.gdx.graphics.Pixmap) -> a
    void newPage() -> g
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Node insert(com.badlogic.gdx.graphics.g2d.PixmapPacker$Node,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.utils.Array getPages() -> a
    com.badlogic.gdx.math.Rectangle getRect(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Page getPage(java.lang.String) -> b
    void dispose() -> e
    com.badlogic.gdx.graphics.g2d.TextureAtlas generateTextureAtlas(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
    void updateTextureAtlas(com.badlogic.gdx.graphics.g2d.TextureAtlas,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> a
    int getPageWidth() -> b
    int getPageHeight() -> c
    int getPadding() -> d
    boolean duplicateBoarder() -> f
com.badlogic.gdx.graphics.g2d.PixmapPacker$1 -> com.badlogic.gdx.graphics.g2d.aa:
    com.badlogic.gdx.graphics.g2d.PixmapPacker this$0 -> h
    void dispose() -> e
com.badlogic.gdx.graphics.g2d.PixmapPacker$2 -> com.badlogic.gdx.graphics.g2d.ab:
    com.badlogic.gdx.graphics.g2d.PixmapPacker this$0 -> h
    void dispose() -> e
com.badlogic.gdx.graphics.g2d.PixmapPacker$ManagedPixmapTextureData -> com.badlogic.gdx.graphics.g2d.ac:
    com.badlogic.gdx.graphics.g2d.PixmapPacker this$0 -> a
    boolean isManaged() -> k
com.badlogic.gdx.graphics.g2d.PixmapPacker$Node -> com.badlogic.gdx.graphics.g2d.ad:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Node leftChild -> a
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Node rightChild -> b
    com.badlogic.gdx.math.Rectangle rect -> c
    java.lang.String leaveName -> d
com.badlogic.gdx.graphics.g2d.PixmapPacker$Page -> com.badlogic.gdx.graphics.g2d.ae:
    com.badlogic.gdx.graphics.g2d.PixmapPacker$Node root -> a
    com.badlogic.gdx.utils.OrderedMap rects -> b
    com.badlogic.gdx.graphics.Pixmap image -> c
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.utils.Array addedRects -> e
    com.badlogic.gdx.graphics.g2d.PixmapPacker this$0 -> f
    com.badlogic.gdx.graphics.Pixmap getPixmap() -> a
com.badlogic.gdx.graphics.g2d.PolygonRegion -> com.badlogic.gdx.graphics.g2d.af:
    float[] texCoords -> a
    float[] localVertices -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> c
    void loadPolygonDefinition(com.badlogic.gdx.files.FileHandle) -> a
    float[] calculateAtlasTexCoords(float[]) -> a
    float[] getLocalVertices() -> a
    float[] getTextureCoords() -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> c
com.badlogic.gdx.graphics.g2d.PolygonSprite -> com.badlogic.gdx.graphics.g2d.ag:
    com.badlogic.gdx.graphics.g2d.PolygonRegion region -> a
    float x -> b
    float y -> c
    float width -> d
    float height -> e
    float scaleX -> f
    float scaleY -> g
    float rotation -> h
    float originX -> i
    float originY -> j
    float[] vertices -> k
    boolean dirty -> l
    com.badlogic.gdx.math.Rectangle bounds -> m
    com.badlogic.gdx.graphics.Color color -> n
    void set(com.badlogic.gdx.graphics.g2d.PolygonSprite) -> a
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> a
    void setPosition(float,float) -> b
    void setX(float) -> a
    void setY(float) -> b
    void translateX(float) -> c
    void translateY(float) -> d
    void translate(float,float) -> c
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> b
    void setOrigin(float,float) -> d
    void setRotation(float) -> e
    void rotate(float) -> f
    void setScale(float) -> g
    void setScale(float,float) -> e
    void scale(float) -> h
    float[] getVertices() -> a
    com.badlogic.gdx.math.Rectangle getBoundingRectangle() -> b
    void draw(com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch) -> a
    void draw(com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch,float) -> a
    float getX() -> c
    float getY() -> d
    float getWidth() -> e
    float getHeight() -> f
    float getOriginX() -> g
    float getOriginY() -> h
    float getRotation() -> i
    float getScaleX() -> j
    float getScaleY() -> k
    com.badlogic.gdx.graphics.Color getColor() -> l
    void setRegion(com.badlogic.gdx.graphics.g2d.PolygonRegion) -> a
com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch -> com.badlogic.gdx.graphics.g2d.ah:
    com.badlogic.gdx.graphics.Mesh mesh -> e
    com.badlogic.gdx.graphics.Mesh[] buffers -> f
    com.badlogic.gdx.graphics.Texture lastTexture -> g
    int idx -> h
    int currBufferIdx -> i
    float[] vertices -> j
    com.badlogic.gdx.math.Matrix4 transformMatrix -> k
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> l
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> m
    boolean drawing -> n
    boolean blendingDisabled -> o
    int blendSrcFunc -> p
    int blendDstFunc -> q
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> r
    boolean ownsShader -> s
    float color -> a
    com.badlogic.gdx.graphics.Color tempColor -> t
    int renderCalls -> b
    int totalRenderCalls -> c
    int maxVerticesInBatch -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> u
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> a
    void begin() -> b
    void end() -> c
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setColor(float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.g2d.PolygonRegion,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.PolygonRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.PolygonRegion,float,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.PolygonRegion,float[],int,int) -> a
    void flush() -> e
    void renderMesh() -> l
    void disableBlending() -> f
    void enableBlending() -> g
    void setBlendFunction(int,int) -> a
    void dispose() -> h
    com.badlogic.gdx.math.Matrix4 getProjectionMatrix() -> i
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> j
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void setupMatrices() -> m
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> a
    void setShader(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    boolean isBlendingEnabled() -> k
com.badlogic.gdx.graphics.g2d.Sprite -> com.badlogic.gdx.graphics.g2d.ai:
    int VERTEX_SIZE -> u
    int SPRITE_SIZE -> v
    float[] vertices -> w
    com.badlogic.gdx.graphics.Color color -> a
    float x -> b
    float y -> c
    float width -> x
    float height -> y
    float originX -> d
    float originY -> e
    float rotation -> f
    float scaleX -> g
    float scaleY -> h
    boolean dirty -> i
    com.badlogic.gdx.math.Rectangle bounds -> j
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> b
    void setPosition(float,float) -> c
    void setX(float) -> a
    void setY(float) -> b
    void translateX(float) -> c
    void translateY(float) -> d
    void translate(float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> b
    void setColor(float) -> e
    void setOrigin(float,float) -> d
    void setRotation(float) -> f
    void rotate(float) -> g
    void rotate90(boolean) -> a
    void setScale(float) -> h
    void setScale(float,float) -> e
    void scale(float) -> i
    float[] getVertices() -> a
    com.badlogic.gdx.math.Rectangle getBoundingRectangle() -> b
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    float getX() -> c
    float getY() -> d
    float getWidth() -> e
    float getHeight() -> f
    float getOriginX() -> g
    float getOriginY() -> h
    float getRotation() -> i
    float getScaleX() -> j
    float getScaleY() -> k
    com.badlogic.gdx.graphics.Color getColor() -> l
    void setRegion(float,float,float,float) -> c
    void setU(float) -> j
    void setV(float) -> k
    void setU2(float) -> l
    void setV2(float) -> m
    void flip(boolean,boolean) -> a
    void scroll(float,float) -> f
com.badlogic.gdx.graphics.g2d.SpriteBatch -> com.badlogic.gdx.graphics.g2d.aj:
    com.badlogic.gdx.graphics.Mesh mesh -> y
    com.badlogic.gdx.graphics.Mesh[] buffers -> z
    com.badlogic.gdx.graphics.Texture lastTexture -> A
    float invTexWidth -> B
    float invTexHeight -> C
    int idx -> D
    int currBufferIdx -> E
    float[] vertices -> F
    com.badlogic.gdx.math.Matrix4 transformMatrix -> G
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> H
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> I
    boolean drawing -> J
    boolean blendingDisabled -> K
    int blendSrcFunc -> L
    int blendDstFunc -> M
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> N
    boolean ownsShader -> O
    float color -> a
    com.badlogic.gdx.graphics.Color tempColor -> P
    int renderCalls -> b
    int totalRenderCalls -> c
    int maxSpritesInBatch -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> Q
    int X1 -> e
    int Y1 -> f
    int C1 -> g
    int U1 -> h
    int V1 -> i
    int X2 -> j
    int Y2 -> k
    int C2 -> l
    int U2 -> m
    int V2 -> n
    int X3 -> o
    int Y3 -> p
    int C3 -> q
    int U3 -> r
    int V3 -> s
    int X4 -> t
    int Y4 -> u
    int C4 -> v
    int U4 -> w
    int V4 -> x
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> a
    void begin() -> b
    void end() -> c
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setColor(float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float,float,int,int,int,int,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,int,int,int,int,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,int,int,int,int) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float,boolean) -> a
    void flush() -> f
    void renderMesh() -> l
    void disableBlending() -> g
    void enableBlending() -> h
    void setBlendFunction(int,int) -> a
    void dispose() -> e
    com.badlogic.gdx.math.Matrix4 getProjectionMatrix() -> i
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> j
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void setupMatrices() -> m
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> a
    void setShader(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    boolean isBlendingEnabled() -> k
com.badlogic.gdx.graphics.g2d.SpriteCache -> com.badlogic.gdx.graphics.g2d.ak:
    float[] tempVertices -> a
    com.badlogic.gdx.graphics.Mesh mesh -> b
    boolean drawing -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> e
    java.util.ArrayList caches -> f
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> g
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> h
    com.badlogic.gdx.graphics.g2d.SpriteCache$Cache currentCache -> i
    java.util.ArrayList textures -> j
    java.util.ArrayList counts -> k
    float color -> l
    com.badlogic.gdx.graphics.Color tempColor -> m
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> n
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setColor(float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> a
    void beginCache() -> b
    void beginCache(int) -> a
    int endCache() -> c
    void clear() -> d
    void add(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void add(com.badlogic.gdx.graphics.Texture,float,float) -> a
    void add(com.badlogic.gdx.graphics.Texture,float,float,int,int,float,float,float,float,float) -> a
    void add(com.badlogic.gdx.graphics.Texture,float,float,int,int,int,int) -> a
    void add(com.badlogic.gdx.graphics.Texture,float,float,float,float,int,int,int,int,boolean,boolean) -> a
    void add(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float,float,int,int,int,int,boolean,boolean) -> a
    void add(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float) -> a
    void add(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void add(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> a
    void add(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void begin() -> f
    void end() -> g
    void draw(int) -> b
    void draw(int,int,int) -> a
    void dispose() -> e
    com.badlogic.gdx.math.Matrix4 getProjectionMatrix() -> h
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> i
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> j
    void setShader(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
com.badlogic.gdx.graphics.g2d.SpriteCache$Cache -> com.badlogic.gdx.graphics.g2d.al:
    int id -> a
    int offset -> b
    int maxCount -> c
    int textureCount -> d
    com.badlogic.gdx.graphics.Texture[] textures -> e
    int[] counts -> f
com.badlogic.gdx.graphics.g2d.TextureAtlas -> com.badlogic.gdx.graphics.g2d.am:
    java.lang.String[] tuple -> a
    java.util.HashSet textures -> c
    com.badlogic.gdx.utils.Array regions -> d
    java.util.Comparator indexComparator -> b
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion addRegion(java.lang.String,com.badlogic.gdx.graphics.Texture,int,int,int,int) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion addRegion(java.lang.String,com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.utils.Array getRegions() -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String,int) -> a
    com.badlogic.gdx.utils.Array findRegions(java.lang.String) -> b
    com.badlogic.gdx.utils.Array createSprites() -> b
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String) -> c
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String,int) -> b
    com.badlogic.gdx.utils.Array createSprites(java.lang.String) -> d
    com.badlogic.gdx.graphics.g2d.Sprite newSprite(com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch createPatch(java.lang.String) -> e
    java.util.Set getTextures() -> c
    void dispose() -> e
    java.lang.String readValue(java.io.BufferedReader) -> a
    int readTuple(java.io.BufferedReader) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$1 -> com.badlogic.gdx.graphics.g2d.an:
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> com.badlogic.gdx.graphics.g2d.ao:
    int index -> a
    java.lang.String name -> b
    float offsetX -> c
    float offsetY -> d
    int packedWidth -> e
    int packedHeight -> f
    int originalWidth -> g
    int originalHeight -> h
    boolean rotate -> i
    int[] splits -> j
    int[] pads -> k
    void flip(boolean,boolean) -> a
    float getRotatedPackedWidth() -> a
    float getRotatedPackedHeight() -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> com.badlogic.gdx.graphics.g2d.ap:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> a
    float originalOffsetX -> b
    float originalOffsetY -> c
    void setPosition(float,float) -> c
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> b
    void setOrigin(float,float) -> d
    void flip(boolean,boolean) -> a
    void rotate90(boolean) -> a
    float getX() -> c
    float getY() -> d
    float getOriginX() -> g
    float getOriginY() -> h
    float getWidth() -> e
    float getHeight() -> f
    float getWidthRatio() -> m
    float getHeightRatio() -> n
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion getAtlasRegion() -> o
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> com.badlogic.gdx.graphics.g2d.aq:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getPages() -> a
    com.badlogic.gdx.utils.Array getRegions() -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> com.badlogic.gdx.graphics.g2d.ar:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    boolean useMipMaps -> c
    com.badlogic.gdx.graphics.Pixmap$Format format -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> g
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> h
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> com.badlogic.gdx.graphics.g2d.as:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    int index -> b
    java.lang.String name -> c
    float offsetX -> d
    float offsetY -> e
    int originalWidth -> f
    int originalHeight -> g
    boolean rotate -> h
    int left -> i
    int top -> j
    int width -> k
    int height -> l
    boolean flip -> m
    int[] splits -> n
    int[] pads -> o
com.badlogic.gdx.graphics.g2d.TextureRegion -> com.badlogic.gdx.graphics.g2d.at:
    com.badlogic.gdx.graphics.Texture texture -> z
    float u -> A
    float v -> B
    float u2 -> C
    float v2 -> D
    int regionWidth -> E
    int regionHeight -> F
    void setRegion(com.badlogic.gdx.graphics.Texture) -> a
    void setRegion(int,int,int,int) -> a
    void setRegion(float,float,float,float) -> c
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> a
    com.badlogic.gdx.graphics.Texture getTexture() -> p
    void setTexture(com.badlogic.gdx.graphics.Texture) -> b
    float getU() -> q
    void setU(float) -> j
    float getV() -> r
    void setV(float) -> k
    float getU2() -> s
    void setU2(float) -> l
    float getV2() -> t
    void setV2(float) -> m
    int getRegionX() -> u
    void setRegionX(int) -> a
    int getRegionY() -> v
    void setRegionY(int) -> b
    int getRegionWidth() -> w
    void setRegionWidth(int) -> c
    int getRegionHeight() -> x
    void setRegionHeight(int) -> d
    void flip(boolean,boolean) -> a
    boolean isFlipX() -> y
    boolean isFlipY() -> z
    void scroll(float,float) -> f
    com.badlogic.gdx.graphics.g2d.TextureRegion[][] split(int,int) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion[][] split(com.badlogic.gdx.graphics.Texture,int,int) -> a
com.badlogic.gdx.graphics.g3d.AnimatedModelInstance -> com.badlogic.gdx.graphics.a.a:
    java.lang.String getAnimation() -> a
    float getAnimationTime() -> b
    boolean isLooping() -> c
com.badlogic.gdx.graphics.g3d.AnimatedModelNode -> com.badlogic.gdx.graphics.a.b:
    java.lang.String animation -> a
    float time -> b
    boolean looping -> c
    java.lang.String getAnimation() -> a
    float getAnimationTime() -> b
    boolean isLooping() -> c
    com.badlogic.gdx.graphics.g3d.AnimatedModelNode copy() -> d
    com.badlogic.gdx.graphics.g3d.StillModelNode copy() -> e
com.badlogic.gdx.graphics.g3d.ModelLoaderHints -> com.badlogic.gdx.graphics.a.c:
    boolean flipV -> a
com.badlogic.gdx.graphics.g3d.ModelRenderer -> com.badlogic.gdx.graphics.a.d:
    void begin() -> a
    void draw(com.badlogic.gdx.graphics.g3d.model.still.StillModel,com.badlogic.gdx.graphics.g3d.StillModelInstance) -> a
    void draw(com.badlogic.gdx.graphics.g3d.model.AnimatedModel,com.badlogic.gdx.graphics.g3d.AnimatedModelInstance) -> a
    void end() -> b
com.badlogic.gdx.graphics.g3d.StillModelInstance -> com.badlogic.gdx.graphics.a.e:
    com.badlogic.gdx.math.Matrix4 getTransform() -> f
    com.badlogic.gdx.math.Vector3 getSortCenter() -> g
    float getBoundingSphereRadius() -> h
    com.badlogic.gdx.graphics.g3d.materials.Material[] getMaterials() -> i
com.badlogic.gdx.graphics.g3d.StillModelNode -> com.badlogic.gdx.graphics.a.f:
    float[] vec3 -> a
    com.badlogic.gdx.math.Vector3 origin -> d
    com.badlogic.gdx.math.Vector3 transformedPosition -> e
    com.badlogic.gdx.math.Matrix4 matrix -> f
    com.badlogic.gdx.graphics.g3d.materials.Material[] materials -> g
    float radius -> h
    com.badlogic.gdx.math.Matrix4 getTransform() -> f
    com.badlogic.gdx.math.Vector3 getSortCenter() -> g
    com.badlogic.gdx.graphics.g3d.materials.Material[] getMaterials() -> i
    float getBoundingSphereRadius() -> h
    com.badlogic.gdx.graphics.g3d.StillModelNode copy() -> e
com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy -> com.badlogic.gdx.graphics.a.a.a:
    int GROUP_OPAQUE -> f
    int GROUP_BLEND -> g
    com.badlogic.gdx.utils.Pool arrayPool -> a
    com.badlogic.gdx.utils.Array usedArrays -> b
    com.badlogic.gdx.utils.ObjectMap materialGroups -> c
    com.badlogic.gdx.graphics.Camera camera -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> e
    java.util.Comparator cameraSorter -> h
    void setCamera(com.badlogic.gdx.graphics.Camera) -> a
    com.badlogic.gdx.graphics.Camera getCamera() -> a
    int decideGroup(com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    void beforeGroup(int,com.badlogic.gdx.utils.Array) -> a
    void afterGroup(int) -> a
    void beforeGroups() -> b
    void afterGroups() -> c
    void createDefaultShader() -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram getGroupShader(int) -> b
    void dispose() -> e
com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy$1 -> com.badlogic.gdx.graphics.a.a.b:
    com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy this$0 -> a
    com.badlogic.gdx.utils.Array newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy$2 -> com.badlogic.gdx.graphics.a.a.c:
    com.badlogic.gdx.graphics.Camera val$camera -> a
    int compare(com.badlogic.gdx.graphics.g3d.decals.Decal,com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g3d.decals.Decal -> com.badlogic.gdx.graphics.a.a.d:
    int VERTEX_SIZE -> N
    int SIZE -> a
    com.badlogic.gdx.math.Vector3 tmp -> O
    com.badlogic.gdx.math.Vector3 tmp2 -> P
    int value -> b
    float[] vertices -> c
    com.badlogic.gdx.math.Vector3 position -> d
    com.badlogic.gdx.math.Quaternion rotation -> e
    com.badlogic.gdx.math.Vector2 scale -> f
    com.badlogic.gdx.math.Vector2 transformationOffset -> g
    com.badlogic.gdx.math.Vector2 dimensions -> h
    com.badlogic.gdx.graphics.g3d.decals.DecalMaterial material -> i
    boolean updated -> j
    com.badlogic.gdx.math.Vector3 dir -> k
    int X1 -> l
    int Y1 -> m
    int Z1 -> n
    int C1 -> o
    int U1 -> p
    int V1 -> q
    int X2 -> r
    int Y2 -> s
    int Z2 -> t
    int C2 -> u
    int U2 -> v
    int V2 -> w
    int X3 -> x
    int Y3 -> y
    int Z3 -> z
    int C3 -> A
    int U3 -> B
    int V3 -> C
    int X4 -> D
    int Y4 -> E
    int Z4 -> F
    int C4 -> G
    int U4 -> H
    int V4 -> I
    com.badlogic.gdx.math.Quaternion rotator -> J
    com.badlogic.gdx.math.Vector3 X_AXIS -> K
    com.badlogic.gdx.math.Vector3 Y_AXIS -> L
    com.badlogic.gdx.math.Vector3 Z_AXIS -> M
    void setColor(float,float,float,float) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float) -> a
    void setRotationX(float) -> b
    void setRotationY(float) -> c
    void setRotationZ(float) -> d
    void rotateX(float) -> e
    void rotateY(float) -> f
    void rotateZ(float) -> g
    void setRotation(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Quaternion getRotation() -> a
    void translateX(float) -> h
    void setX(float) -> i
    float getX() -> b
    void translateY(float) -> j
    void setY(float) -> k
    float getY() -> c
    void translateZ(float) -> l
    void setZ(float) -> m
    float getZ() -> d
    void translate(float,float,float) -> a
    void setPosition(float,float,float) -> b
    com.badlogic.gdx.math.Vector3 getPosition() -> e
    void setScaleX(float) -> n
    float getScaleX() -> f
    void setScaleY(float) -> o
    float getScaleY() -> g
    void setScale(float,float) -> a
    void setScale(float) -> p
    void setWidth(float) -> q
    float getWidth() -> h
    void setHeight(float) -> r
    float getHeight() -> i
    void setDimensions(float,float) -> b
    float[] getVertices() -> j
    void update() -> k
    void transformVertices() -> l
    void resetVertices() -> m
    void updateUVs() -> n
    void setTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> o
    void setBlending(int,int) -> a
    com.badlogic.gdx.graphics.g3d.decals.DecalMaterial getMaterial() -> p
    void lookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.graphics.g3d.decals.Decal newDecal(com.badlogic.gdx.graphics.g2d.TextureRegion) -> b
    com.badlogic.gdx.graphics.g3d.decals.Decal newDecal(com.badlogic.gdx.graphics.g2d.TextureRegion,boolean) -> a
    com.badlogic.gdx.graphics.g3d.decals.Decal newDecal(float,float,com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.graphics.g3d.decals.Decal newDecal(float,float,com.badlogic.gdx.graphics.g2d.TextureRegion,boolean) -> a
    com.badlogic.gdx.graphics.g3d.decals.Decal newDecal(float,float,com.badlogic.gdx.graphics.g2d.TextureRegion,int,int) -> a
com.badlogic.gdx.graphics.g3d.decals.DecalBatch -> com.badlogic.gdx.graphics.a.a.e:
    int DEFAULT_SIZE -> a
    float[] vertices -> b
    com.badlogic.gdx.graphics.Mesh mesh -> c
    com.badlogic.gdx.utils.SortedIntList groupList -> d
    com.badlogic.gdx.graphics.g3d.decals.GroupStrategy groupStrategy -> e
    com.badlogic.gdx.utils.Pool groupPool -> f
    com.badlogic.gdx.utils.Array usedGroups -> g
    void setGroupStrategy(com.badlogic.gdx.graphics.g3d.decals.GroupStrategy) -> a
    void initialize(int) -> a
    int getSize() -> a
    void add(com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    void flush() -> b
    void render() -> c
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,com.badlogic.gdx.utils.Array) -> a
    void flush(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> a
    void clear() -> d
    void dispose() -> e
com.badlogic.gdx.graphics.g3d.decals.DecalBatch$1 -> com.badlogic.gdx.graphics.a.a.f:
    com.badlogic.gdx.graphics.g3d.decals.DecalBatch this$0 -> a
    com.badlogic.gdx.utils.Array newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g3d.decals.DecalMaterial -> com.badlogic.gdx.graphics.a.a.g:
    int NO_BLEND -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> b
    int srcBlendFactor -> c
    int dstBlendFactor -> d
    void set() -> a
    boolean isOpaque() -> b
    int getSrcBlendFactor() -> c
    int getDstBlendFactor() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.decals.DefaultGroupStrategy -> com.badlogic.gdx.graphics.a.a.h:
    int GROUP_OPAQUE -> a
    int GROUP_BLEND -> b
    int decideGroup(com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    void beforeGroup(int,com.badlogic.gdx.utils.Array) -> a
    void afterGroup(int) -> a
    void beforeGroups() -> b
    void afterGroups() -> c
    com.badlogic.gdx.graphics.glutils.ShaderProgram getGroupShader(int) -> b
com.badlogic.gdx.graphics.g3d.decals.GroupPlug -> com.badlogic.gdx.graphics.a.a.i:
    void beforeGroup(com.badlogic.gdx.utils.Array) -> a
    void afterGroup() -> a
com.badlogic.gdx.graphics.g3d.decals.GroupStrategy -> com.badlogic.gdx.graphics.a.a.j:
    com.badlogic.gdx.graphics.glutils.ShaderProgram getGroupShader(int) -> b
    int decideGroup(com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    void beforeGroup(int,com.badlogic.gdx.utils.Array) -> a
    void afterGroup(int) -> a
    void beforeGroups() -> b
    void afterGroups() -> c
com.badlogic.gdx.graphics.g3d.decals.PluggableGroupStrategy -> com.badlogic.gdx.graphics.a.a.k:
    com.badlogic.gdx.utils.IntMap plugs -> a
    void beforeGroup(int,com.badlogic.gdx.utils.Array) -> a
    void afterGroup(int) -> a
    void plugIn(com.badlogic.gdx.graphics.g3d.decals.GroupPlug,int) -> a
    com.badlogic.gdx.graphics.g3d.decals.GroupPlug unPlug(int) -> c
com.badlogic.gdx.graphics.g3d.decals.SimpleOrthoGroupStrategy -> com.badlogic.gdx.graphics.a.a.l:
    com.badlogic.gdx.graphics.g3d.decals.SimpleOrthoGroupStrategy$Comparator comparator -> a
    int GROUP_OPAQUE -> b
    int GROUP_BLEND -> c
    int decideGroup(com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    void beforeGroup(int,com.badlogic.gdx.utils.Array) -> a
    void afterGroup(int) -> a
    void beforeGroups() -> b
    void afterGroups() -> c
    com.badlogic.gdx.graphics.glutils.ShaderProgram getGroupShader(int) -> b
com.badlogic.gdx.graphics.g3d.decals.SimpleOrthoGroupStrategy$Comparator -> com.badlogic.gdx.graphics.a.a.m:
    com.badlogic.gdx.graphics.g3d.decals.SimpleOrthoGroupStrategy this$0 -> a
    int compare(com.badlogic.gdx.graphics.g3d.decals.Decal,com.badlogic.gdx.graphics.g3d.decals.Decal) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g3d.loaders.KeyframedModelLoader -> com.badlogic.gdx.graphics.a.b.a:
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
com.badlogic.gdx.graphics.g3d.loaders.ModelLoader -> com.badlogic.gdx.graphics.a.b.b:
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry -> com.badlogic.gdx.graphics.a.b.c:
    java.util.Map loaders -> a
    java.util.Map defaultHints -> b
    void registerLoader(java.lang.String,com.badlogic.gdx.graphics.g3d.loaders.ModelLoader,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadStillModel(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadStillModel(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel loadKeyframedModel(com.badlogic.gdx.files.FileHandle) -> c
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel loadKeyframedModel(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel loadSkeletonModel(com.badlogic.gdx.files.FileHandle) -> d
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel loadSkeletonModel(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> d
com.badlogic.gdx.graphics.g3d.loaders.SkeletonModelLoader -> com.badlogic.gdx.graphics.a.b.d:
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
com.badlogic.gdx.graphics.g3d.loaders.StillModelLoader -> com.badlogic.gdx.graphics.a.b.e:
    com.badlogic.gdx.graphics.g3d.model.still.StillModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dConstants -> com.badlogic.gdx.graphics.a.b.a.a:
    byte MAJOR_VERSION -> a
    byte MINOR_VERSION -> b
    int G3D_ROOT -> c
    int VERSION_INFO -> d
    int STILL_MODEL -> e
    int STILL_SUBMESH -> f
    int KEYFRAMED_MODEL -> g
    int KEYFRAMED_SUBMESH -> h
    int KEYFRAMED_ANIMATION -> i
    int KEYFRAMED_FRAME -> j
    int SKELETON_MODEL -> k
    int SKELETON_SUBMESH -> l
    int SKELETON_ANIMATIONS -> m
    int SKELETON_ANIMATION -> n
    int SKELETON -> o
    int SKELETON_HIERARCHY -> p
    int SKELETON_JOINT -> q
    int SKELETON_KEYFRAME -> r
    int VERTEX_LIST -> s
    int INDEX_LIST -> t
    int VERTEX_ATTRIBUTES -> u
    int VERTEX_ATTRIBUTE -> v
    int BONE_WEIGHTS -> w
    int BONE_WEIGHT -> x
    int BONE_ASSIGNMENTS -> y
    int BONE_ASSIGNMENT -> z
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader -> com.badlogic.gdx.graphics.a.b.a.b:
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadStillModel(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel loadKeyframedModel(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel loadSkeletonModel(com.badlogic.gdx.files.FileHandle) -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint readSkeletonJoint(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk) -> a
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader$G3dKeyframedModelLoader -> com.badlogic.gdx.graphics.a.b.a.c:
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader$G3dSkeletonModelLoader -> com.badlogic.gdx.graphics.a.b.a.d:
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader$G3dStillModelLoader -> com.badlogic.gdx.graphics.a.b.a.e:
    com.badlogic.gdx.graphics.g3d.model.still.StillModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dtLoader -> com.badlogic.gdx.graphics.a.b.a.f:
    int lineNum -> a
    java.lang.String line -> b
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel loadKeyframedModel(com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadStillModel(com.badlogic.gdx.files.FileHandle,boolean) -> b
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadStillModel(java.io.InputStream,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh readStillSubMesh(java.io.BufferedReader,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel loadKeyframedModel(java.io.InputStream,boolean) -> b
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh readMesh(java.io.BufferedReader,boolean) -> b
    float[] buildVertices(int,boolean,com.badlogic.gdx.utils.Array) -> a
    com.badlogic.gdx.graphics.VertexAttribute[] createVertexAttributes(boolean,int) -> a
    com.badlogic.gdx.utils.FloatArray readUVSet(java.io.BufferedReader,int,boolean) -> a
    com.badlogic.gdx.utils.IntArray readFaces(java.io.BufferedReader) -> a
    short[] convertToShortArray(com.badlogic.gdx.utils.IntArray) -> a
    float readFloat(java.io.BufferedReader) -> b
    int readInt(java.io.BufferedReader) -> c
    java.lang.String readString(java.io.BufferedReader) -> d
    void readFloatArray(java.io.BufferedReader,com.badlogic.gdx.utils.FloatArray) -> a
    int readFloatArray(java.io.BufferedReader,float[],int) -> a
    void readIntArray(java.io.BufferedReader,com.badlogic.gdx.utils.IntArray) -> a
    java.lang.String read(java.io.BufferedReader) -> e
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dtLoader$G3dtKeyframedModelLoader -> com.badlogic.gdx.graphics.a.b.a.g:
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dtLoader$G3dtStillModelLoader -> com.badlogic.gdx.graphics.a.b.a.h:
    com.badlogic.gdx.graphics.g3d.model.still.StillModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader -> com.badlogic.gdx.graphics.a.b.a.a.a:
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk readChunks(java.io.InputStream) -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk loadChunks(java.io.InputStream,int) -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk loadChunk(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.CountingDataInputStream,byte[]) -> a
    byte[] readStream(java.io.InputStream,int) -> b
    void printChunks(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk) -> a
    void printChunks(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk,int) -> a
    java.lang.String rep(java.lang.String,int) -> a
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk -> com.badlogic.gdx.graphics.a.b.a.a.b:
    int id -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk parent -> b
    com.badlogic.gdx.utils.Array children -> c
    java.io.ByteArrayInputStream payload -> d
    byte[] payloadBytes -> e
    int offset -> f
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.CountingDataInputStream in -> g
    int getId() -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk getParent() -> b
    com.badlogic.gdx.utils.Array getChildren() -> c
    int readByte() -> d
    short readShort() -> e
    int readInt() -> f
    long readLong() -> g
    float readFloat() -> h
    double readDouble() -> i
    byte[] readBytes() -> j
    short[] readShorts() -> k
    int[] readInts() -> l
    long[] readLongs() -> m
    float[] readFloats() -> n
    double[] readDoubles() -> o
    java.lang.String readString() -> p
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk getChild(int) -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader$Chunk[] getChildren(int) -> b
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter -> com.badlogic.gdx.graphics.a.b.a.a.c:
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter$Chunk root -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter$Chunk currChunk -> b
    void newChunk(int) -> a
    void endChunk() -> a
    void writeByte(int) -> b
    void writeShort(short) -> a
    void writeInt(int) -> c
    void writeLong(long) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeString(java.lang.String) -> a
    void writeToStream(java.io.OutputStream) -> a
    void writeToStream(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter$Chunk,java.io.DataOutputStream) -> a
    void writeBytes(byte[]) -> a
    void writeShorts(short[]) -> a
    void writeInts(int[]) -> a
    void writeLongs(long[]) -> a
    void writeFloats(float[]) -> a
    void writeDoubles(double[]) -> a
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter$Chunk -> com.badlogic.gdx.graphics.a.b.a.a.d:
    int id -> a
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter$Chunk parent -> b
    com.badlogic.gdx.utils.Array children -> c
    java.io.ByteArrayOutputStream payload -> d
    java.io.DataOutputStream out -> e
    com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter this$0 -> f
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.CountingDataInputStream -> com.badlogic.gdx.graphics.a.b.a.a.e:
    int readBytes -> a
    java.io.DataInputStream in -> b
    int getReadBytes() -> a
    void readFully(byte[]) -> readFully
    void readFully(byte[],int,int) -> readFully
    int skipBytes(int) -> skipBytes
    boolean readBoolean() -> readBoolean
    byte readByte() -> readByte
    int readUnsignedByte() -> readUnsignedByte
    short readShort() -> readShort
    int readUnsignedShort() -> readUnsignedShort
    char readChar() -> readChar
    int readInt() -> readInt
    long readLong() -> readLong
    float readFloat() -> readFloat
    double readDouble() -> readDouble
    java.lang.String readLine() -> readLine
    java.lang.String readUTF() -> readUTF
com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.G3dExporter -> com.badlogic.gdx.graphics.a.b.a.a.f:
    void export(com.badlogic.gdx.graphics.g3d.model.still.StillModel,com.badlogic.gdx.files.FileHandle) -> a
    void export(com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel,com.badlogic.gdx.files.FileHandle) -> a
    void export(com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel,com.badlogic.gdx.files.FileHandle) -> a
    void writeSkeletonJoint(com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkWriter,com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint) -> a
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Frame -> com.badlogic.gdx.graphics.a.b.b.a:
    float[] vertices -> a
    int[] normalIndices -> b
    java.lang.String name -> c
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header -> com.badlogic.gdx.graphics.a.b.b.b:
    int ident -> a
    int version -> b
    int skinWidth -> c
    int skinHeight -> d
    int frameSize -> e
    int numSkins -> f
    int numVertices -> g
    int numTexCoords -> h
    int numTriangles -> i
    int numGLCommands -> j
    int numFrames -> k
    int offsetSkin -> l
    int offsetTexCoords -> m
    int offsetTriangles -> n
    int offsetFrames -> o
    int offsetGLCommands -> p
    int offsetEnd -> q
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader -> com.badlogic.gdx.graphics.a.b.b.c:
    byte[] charBuffer -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(com.badlogic.gdx.files.FileHandle,float) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel load(java.io.InputStream,float) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel buildModel(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Triangle[],float[],com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Frame[],float) -> a
    float[] buildTexCoords(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Triangle[],float[]) -> a
    short[] buildIndices(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Triangle[]) -> a
    com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Frame[] loadFrames(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,byte[]) -> a
    com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Frame loadFrame(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,com.badlogic.gdx.utils.LittleEndianInputStream) -> a
    com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Triangle[] loadTriangles(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,byte[]) -> b
    float[] loadTexCoords(com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header,byte[]) -> c
    com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Header loadHeader(byte[]) -> a
    byte[] loadBytes(java.io.InputStream) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader$MD2LoaderHints -> com.badlogic.gdx.graphics.a.b.b.d:
    float frameDuration -> b
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader$VertexIndices -> com.badlogic.gdx.graphics.a.b.b.e:
    short vIdx -> a
    short tIdx -> b
    short nIdx -> c
    com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader this$0 -> d
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Normals -> com.badlogic.gdx.graphics.a.b.b.f:
    float[][] normals -> a
com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Triangle -> com.badlogic.gdx.graphics.a.b.b.g:
    short[] vertices -> a
    short[] texCoords -> b
com.badlogic.gdx.graphics.g3d.loaders.wavefront.MtlLoader -> com.badlogic.gdx.graphics.a.b.c.a:
    java.util.ArrayList materials -> a
    com.badlogic.gdx.assets.AssetManager assetManager -> b
    com.badlogic.gdx.graphics.Texture emptyTexture -> c
    void load(java.lang.String,com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.materials.Material getMaterial(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader -> com.badlogic.gdx.graphics.a.b.c.b:
    com.badlogic.gdx.utils.FloatArray verts -> a
    com.badlogic.gdx.utils.FloatArray norms -> b
    com.badlogic.gdx.utils.FloatArray uvs -> c
    java.util.ArrayList groups -> d
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadObj(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadObj(com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillModel loadObj(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader$Group setActiveGroup(java.lang.String) -> a
    int getIndex(java.lang.String,int) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillModel load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> a
    com.badlogic.gdx.graphics.g3d.model.Model load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.ModelLoaderHints) -> b
com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader$Group -> com.badlogic.gdx.graphics.a.b.c.c:
    java.lang.String name -> a
    java.lang.String materialName -> b
    java.util.ArrayList faces -> c
    int numFaces -> d
    boolean hasNorms -> e
    boolean hasUVs -> f
    com.badlogic.gdx.graphics.g3d.materials.Material mat -> g
    com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader this$0 -> h
com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute -> com.badlogic.gdx.graphics.a.c.a:
    java.lang.String translucent -> a
    int blendSrcFunc -> b
    int blendDstFunc -> c
    com.badlogic.gdx.utils.Pool pool -> d
    void bind() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute copy() -> b
    void set(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute pooledCopy() -> c
    void free() -> d
com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute$1 -> com.badlogic.gdx.graphics.a.c.b:
    com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g3d.materials.ColorAttribute -> com.badlogic.gdx.graphics.a.c.c:
    java.lang.String diffuse -> a
    java.lang.String specular -> b
    java.lang.String emissive -> c
    java.lang.String rim -> d
    java.lang.String fog -> e
    com.badlogic.gdx.graphics.Color color -> f
    com.badlogic.gdx.utils.Pool pool -> i
    void bind() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute copy() -> b
    void set(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute pooledCopy() -> c
    void free() -> d
com.badlogic.gdx.graphics.g3d.materials.ColorAttribute$1 -> com.badlogic.gdx.graphics.a.c.d:
    com.badlogic.gdx.graphics.g3d.materials.ColorAttribute newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g3d.materials.Material -> com.badlogic.gdx.graphics.a.c.e:
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array attributes -> e
    boolean needBlending -> b
    boolean hasTexture -> c
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> d
    void checkAttributes() -> a
    void bind() -> b
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    java.lang.String getName() -> c
    void addAttribute(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute[]) -> a
    void removeAttribute(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute[]) -> b
    void clearAttributes() -> d
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute getAttribute(int) -> a
    int getNumberOfAttributes() -> e
    com.badlogic.gdx.graphics.g3d.materials.Material copy() -> f
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    boolean shaderEquals(com.badlogic.gdx.graphics.g3d.materials.Material) -> a
    void setPooled(com.badlogic.gdx.graphics.g3d.materials.Material) -> b
    boolean isNeedBlending() -> g
    boolean hasTexture() -> h
    com.badlogic.gdx.graphics.glutils.ShaderProgram getShader() -> i
    void setShader(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void resetShader() -> j
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute -> com.badlogic.gdx.graphics.a.c.f:
    java.lang.String FLAG -> a
    java.lang.String name -> g
    boolean isPooled -> h
    void bind() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute copy() -> b
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute pooledCopy() -> c
    void free() -> d
    void set(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute) -> a
    java.lang.String getShaderFlag() -> e
com.badlogic.gdx.graphics.g3d.materials.TextureAttribute -> com.badlogic.gdx.graphics.a.c.g:
    int MAX_TEXTURE_UNITS -> a
    java.lang.String diffuseTexture -> b
    java.lang.String lightmapTexture -> c
    java.lang.String specularTexture -> d
    com.badlogic.gdx.graphics.Texture texture -> e
    int unit -> f
    int minFilter -> i
    int magFilter -> j
    int uWrap -> k
    int vWrap -> l
    com.badlogic.gdx.utils.Pool pool -> m
    void bind() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute copy() -> b
    void set(com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute) -> a
    boolean texturePortionEquals(com.badlogic.gdx.graphics.g3d.materials.TextureAttribute) -> a
    com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute pooledCopy() -> c
    void free() -> d
com.badlogic.gdx.graphics.g3d.materials.TextureAttribute$1 -> com.badlogic.gdx.graphics.a.c.h:
    com.badlogic.gdx.graphics.g3d.materials.TextureAttribute newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.graphics.g3d.model.AnimatedModel -> com.badlogic.gdx.graphics.a.d.a:
    void setAnimation(java.lang.String,float,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.Animation getAnimation(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.Animation[] getAnimations() -> a
com.badlogic.gdx.graphics.g3d.model.Animation -> com.badlogic.gdx.graphics.a.d.b:
    java.lang.String name -> a
    float totalDuration -> b
com.badlogic.gdx.graphics.g3d.model.Model -> com.badlogic.gdx.graphics.a.d.c:
    void render() -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.model.Model getSubModel(java.lang.String[]) -> a
    com.badlogic.gdx.graphics.g3d.model.SubMesh getSubMesh(java.lang.String) -> b
    com.badlogic.gdx.graphics.g3d.model.SubMesh[] getSubMeshes() -> c
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    void setMaterials(com.badlogic.gdx.graphics.g3d.materials.Material[]) -> a
    void setMaterial(com.badlogic.gdx.graphics.g3d.materials.Material) -> a
    void dispose() -> e
com.badlogic.gdx.graphics.g3d.model.SubMesh -> com.badlogic.gdx.graphics.a.d.d:
    java.lang.String name -> a
    com.badlogic.gdx.graphics.g3d.materials.Material material -> b
    int primitiveType -> c
    com.badlogic.gdx.graphics.Mesh mesh -> d
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    com.badlogic.gdx.graphics.Mesh getMesh() -> a
    void setMesh(com.badlogic.gdx.graphics.Mesh) -> a
com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe -> com.badlogic.gdx.graphics.a.d.a.a:
    float timeStamp -> a
    float[] vertices -> b
com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation -> com.badlogic.gdx.graphics.a.d.a.b:
    float frameDuration -> c
    com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe[] keyframes -> d
com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel -> com.badlogic.gdx.graphics.a.d.a.c:
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh[] subMeshes -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation[] animations -> b
    com.badlogic.gdx.math.collision.BoundingBox tmpBox -> c
    void checkValidity() -> f
    void render() -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void setMaterials(com.badlogic.gdx.graphics.g3d.materials.Material[]) -> a
    void setMaterial(com.badlogic.gdx.graphics.g3d.materials.Material) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh getSubMesh(java.lang.String) -> c
    com.badlogic.gdx.graphics.g3d.model.SubMesh[] getSubMeshes() -> c
    void setAnimation(java.lang.String,float,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation getAnimation(java.lang.String) -> d
    com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation[] getAnimations() -> d
    com.badlogic.gdx.graphics.g3d.model.Model getSubModel(java.lang.String[]) -> a
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    void dispose() -> e
    com.badlogic.gdx.graphics.g3d.model.Animation[] getAnimations() -> a
    com.badlogic.gdx.graphics.g3d.model.Animation getAnimation(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.SubMesh getSubMesh(java.lang.String) -> b
com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh -> com.badlogic.gdx.graphics.a.d.a.d:
    float[] blendedVertices -> e
    int animatedComponents -> f
    com.badlogic.gdx.utils.ObjectMap animations -> g
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
com.badlogic.gdx.graphics.g3d.model.skeleton.Skeleton -> com.badlogic.gdx.graphics.a.d.b.a:
    com.badlogic.gdx.utils.Array hierarchy -> a
    com.badlogic.gdx.utils.Array jointNames -> b
    java.util.Map namesToIndices -> c
    com.badlogic.gdx.utils.Array bindPoseJoints -> d
    com.badlogic.gdx.utils.Array animPoseJoints -> e
    com.badlogic.gdx.utils.Array offsetMatrices -> f
    com.badlogic.gdx.utils.Array sceneMatrices -> g
    com.badlogic.gdx.utils.Array combinedMatrices -> h
    com.badlogic.gdx.utils.ObjectMap animations -> i
    com.badlogic.gdx.math.Matrix4 IDENTITY -> j
    com.badlogic.gdx.math.Matrix4 rotMatrix -> k
    void buildFromHierarchy() -> a
    void recursiveFill(com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint) -> a
    void calculateOffsetMatrices() -> b
    void calculateMatrices(com.badlogic.gdx.utils.Array) -> a
    void setAnimation(java.lang.String,float) -> a
    void setBindPose() -> c
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation -> com.badlogic.gdx.graphics.a.d.b.b:
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonKeyframe[][] perJointkeyFrames -> c
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint -> com.badlogic.gdx.graphics.a.d.b.c:
    java.lang.String name -> a
    int index -> b
    int parentIndex -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint parent -> d
    com.badlogic.gdx.utils.Array children -> e
    com.badlogic.gdx.math.Vector3 position -> f
    com.badlogic.gdx.math.Quaternion rotation -> g
    com.badlogic.gdx.math.Vector3 scale -> h
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonKeyframe -> com.badlogic.gdx.graphics.a.d.b.d:
    float timeStamp -> a
    int parentIndex -> b
    com.badlogic.gdx.math.Vector3 position -> c
    com.badlogic.gdx.math.Vector3 scale -> d
    com.badlogic.gdx.math.Quaternion rotation -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel -> com.badlogic.gdx.graphics.a.d.b.e:
    com.badlogic.gdx.graphics.g3d.model.skeleton.Skeleton skeleton -> a
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh[] subMeshes -> b
    com.badlogic.gdx.math.Vector3 v -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation[] animations -> d
    com.badlogic.gdx.math.collision.BoundingBox tmpBox -> e
    void setBindPose() -> d
    void setAnimation(java.lang.String,float,boolean) -> a
    void skin(com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh,com.badlogic.gdx.utils.Array) -> a
    void render() -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void setMaterials(com.badlogic.gdx.graphics.g3d.materials.Material[]) -> a
    void setMaterial(com.badlogic.gdx.graphics.g3d.materials.Material) -> a
    com.badlogic.gdx.graphics.g3d.model.SubMesh getSubMesh(java.lang.String) -> b
    com.badlogic.gdx.graphics.g3d.model.SubMesh[] getSubMeshes() -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation getAnimation(java.lang.String) -> c
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation[] getAnimations() -> f
    com.badlogic.gdx.graphics.g3d.model.Model getSubModel(java.lang.String[]) -> a
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    void dispose() -> e
    com.badlogic.gdx.graphics.g3d.model.Animation[] getAnimations() -> a
    com.badlogic.gdx.graphics.g3d.model.Animation getAnimation(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModelGpuSkinned -> com.badlogic.gdx.graphics.a.d.b.f:
    java.lang.String BoneIndexAttribue -> e
    java.lang.String BoneWeightAttribue -> f
    com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel CreateFromSkeletonModel(com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel) -> a
    void setupGpuSkin() -> g
    void setupGpuSkin(com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh) -> a
    void setAnimation(java.lang.String,float,boolean) -> a
com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh -> com.badlogic.gdx.graphics.a.d.b.g:
    short[] indices -> e
    float[] vertices -> f
    float[] skinnedVertices -> g
    int[][] boneAssignments -> h
    float[][] boneWeights -> i
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    void setVertices(float[]) -> a
    void setIndices(short[]) -> a
com.badlogic.gdx.graphics.g3d.model.still.StillModel -> com.badlogic.gdx.graphics.a.d.c.a:
    com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh[] subMeshes -> a
    com.badlogic.gdx.math.collision.BoundingBox tmpBox -> b
    void render() -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    com.badlogic.gdx.graphics.g3d.model.Model getSubModel(java.lang.String[]) -> a
    com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh getSubMesh(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.SubMesh[] getSubMeshes() -> c
    void setMaterials(com.badlogic.gdx.graphics.g3d.materials.Material[]) -> a
    void setMaterial(com.badlogic.gdx.graphics.g3d.materials.Material) -> a
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
    void dispose() -> e
    com.badlogic.gdx.graphics.g3d.model.SubMesh getSubMesh(java.lang.String) -> b
com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh -> com.badlogic.gdx.graphics.a.d.c.b:
    void getBoundingBox(com.badlogic.gdx.math.collision.BoundingBox) -> a
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int PKM_HEADER_SIZE -> a
    int ETC1_RGB8_OES -> b
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data encodeImage(com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data encodeImagePKM(com.badlogic.gdx.graphics.Pixmap) -> b
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getCompressedDataSize(int,int) -> getCompressedDataSize
    void formatHeader(java.nio.ByteBuffer,int,int,int) -> formatHeader
    int getWidthPKM(java.nio.ByteBuffer,int) -> getWidthPKM
    int getHeightPKM(java.nio.ByteBuffer,int) -> getHeightPKM
    boolean isValidPKM(java.nio.ByteBuffer,int) -> isValidPKM
    void decodeImage(java.nio.ByteBuffer,int,java.nio.ByteBuffer,int,int,int,int) -> decodeImage
    java.nio.ByteBuffer encodeImage(java.nio.ByteBuffer,int,int,int,int) -> encodeImage
    java.nio.ByteBuffer encodeImagePKM(java.nio.ByteBuffer,int,int,int,int) -> encodeImagePKM
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.a:
    int width -> a
    int height -> b
    java.nio.ByteBuffer compressedData -> c
    int dataOffset -> d
    void checkNPOT() -> b
    boolean hasPKMHeader() -> a
    void write(com.badlogic.gdx.files.FileHandle) -> a
    void dispose() -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.b:
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    boolean useMipMaps -> c
    int width -> d
    int height -> e
    boolean isPrepared -> f
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    void consumeCompressedData() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> g
    int getHeight() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    boolean useMipMaps() -> j
    boolean isManaged() -> k
com.badlogic.gdx.graphics.glutils.FileTextureData -> com.badlogic.gdx.graphics.glutils.c:
    boolean copyToPOT -> a
    com.badlogic.gdx.files.FileHandle file -> b
    int width -> c
    int height -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    com.badlogic.gdx.graphics.Pixmap pixmap -> f
    boolean useMipMaps -> g
    boolean isPrepared -> h
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap ensurePot(com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> g
    int getHeight() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    boolean useMipMaps() -> j
    boolean isManaged() -> k
    com.badlogic.gdx.files.FileHandle getFileHandle() -> l
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCompressedData() -> f
com.badlogic.gdx.graphics.glutils.FloatFrameBuffer -> com.badlogic.gdx.graphics.glutils.d:
    void setupTexture() -> a
com.badlogic.gdx.graphics.glutils.FloatTextureData -> com.badlogic.gdx.graphics.glutils.e:
    int width -> a
    int height -> b
    boolean isPrepared -> c
    java.nio.FloatBuffer buffer -> d
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    void consumeCompressedData() -> f
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> g
    int getHeight() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    boolean useMipMaps() -> j
    boolean isManaged() -> k
com.badlogic.gdx.graphics.glutils.FrameBuffer -> com.badlogic.gdx.graphics.glutils.f:
    java.util.Map buffers -> f
    com.badlogic.gdx.graphics.Texture colorTexture -> a
    int defaultFramebufferHandle -> g
    boolean defaultFramebufferHandleInitialized -> h
    int framebufferHandle -> i
    int depthbufferHandle -> j
    int width -> b
    int height -> c
    boolean hasDepth -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    void setupTexture() -> a
    void build() -> i
    void dispose() -> e
    void begin() -> b
    void end() -> c
    void addManagedFrameBuffer(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.FrameBuffer) -> a
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> a
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> d
    com.badlogic.gdx.graphics.Texture getColorBufferTexture() -> f
    int getHeight() -> g
    int getWidth() -> h
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> com.badlogic.gdx.graphics.glutils.g:
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(float,float,float,float) -> a
    void texCoord(float,float) -> a
    void normal(float,float,float) -> a
    void vertex(float,float,float) -> b
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer10 -> com.badlogic.gdx.graphics.glutils.h:
    int primitiveType -> a
    float[] positions -> b
    java.nio.FloatBuffer positionsBuffer -> c
    float[] colors -> d
    java.nio.FloatBuffer colorsBuffer -> e
    float[] normals -> f
    java.nio.FloatBuffer normalsBuffer -> g
    float[] texCoords -> h
    java.nio.FloatBuffer texCoordsBuffer -> i
    int idxPos -> j
    int idxCols -> k
    int idxNors -> l
    int idxTexCoords -> m
    boolean hasCols -> n
    boolean hasNors -> o
    boolean hasTexCoords -> p
    int maxVertices -> q
    int numVertices -> r
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void begin(int) -> a
    void color(float,float,float,float) -> a
    void normal(float,float,float) -> a
    void texCoord(float,float) -> a
    void vertex(float,float,float) -> b
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void end() -> a
    void vertex(com.badlogic.gdx.math.Vector3) -> a
    void dispose() -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> com.badlogic.gdx.graphics.glutils.i:
    int primitiveType -> a
    int vertexIdx -> b
    int numSetTexCoords -> c
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    boolean ownsShader -> h
    int numTexCoords -> i
    int vertexSize -> j
    int normalOffset -> k
    int colorOffset -> l
    int texCoordOffset -> m
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    float[] vertices -> o
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> b
    void setShader(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(float,float,float,float) -> a
    void texCoord(float,float) -> a
    void normal(float,float,float) -> a
    void vertex(float,float,float) -> b
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
    java.lang.String createVertexShader(boolean,boolean,int) -> c
    java.lang.String createFragmentShader(boolean,boolean,int) -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> a
com.badlogic.gdx.graphics.glutils.IndexArray -> com.badlogic.gdx.graphics.glutils.j:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> c
    void bind() -> d
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> com.badlogic.gdx.graphics.glutils.k:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> c
    void bind() -> d
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.l:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> c
    void bind() -> d
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.IndexData -> com.badlogic.gdx.graphics.glutils.m:
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> c
    void bind() -> d
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> com.badlogic.gdx.graphics.glutils.n:
    boolean useHWMipMap -> a
    void setUseHardwareMipMap(boolean) -> a
    void generateMipMap(com.badlogic.gdx.graphics.Pixmap,int,int,boolean) -> a
    void generateMipMapGLES20(com.badlogic.gdx.graphics.Pixmap,boolean) -> a
    void generateMipMapDesktop(com.badlogic.gdx.graphics.Pixmap,int,int,boolean) -> b
    void generateMipMapCPU(com.badlogic.gdx.graphics.Pixmap,int,int,boolean) -> c
com.badlogic.gdx.graphics.glutils.PixmapTextureData -> com.badlogic.gdx.graphics.glutils.o:
    com.badlogic.gdx.graphics.Pixmap pixmap -> b
    com.badlogic.gdx.graphics.Pixmap$Format format -> c
    boolean useMipMaps -> d
    boolean disposePixmap -> e
    boolean disposePixmap() -> e
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    int getWidth() -> g
    int getHeight() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    boolean useMipMaps() -> j
    boolean isManaged() -> k
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCompressedData() -> f
    boolean isPrepared() -> b
    void prepare() -> c
com.badlogic.gdx.graphics.glutils.ShaderProgram -> com.badlogic.gdx.graphics.glutils.p:
    java.lang.String POSITION_ATTRIBUTE -> a
    java.lang.String NORMAL_ATTRIBUTE -> b
    java.lang.String COLOR_ATTRIBUTE -> c
    java.lang.String TEXCOORD_ATTRIBUTE -> d
    java.lang.String TANGENT_ATTRIBUTE -> e
    java.lang.String BINORMAL_ATTRIBUTE -> f
    boolean pedantic -> g
    com.badlogic.gdx.utils.ObjectMap shaders -> k
    java.lang.String log -> l
    boolean isCompiled -> m
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> n
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> o
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> p
    java.lang.String[] uniformNames -> q
    com.badlogic.gdx.utils.ObjectIntMap attributes -> r
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> s
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> t
    java.lang.String[] attributeNames -> u
    int program -> v
    int vertexShaderHandle -> w
    int fragmentShaderHandle -> x
    java.nio.FloatBuffer matrix -> y
    java.lang.String vertexShaderSource -> z
    java.lang.String fragmentShaderSource -> A
    boolean invalidated -> B
    java.nio.ByteBuffer buffer -> C
    java.nio.FloatBuffer floatBuffer -> D
    java.nio.IntBuffer intBuffer -> E
    int refCount -> F
    java.nio.IntBuffer intbuf -> h
    java.nio.IntBuffer params -> i
    java.nio.IntBuffer type -> j
    void compileShaders(java.lang.String,java.lang.String) -> a
    int loadShader(int,java.lang.String) -> a
    int linkProgram() -> i
    java.lang.String getLog() -> a
    boolean isCompiled() -> b
    int fetchAttributeLocation(java.lang.String) -> k
    int fetchUniformLocation(java.lang.String) -> l
    void setUniformi(java.lang.String,int) -> a
    void setUniformi(int,int) -> a
    void setUniformi(java.lang.String,int,int) -> a
    void setUniformi(int,int,int) -> a
    void setUniformi(java.lang.String,int,int,int) -> a
    void setUniformi(int,int,int,int) -> a
    void setUniformi(java.lang.String,int,int,int,int) -> a
    void setUniformi(int,int,int,int,int) -> a
    void setUniformf(java.lang.String,float) -> a
    void setUniformf(int,float) -> a
    void setUniformf(java.lang.String,float,float) -> a
    void setUniformf(int,float,float) -> a
    void setUniformf(java.lang.String,float,float,float) -> a
    void setUniformf(int,float,float,float) -> a
    void setUniformf(java.lang.String,float,float,float,float) -> a
    void setUniformf(int,float,float,float,float) -> a
    void setUniform1fv(java.lang.String,float[],int,int) -> a
    void setUniform1fv(int,float[],int,int) -> a
    void setUniform2fv(java.lang.String,float[],int,int) -> b
    void setUniform2fv(int,float[],int,int) -> b
    void setUniform3fv(java.lang.String,float[],int,int) -> c
    void setUniform3fv(int,float[],int,int) -> c
    void setUniform4fv(java.lang.String,float[],int,int) -> d
    void setUniform4fv(int,float[],int,int) -> d
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4) -> a
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix3) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix3,boolean) -> a
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix3) -> a
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix3,boolean) -> a
    void setUniformMatrix4fv(java.lang.String,java.nio.FloatBuffer,int,boolean) -> a
    void setUniformf(java.lang.String,com.badlogic.gdx.math.Vector2) -> a
    void setUniformf(int,com.badlogic.gdx.math.Vector2) -> a
    void setUniformf(java.lang.String,com.badlogic.gdx.math.Vector3) -> a
    void setUniformf(int,com.badlogic.gdx.math.Vector3) -> a
    void setUniformf(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    void setUniformf(int,com.badlogic.gdx.graphics.Color) -> a
    void setVertexAttribute(java.lang.String,int,int,boolean,int,java.nio.Buffer) -> a
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> a
    void setVertexAttribute(java.lang.String,int,int,boolean,int,int) -> a
    void setVertexAttribute(int,int,int,boolean,int,int) -> a
    void begin() -> c
    void end() -> d
    void dispose() -> e
    void disableVertexAttribute(java.lang.String) -> a
    void disableVertexAttribute(int) -> a
    void enableVertexAttribute(java.lang.String) -> b
    void enableVertexAttribute(int) -> b
    void checkManaged() -> j
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> a
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> f
    void setAttributef(java.lang.String,float,float,float,float) -> b
    void ensureBufferCapacity(int) -> c
    void fetchUniforms() -> k
    void fetchAttributes() -> l
    boolean hasAttribute(java.lang.String) -> c
    int getAttributeType(java.lang.String) -> d
    int getAttributeLocation(java.lang.String) -> e
    int getAttributeSize(java.lang.String) -> f
    boolean hasUniform(java.lang.String) -> g
    int getUniformType(java.lang.String) -> h
    int getUniformLocation(java.lang.String) -> i
    int getUniformSize(java.lang.String) -> j
    java.lang.String[] getAttributes() -> g
    java.lang.String[] getUniforms() -> h
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> com.badlogic.gdx.graphics.glutils.q:
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.math.Matrix4 projView -> c
    com.badlogic.gdx.math.Matrix4 transform -> d
    com.badlogic.gdx.math.Matrix4 combined -> e
    com.badlogic.gdx.math.Matrix4 tmp -> f
    com.badlogic.gdx.graphics.Color color -> g
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType currType -> h
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> a
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void identity() -> a
    void translate(float,float,float) -> a
    void rotate(float,float,float,float) -> b
    void scale(float,float,float) -> b
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> a
    void point(float,float,float) -> c
    void line(float,float,float,float,float,float) -> a
    void line(float,float,float,float) -> c
    void curve(float,float,float,float,float,float,float,float,int) -> a
    void triangle(float,float,float,float,float,float) -> b
    void rect(float,float,float,float) -> d
    void rect(float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> a
    void box(float,float,float,float,float,float) -> c
    void circle(float,float,float) -> d
    void circle(float,float,float,int) -> a
    void ellipse(float,float,float,float) -> e
    void ellipse(float,float,float,float,int) -> a
    void cone(float,float,float,float,float) -> a
    void cone(float,float,float,float,float,int) -> a
    void polygon(float[]) -> a
    void polyline(float[]) -> b
    void checkDirty() -> f
    void checkFlush(int) -> a
    void end() -> b
    void flush() -> c
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType getCurrentType() -> d
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> com.badlogic.gdx.graphics.glutils.r:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> a
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> c
    int glType -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] values() -> values
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType valueOf(java.lang.String) -> valueOf
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> com.badlogic.gdx.graphics.glutils.s:
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    boolean isBound -> d
    void dispose() -> e
    java.nio.FloatBuffer getBuffer() -> a
    int getNumVertices() -> b
    int getNumMaxVertices() -> c
    void setVertices(float[],int,int) -> a
    void bind() -> d
    void unbind() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> com.badlogic.gdx.graphics.glutils.t:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isStatic -> f
    int usage -> g
    boolean isDirty -> h
    boolean isBound -> i
    int createBufferObject() -> i
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
    int getNumVertices() -> b
    int getNumMaxVertices() -> c
    java.nio.FloatBuffer getBuffer() -> a
    void setVertices(float[],int,int) -> a
    void bind() -> d
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void unbind() -> f
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void invalidate() -> h
    void dispose() -> e
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.u:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isDirect -> f
    boolean isStatic -> g
    int usage -> h
    boolean isDirty -> i
    boolean isBound -> j
    int createBufferObject() -> j
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
    int getNumVertices() -> b
    int getNumMaxVertices() -> c
    java.nio.FloatBuffer getBuffer() -> a
    void setVertices(float[],int,int) -> a
    void bind() -> d
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void unbind() -> f
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void invalidate() -> h
    void dispose() -> e
    int getBufferHandle() -> i
com.badlogic.gdx.graphics.glutils.VertexData -> com.badlogic.gdx.graphics.glutils.v:
    int getNumVertices() -> b
    int getNumMaxVertices() -> c
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> g
    void setVertices(float[],int,int) -> a
    java.nio.FloatBuffer getBuffer() -> a
    void bind() -> d
    void unbind() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void dispose() -> e
com.badlogic.gdx.input.GestureDetector -> com.badlogic.gdx.e.a:
    com.badlogic.gdx.input.GestureDetector$GestureListener listener -> a
    float tapSquareSize -> d
    long tapCountInterval -> e
    float longPressSeconds -> f
    long maxFlingDelay -> g
    boolean inTapSquare -> h
    int tapCount -> i
    long lastTapTime -> j
    float lastTapX -> k
    float lastTapY -> l
    int lastTapButton -> m
    int lastTapPointer -> n
    boolean longPressFired -> b
    boolean pinching -> o
    boolean panning -> p
    com.badlogic.gdx.input.GestureDetector$VelocityTracker tracker -> q
    float tapSquareCenterX -> r
    float tapSquareCenterY -> s
    long gestureStartTime -> t
    com.badlogic.gdx.math.Vector2 pointer1 -> c
    com.badlogic.gdx.math.Vector2 pointer2 -> u
    com.badlogic.gdx.math.Vector2 initialPointer1 -> v
    com.badlogic.gdx.math.Vector2 initialPointer2 -> w
    com.badlogic.gdx.utils.Timer$Task longPressTask -> x
    boolean touchDown(int,int,int,int) -> a
    boolean touchDown(float,float,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean touchDragged(float,float,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchUp(float,float,int,int) -> b
    boolean isLongPressed() -> a
    boolean isLongPressed(float) -> a
    boolean isPanning() -> b
    void reset() -> c
    boolean isWithinTapSquare(float,float,float,float) -> a
    void invalidateTapSquare() -> d
    void setTapSquareSize(int) -> d
    void setTapCountInterval(float) -> b
    void setLongPressSeconds(float) -> c
    void setMaxFlingDelay(long) -> a
com.badlogic.gdx.input.GestureDetector$1 -> com.badlogic.gdx.e.b:
    com.badlogic.gdx.input.GestureDetector this$0 -> a
    void run() -> run
com.badlogic.gdx.input.GestureDetector$GestureAdapter -> com.badlogic.gdx.e.c:
    boolean touchDown(float,float,int,int) -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.input.GestureDetector$GestureListener -> com.badlogic.gdx.e.d:
    boolean touchDown(float,float,int,int) -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.input.GestureDetector$VelocityTracker -> com.badlogic.gdx.e.e:
    int sampleSize -> a
    float lastX -> b
    float lastY -> c
    float deltaX -> d
    float deltaY -> e
    long lastTime -> f
    int numSamples -> g
    float[] meanX -> h
    float[] meanY -> i
    long[] meanTime -> j
    void start(float,float,long) -> a
    void update(float,float,long) -> b
    float getVelocityX() -> a
    float getVelocityY() -> b
    float getAverage(float[],int) -> a
    long getAverage(long[],int) -> a
    float getSum(float[],int) -> b
com.badlogic.gdx.input.RemoteInput -> com.badlogic.gdx.e.f:
    int DEFAULT_PORT -> a
    java.net.ServerSocket serverSocket -> i
    float[] accel -> j
    float[] compass -> k
    boolean multiTouch -> l
    float remoteWidth -> m
    float remoteHeight -> n
    boolean connected -> o
    com.badlogic.gdx.input.RemoteInput$RemoteInputListener listener -> p
    java.util.Set keys -> b
    int[] touchX -> c
    int[] touchY -> d
    boolean[] isTouched -> e
    boolean justTouched -> f
    com.badlogic.gdx.InputProcessor processor -> g
    int port -> q
    java.lang.String[] ips -> h
    void run() -> run
    boolean isConnected() -> s
    float getAccelerometerX() -> a
    float getAccelerometerY() -> b
    float getAccelerometerZ() -> c
    int getX() -> d
    int getX(int) -> a
    int getY() -> f
    int getY(int) -> c
    boolean isTouched() -> h
    boolean justTouched() -> i
    boolean isTouched(int) -> e
    boolean isButtonPressed(int) -> f
    boolean isKeyPressed(int) -> g
    void getTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> a
    void getPlaceholderTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String) -> b
    void setOnscreenKeyboardVisible(boolean) -> a
    void vibrate(int) -> h
    void vibrate(long[],int) -> a
    void cancelVibrate() -> j
    float getAzimuth() -> k
    float getPitch() -> l
    float getRoll() -> m
    void setCatchBackKey(boolean) -> b
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    com.badlogic.gdx.InputProcessor getInputProcessor() -> o
    java.lang.String[] getIPs() -> t
    boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral) -> a
    int getRotation() -> p
    com.badlogic.gdx.Input$Orientation getNativeOrientation() -> q
    void setCursorCatched(boolean) -> d
    boolean isCursorCatched() -> r
    int getDeltaX() -> e
    int getDeltaX(int) -> b
    int getDeltaY() -> g
    int getDeltaY(int) -> d
    void setCursorPosition(int,int) -> a
    void setCatchMenuKey(boolean) -> c
    long getCurrentEventTime() -> n
    void getRotationMatrix(float[]) -> a
com.badlogic.gdx.input.RemoteInput$EventTrigger -> com.badlogic.gdx.e.g:
    com.badlogic.gdx.input.RemoteInput$TouchEvent touchEvent -> a
    com.badlogic.gdx.input.RemoteInput$KeyEvent keyEvent -> b
    com.badlogic.gdx.input.RemoteInput this$0 -> c
    void run() -> run
com.badlogic.gdx.input.RemoteInput$KeyEvent -> com.badlogic.gdx.e.h:
    int KEY_DOWN -> a
    int KEY_UP -> b
    int KEY_TYPED -> c
    long timeStamp -> d
    int type -> e
    int keyCode -> f
    char keyChar -> g
    com.badlogic.gdx.input.RemoteInput this$0 -> h
com.badlogic.gdx.input.RemoteInput$RemoteInputListener -> com.badlogic.gdx.e.i:
    void onConnected() -> a
    void onDisconnected() -> b
com.badlogic.gdx.input.RemoteInput$TouchEvent -> com.badlogic.gdx.e.j:
    int TOUCH_DOWN -> a
    int TOUCH_UP -> b
    int TOUCH_DRAGGED -> c
    long timeStamp -> d
    int type -> e
    int x -> f
    int y -> g
    int pointer -> h
    com.badlogic.gdx.input.RemoteInput this$0 -> i
com.badlogic.gdx.input.RemoteSender -> com.badlogic.gdx.e.k:
    java.io.DataOutputStream out -> j
    boolean connected -> k
    int KEY_DOWN -> a
    int KEY_UP -> b
    int KEY_TYPED -> c
    int TOUCH_DOWN -> d
    int TOUCH_UP -> e
    int TOUCH_DRAGGED -> f
    int ACCEL -> g
    int COMPASS -> h
    int SIZE -> i
    void sendUpdate() -> a
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
    boolean isConnected() -> b
com.badlogic.gdx.maps.ImageResolver -> com.badlogic.gdx.f.a:
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.ImageResolver$AssetManagerImageResolver -> com.badlogic.gdx.f.b:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.ImageResolver$DirectImageResolver -> com.badlogic.gdx.f.c:
    com.badlogic.gdx.utils.ObjectMap images -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.ImageResolver$TextureAtlasImageResolver -> com.badlogic.gdx.f.d:
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.Map -> com.badlogic.gdx.f.e:
    com.badlogic.gdx.maps.MapLayers layers -> a
    com.badlogic.gdx.maps.MapProperties properties -> b
    com.badlogic.gdx.maps.MapLayers getLayers() -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> b
    void dispose() -> e
com.badlogic.gdx.maps.MapLayer -> com.badlogic.gdx.f.f:
    java.lang.String name -> a
    float opacity -> b
    boolean visible -> c
    com.badlogic.gdx.maps.MapObjects objects -> d
    com.badlogic.gdx.maps.MapProperties properties -> e
    java.lang.String getName() -> a
    void setName(java.lang.String) -> a
    float getOpacity() -> b
    void setOpacity(float) -> a
    com.badlogic.gdx.maps.MapObjects getObjects() -> c
    boolean isVisible() -> d
    void setVisible(boolean) -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
com.badlogic.gdx.maps.MapLayers -> com.badlogic.gdx.f.g:
    com.badlogic.gdx.utils.Array layers -> a
    com.badlogic.gdx.maps.MapLayer get(int) -> a
    com.badlogic.gdx.maps.MapLayer get(java.lang.String) -> a
    int getCount() -> a
    void add(com.badlogic.gdx.maps.MapLayer) -> a
    void remove(int) -> b
    void remove(com.badlogic.gdx.maps.MapLayer) -> b
    com.badlogic.gdx.utils.Array getByType(java.lang.Class) -> a
    com.badlogic.gdx.utils.Array getByType(java.lang.Class,com.badlogic.gdx.utils.Array) -> a
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.maps.MapObject -> com.badlogic.gdx.f.h:
    java.lang.String name -> a
    float opacity -> b
    boolean visible -> c
    com.badlogic.gdx.maps.MapProperties properties -> d
    com.badlogic.gdx.graphics.Color color -> e
    java.lang.String getName() -> a
    void setName(java.lang.String) -> a
    com.badlogic.gdx.graphics.Color getColor() -> b
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    float getOpacity() -> c
    void setOpacity(float) -> a
    boolean isVisible() -> d
    void setVisible(boolean) -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
com.badlogic.gdx.maps.MapObjects -> com.badlogic.gdx.f.i:
    com.badlogic.gdx.utils.Array objects -> a
    com.badlogic.gdx.maps.MapObject get(int) -> a
    com.badlogic.gdx.maps.MapObject get(java.lang.String) -> a
    void add(com.badlogic.gdx.maps.MapObject) -> a
    void remove(int) -> b
    void remove(com.badlogic.gdx.maps.MapObject) -> b
    int getCount() -> a
    com.badlogic.gdx.utils.Array getByType(java.lang.Class) -> a
    com.badlogic.gdx.utils.Array getByType(java.lang.Class,com.badlogic.gdx.utils.Array) -> a
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.maps.MapProperties -> com.badlogic.gdx.f.j:
    com.badlogic.gdx.utils.ObjectMap properties -> a
    boolean containsKey(java.lang.String) -> a
    java.lang.Object get(java.lang.String) -> b
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Object,java.lang.Class) -> a
    void put(java.lang.String,java.lang.Object) -> a
    void putAll(com.badlogic.gdx.maps.MapProperties) -> a
    void remove(java.lang.String) -> c
    void clear() -> a
    java.util.Iterator getKeys() -> b
    java.util.Iterator getValues() -> c
com.badlogic.gdx.maps.MapRenderer -> com.badlogic.gdx.f.k:
    void setView(com.badlogic.gdx.graphics.OrthographicCamera) -> a
    void setView(com.badlogic.gdx.math.Matrix4,float,float,float,float) -> a
    void render() -> a
    void render(int[]) -> a
com.badlogic.gdx.maps.objects.CircleMapObject -> com.badlogic.gdx.f.a.a:
    com.badlogic.gdx.math.Circle circle -> a
    com.badlogic.gdx.math.Circle getCircle() -> f
com.badlogic.gdx.maps.objects.EllipseMapObject -> com.badlogic.gdx.f.a.b:
    com.badlogic.gdx.math.Ellipse ellipse -> a
    com.badlogic.gdx.math.Ellipse getEllipse() -> f
com.badlogic.gdx.maps.objects.PolygonMapObject -> com.badlogic.gdx.f.a.c:
    com.badlogic.gdx.math.Polygon polygon -> a
    com.badlogic.gdx.math.Polygon getPolygon() -> f
    void setPolygon(com.badlogic.gdx.math.Polygon) -> a
com.badlogic.gdx.maps.objects.PolylineMapObject -> com.badlogic.gdx.f.a.d:
    com.badlogic.gdx.math.Polyline polyline -> a
    com.badlogic.gdx.math.Polyline getPolyline() -> f
    void setPolyline(com.badlogic.gdx.math.Polyline) -> a
com.badlogic.gdx.maps.objects.RectangleMapObject -> com.badlogic.gdx.f.a.e:
    com.badlogic.gdx.math.Rectangle rectangle -> a
    com.badlogic.gdx.math.Rectangle getRectangle() -> f
com.badlogic.gdx.maps.objects.TextureMapObject -> com.badlogic.gdx.f.a.f:
    float x -> a
    float y -> b
    float originX -> c
    float originY -> d
    float scaleX -> e
    float scaleY -> f
    float rotation -> g
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> h
    float getX() -> f
    void setX(float) -> b
    float getY() -> g
    void setY(float) -> c
    float getOriginX() -> h
    void setOriginX(float) -> d
    float getOriginY() -> i
    void setOriginY(float) -> e
    float getScaleX() -> j
    void setScaleX(float) -> f
    float getScaleY() -> k
    void setScaleY(float) -> g
    float getRotation() -> l
    void setRotation(float) -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> m
    void setTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
com.badlogic.gdx.maps.tiled.TideMapLoader -> com.badlogic.gdx.f.b.a:
    com.badlogic.gdx.utils.XmlReader xml -> a
    com.badlogic.gdx.utils.XmlReader$Element root -> b
    com.badlogic.gdx.maps.tiled.TiledMap load(java.lang.String) -> b
    com.badlogic.gdx.maps.tiled.TiledMap load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.maps.tiled.TideMapLoader$Parameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.maps.tiled.TideMapLoader$Parameters) -> a
    com.badlogic.gdx.maps.tiled.TiledMap loadMap(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> a
    com.badlogic.gdx.utils.Array loadTileSheets(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle) -> a
    void loadTileSheet(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> a
    void loadLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.utils.XmlReader$Element) -> a
    void loadProperties(com.badlogic.gdx.maps.MapProperties,com.badlogic.gdx.utils.XmlReader$Element) -> a
    com.badlogic.gdx.files.FileHandle getRelativeFileHandle(com.badlogic.gdx.files.FileHandle,java.lang.String) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.maps.tiled.TideMapLoader$Parameters -> com.badlogic.gdx.f.b.b:
com.badlogic.gdx.maps.tiled.TiledMap -> com.badlogic.gdx.f.b.c:
    com.badlogic.gdx.maps.tiled.TiledMapTileSets tilesets -> a
    com.badlogic.gdx.utils.Array ownedTextures -> b
    com.badlogic.gdx.maps.tiled.TiledMapTileSets getTileSets() -> c
    void setOwnedTextures(com.badlogic.gdx.utils.Array) -> a
    void dispose() -> e
com.badlogic.gdx.maps.tiled.TiledMapRenderer -> com.badlogic.gdx.f.b.d:
    void renderObject(com.badlogic.gdx.maps.MapObject) -> a
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> a
com.badlogic.gdx.maps.tiled.TiledMapTile -> com.badlogic.gdx.f.b.e:
    int getId() -> a
    void setId(int) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode getBlendMode() -> b
    void setBlendMode(com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> c
    com.badlogic.gdx.maps.MapProperties getProperties() -> d
com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode -> com.badlogic.gdx.f.b.f:
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode NONE -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode ALPHA -> b
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode[] $VALUES -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode[] values() -> values
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.maps.tiled.TiledMapTileLayer -> com.badlogic.gdx.f.b.g:
    int width -> a
    int height -> b
    float tileWidth -> c
    float tileHeight -> d
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell[][] cells -> e
    int getWidth() -> f
    int getHeight() -> g
    float getTileWidth() -> h
    float getTileHeight() -> i
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell getCell(int,int) -> a
    void setCell(int,int,com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell) -> a
com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell -> com.badlogic.gdx.f.b.h:
    com.badlogic.gdx.maps.tiled.TiledMapTile tile -> e
    boolean flipHorizontally -> f
    boolean flipVertically -> g
    int rotation -> h
    int ROTATE_0 -> a
    int ROTATE_90 -> b
    int ROTATE_180 -> c
    int ROTATE_270 -> d
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile() -> a
    void setTile(com.badlogic.gdx.maps.tiled.TiledMapTile) -> a
    boolean getFlipHorizontally() -> b
    void setFlipHorizontally(boolean) -> a
    boolean getFlipVertically() -> c
    void setFlipVertically(boolean) -> b
    int getRotation() -> d
    void setRotation(int) -> a
com.badlogic.gdx.maps.tiled.TiledMapTileSet -> com.badlogic.gdx.f.b.i:
    java.lang.String name -> a
    com.badlogic.gdx.utils.IntMap tiles -> b
    com.badlogic.gdx.maps.MapProperties properties -> c
    java.lang.String getName() -> a
    void setName(java.lang.String) -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> b
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> a
    java.util.Iterator iterator() -> iterator
    void putTile(int,com.badlogic.gdx.maps.tiled.TiledMapTile) -> a
    void removeTile(int) -> b
    int size() -> c
com.badlogic.gdx.maps.tiled.TiledMapTileSets -> com.badlogic.gdx.f.b.j:
    com.badlogic.gdx.utils.Array tilesets -> a
    com.badlogic.gdx.maps.tiled.TiledMapTileSet getTileSet(int) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTileSet getTileSet(java.lang.String) -> a
    void addTileSet(com.badlogic.gdx.maps.tiled.TiledMapTileSet) -> a
    void removeTileSet(int) -> b
    void removeTileSet(com.badlogic.gdx.maps.tiled.TiledMapTileSet) -> b
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> c
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.maps.tiled.TmxMapLoader -> com.badlogic.gdx.f.b.k:
    int FLAG_FLIP_HORIZONTALLY -> a
    int FLAG_FLIP_VERTICALLY -> b
    int FLAG_FLIP_DIAGONALLY -> c
    int MASK_CLEAR -> d
    com.badlogic.gdx.utils.XmlReader xml -> e
    com.badlogic.gdx.utils.XmlReader$Element root -> f
    boolean yUp -> g
    int mapWidthInPixels -> h
    int mapHeightInPixels -> i
    com.badlogic.gdx.maps.tiled.TiledMap map -> j
    com.badlogic.gdx.maps.tiled.TiledMap load(java.lang.String) -> b
    com.badlogic.gdx.maps.tiled.TiledMap load(java.lang.String,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> a
    com.badlogic.gdx.maps.tiled.TiledMap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> b
    com.badlogic.gdx.maps.tiled.TiledMap loadTilemap(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> a
    com.badlogic.gdx.utils.Array loadTilesets(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle) -> a
    void loadTileSet(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> a
    void loadTileLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.utils.XmlReader$Element) -> a
    void loadObjectGroup(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.utils.XmlReader$Element) -> b
    void loadObject(com.badlogic.gdx.maps.MapLayer,com.badlogic.gdx.utils.XmlReader$Element) -> a
    void loadProperties(com.badlogic.gdx.maps.MapProperties,com.badlogic.gdx.utils.XmlReader$Element) -> a
    com.badlogic.gdx.files.FileHandle getRelativeFileHandle(com.badlogic.gdx.files.FileHandle,java.lang.String) -> a
    int unsignedByteToInt(byte) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters -> com.badlogic.gdx.f.b.l:
    boolean yUp -> b
    boolean generateMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMinFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMagFilter -> e
com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer -> com.badlogic.gdx.f.b.a.a:
    com.badlogic.gdx.maps.tiled.TiledMap map -> a
    float unitScale -> b
    com.badlogic.gdx.graphics.g2d.SpriteBatch spriteBatch -> c
    com.badlogic.gdx.math.Rectangle viewBounds -> d
    boolean ownsSpriteBatch -> e
    com.badlogic.gdx.maps.tiled.TiledMap getMap() -> b
    void setMap(com.badlogic.gdx.maps.tiled.TiledMap) -> a
    float getUnitScale() -> c
    com.badlogic.gdx.graphics.g2d.SpriteBatch getSpriteBatch() -> d
    com.badlogic.gdx.math.Rectangle getViewBounds() -> f
    void setView(com.badlogic.gdx.graphics.OrthographicCamera) -> a
    void setView(com.badlogic.gdx.math.Matrix4,float,float,float,float) -> a
    void render() -> a
    void render(int[]) -> a
    void dispose() -> e
com.badlogic.gdx.maps.tiled.renderers.HexagonalTiledMapRenderer -> com.badlogic.gdx.f.b.a.b:
    boolean yDown -> f
    float[] vertices -> g
    boolean isYdown() -> g
    void setYDown(boolean) -> a
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> a
    void renderObject(com.badlogic.gdx.maps.MapObject) -> a
com.badlogic.gdx.maps.tiled.renderers.IsometricTiledMapRenderer -> com.badlogic.gdx.f.b.a.c:
    com.badlogic.gdx.maps.tiled.TiledMap map -> f
    float[] vertices -> g
    void renderObject(com.badlogic.gdx.maps.MapObject) -> a
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> a
com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer -> com.badlogic.gdx.f.b.a.d:
    float[] vertices -> f
    void renderObject(com.badlogic.gdx.maps.MapObject) -> a
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> a
com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer2 -> com.badlogic.gdx.f.b.a.e:
    com.badlogic.gdx.maps.tiled.TiledMap map -> a
    float unitScale -> b
    com.badlogic.gdx.graphics.g2d.SpriteCache spriteCache -> c
    com.badlogic.gdx.math.Rectangle viewBounds -> d
    float[] vertices -> h
    boolean recache -> e
    boolean cached -> f
    int count -> g
    void setView(com.badlogic.gdx.graphics.OrthographicCamera) -> a
    void setView(com.badlogic.gdx.math.Matrix4,float,float,float,float) -> a
    void begin() -> b
    void end() -> c
    void render() -> a
    void render(int[]) -> a
    void renderObject(com.badlogic.gdx.maps.MapObject) -> a
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> a
    void dispose() -> e
com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile -> com.badlogic.gdx.f.b.b.a:
    int id -> a
    com.badlogic.gdx.utils.Array frameTiles -> b
    float animationTime -> c
    int getId() -> a
    void setId(int) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode getBlendMode() -> b
    void setBlendMode(com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> c
    com.badlogic.gdx.maps.MapProperties getProperties() -> d
    void setAnimationTime(float) -> a
com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile -> com.badlogic.gdx.f.b.b.b:
    int id -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode blendMode -> b
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> d
    int getId() -> a
    void setId(int) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode getBlendMode() -> b
    void setBlendMode(com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode) -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> d
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> c
com.badlogic.gdx.math.BSpline -> com.badlogic.gdx.math.a:
    float d6 -> f
    com.badlogic.gdx.math.Vector[] controlPoints -> a
    com.badlogic.gdx.utils.Array knots -> b
    int degree -> c
    boolean continuous -> d
    int spanCount -> e
    com.badlogic.gdx.math.Vector tmp -> g
    com.badlogic.gdx.math.Vector cubic(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector[],boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector cubic(com.badlogic.gdx.math.Vector,int,float,com.badlogic.gdx.math.Vector[],boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector calculate(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector[],int,boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector calculate(com.badlogic.gdx.math.Vector,int,float,com.badlogic.gdx.math.Vector[],int,boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.BSpline set(com.badlogic.gdx.math.Vector[],int,boolean) -> a
    com.badlogic.gdx.math.Vector valueAt(com.badlogic.gdx.math.Vector,float) -> a
    com.badlogic.gdx.math.Vector valueAt(com.badlogic.gdx.math.Vector,int,float) -> a
    int nearest(com.badlogic.gdx.math.Vector) -> a
    int nearest(com.badlogic.gdx.math.Vector,int,int) -> a
    float approximate(com.badlogic.gdx.math.Vector) -> b
    float approximate(com.badlogic.gdx.math.Vector,int,int) -> b
    float approximate(com.badlogic.gdx.math.Vector,int) -> a
    float locate(com.badlogic.gdx.math.Vector) -> c
    float locate(java.lang.Object) -> a
    float approximate(java.lang.Object) -> b
    java.lang.Object valueAt(java.lang.Object,float) -> a
com.badlogic.gdx.math.Bezier -> com.badlogic.gdx.math.b:
    com.badlogic.gdx.utils.Array points -> a
    com.badlogic.gdx.math.Vector tmp -> b
    com.badlogic.gdx.math.Vector linear(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector quadratic(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector cubic(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Bezier set(com.badlogic.gdx.math.Vector[]) -> a
    com.badlogic.gdx.math.Bezier set(com.badlogic.gdx.math.Vector[],int,int) -> a
    com.badlogic.gdx.math.Bezier set(com.badlogic.gdx.utils.Array,int,int) -> a
    com.badlogic.gdx.math.Vector valueAt(com.badlogic.gdx.math.Vector,float) -> a
    float approximate(com.badlogic.gdx.math.Vector) -> a
    float locate(com.badlogic.gdx.math.Vector) -> b
    float locate(java.lang.Object) -> a
    float approximate(java.lang.Object) -> b
    java.lang.Object valueAt(java.lang.Object,float) -> a
com.badlogic.gdx.math.CatmullRomSpline -> com.badlogic.gdx.math.c:
    com.badlogic.gdx.math.Vector[] controlPoints -> a
    boolean continuous -> b
    int spanCount -> c
    com.badlogic.gdx.math.Vector tmp -> d
    com.badlogic.gdx.math.Vector tmp2 -> e
    com.badlogic.gdx.math.Vector calculate(com.badlogic.gdx.math.Vector,float,com.badlogic.gdx.math.Vector[],boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector calculate(com.badlogic.gdx.math.Vector,int,float,com.badlogic.gdx.math.Vector[],boolean,com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.CatmullRomSpline set(com.badlogic.gdx.math.Vector[],boolean) -> a
    com.badlogic.gdx.math.Vector valueAt(com.badlogic.gdx.math.Vector,float) -> a
    com.badlogic.gdx.math.Vector valueAt(com.badlogic.gdx.math.Vector,int,float) -> a
    int nearest(com.badlogic.gdx.math.Vector) -> a
    int nearest(com.badlogic.gdx.math.Vector,int,int) -> a
    float approximate(com.badlogic.gdx.math.Vector) -> b
    float approximate(com.badlogic.gdx.math.Vector,int,int) -> b
    float approximate(com.badlogic.gdx.math.Vector,int) -> a
    float locate(com.badlogic.gdx.math.Vector) -> c
    float locate(java.lang.Object) -> a
    float approximate(java.lang.Object) -> b
    java.lang.Object valueAt(java.lang.Object,float) -> a
com.badlogic.gdx.math.Circle -> com.badlogic.gdx.math.d:
    float x -> a
    float y -> b
    float radius -> c
    void set(float,float,float) -> a
    boolean contains(float,float) -> a
    boolean contains(com.badlogic.gdx.math.Vector2) -> a
    boolean contains(com.badlogic.gdx.math.Circle) -> a
    boolean overlaps(com.badlogic.gdx.math.Circle) -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.math.EarClippingTriangulator -> com.badlogic.gdx.math.e:
    int CONCAVE -> a
    int CONVEX -> b
    int concaveVertexCount -> c
    java.util.List computeTriangles(java.util.List) -> a
    boolean areVerticesClockwise(java.util.ArrayList) -> a
    int[] classifyVertices(java.util.ArrayList) -> b
    boolean isTriangleConvex(float,float,float,float,float,float) -> a
    int computeSpannedAreaSign(float,float,float,float,float,float) -> b
    boolean isAnyVertexInTriangle(java.util.ArrayList,int[],float,float,float,float,float,float) -> a
    boolean isEarTip(java.util.ArrayList,int,int[]) -> a
    void cutEarTip(java.util.ArrayList,int,java.util.ArrayList) -> a
    void removeCollinearNeighborEarsAfterRemovingEarTip(java.util.ArrayList,int) -> a
    boolean isCollinear(java.util.ArrayList,int) -> b
    boolean isCollinear(java.util.ArrayList,int,int,int) -> a
    int computePreviousIndex(java.util.List,int) -> a
    int computeNextIndex(java.util.List,int) -> b
com.badlogic.gdx.math.Ellipse -> com.badlogic.gdx.math.f:
    float x -> a
    float y -> b
    float width -> c
    float height -> d
    float halfWidth -> e
    float halfHeight -> f
    long serialVersionUID -> g
    boolean contains(float,float) -> a
    boolean contains(com.badlogic.gdx.math.Vector2) -> a
    void set(float,float,float,float) -> a
com.badlogic.gdx.math.FloatCounter -> com.badlogic.gdx.math.g:
    int count -> a
    float total -> b
    float min -> c
    float max -> d
    float average -> e
    float latest -> f
    float value -> g
    com.badlogic.gdx.math.WindowedMean mean -> h
    void put(float) -> a
    void reset() -> a
com.badlogic.gdx.math.Frustum -> com.badlogic.gdx.math.h:
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> a
    float[] clipSpacePlanePointsArray -> b
    com.badlogic.gdx.math.Plane[] planes -> c
    com.badlogic.gdx.math.Vector3[] planePoints -> d
    float[] planePointsArray -> e
    void update(com.badlogic.gdx.math.Matrix4) -> a
    boolean pointInFrustum(com.badlogic.gdx.math.Vector3) -> a
    boolean sphereInFrustum(com.badlogic.gdx.math.Vector3,float) -> a
    boolean sphereInFrustumWithoutNearFar(com.badlogic.gdx.math.Vector3,float) -> b
    boolean boundsInFrustum(com.badlogic.gdx.math.collision.BoundingBox) -> a
com.badlogic.gdx.math.Interpolation -> com.badlogic.gdx.math.i:
    com.badlogic.gdx.math.Interpolation linear -> a
    com.badlogic.gdx.math.Interpolation fade -> b
    com.badlogic.gdx.math.Interpolation$Pow pow2 -> c
    com.badlogic.gdx.math.Interpolation$PowIn pow2In -> d
    com.badlogic.gdx.math.Interpolation$PowOut pow2Out -> e
    com.badlogic.gdx.math.Interpolation$Pow pow3 -> f
    com.badlogic.gdx.math.Interpolation$PowIn pow3In -> g
    com.badlogic.gdx.math.Interpolation$PowOut pow3Out -> h
    com.badlogic.gdx.math.Interpolation$Pow pow4 -> i
    com.badlogic.gdx.math.Interpolation$PowIn pow4In -> j
    com.badlogic.gdx.math.Interpolation$PowOut pow4Out -> k
    com.badlogic.gdx.math.Interpolation$Pow pow5 -> l
    com.badlogic.gdx.math.Interpolation$PowIn pow5In -> m
    com.badlogic.gdx.math.Interpolation$PowOut pow5Out -> n
    com.badlogic.gdx.math.Interpolation sine -> o
    com.badlogic.gdx.math.Interpolation sineIn -> p
    com.badlogic.gdx.math.Interpolation sineOut -> q
    com.badlogic.gdx.math.Interpolation exp10 -> r
    com.badlogic.gdx.math.Interpolation exp10In -> s
    com.badlogic.gdx.math.Interpolation exp10Out -> t
    com.badlogic.gdx.math.Interpolation exp5 -> u
    com.badlogic.gdx.math.Interpolation exp5In -> v
    com.badlogic.gdx.math.Interpolation exp5Out -> w
    com.badlogic.gdx.math.Interpolation circle -> x
    com.badlogic.gdx.math.Interpolation circleIn -> y
    com.badlogic.gdx.math.Interpolation circleOut -> z
    com.badlogic.gdx.math.Interpolation$Elastic elastic -> A
    com.badlogic.gdx.math.Interpolation$Elastic elasticIn -> B
    com.badlogic.gdx.math.Interpolation$Elastic elasticOut -> C
    com.badlogic.gdx.math.Interpolation swing -> D
    com.badlogic.gdx.math.Interpolation swingIn -> E
    com.badlogic.gdx.math.Interpolation swingOut -> F
    com.badlogic.gdx.math.Interpolation bounce -> G
    com.badlogic.gdx.math.Interpolation bounceIn -> H
    com.badlogic.gdx.math.Interpolation bounceOut -> I
    float apply(float) -> a
    float apply(float,float,float) -> a
com.badlogic.gdx.math.Interpolation$1 -> com.badlogic.gdx.math.j:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$2 -> com.badlogic.gdx.math.k:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$3 -> com.badlogic.gdx.math.l:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$4 -> com.badlogic.gdx.math.m:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$5 -> com.badlogic.gdx.math.n:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$6 -> com.badlogic.gdx.math.o:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$7 -> com.badlogic.gdx.math.p:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$8 -> com.badlogic.gdx.math.q:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Bounce -> com.badlogic.gdx.math.r:
    float out(float) -> b
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceIn -> com.badlogic.gdx.math.s:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceOut -> com.badlogic.gdx.math.t:
    float[] widths -> J
    float[] heights -> K
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Elastic -> com.badlogic.gdx.math.u:
    float value -> J
    float power -> K
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticIn -> com.badlogic.gdx.math.v:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticOut -> com.badlogic.gdx.math.w:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Exp -> com.badlogic.gdx.math.x:
    float value -> J
    float power -> K
    float min -> L
    float scale -> M
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpIn -> com.badlogic.gdx.math.y:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpOut -> com.badlogic.gdx.math.z:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Pow -> com.badlogic.gdx.math.aa:
    int power -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowIn -> com.badlogic.gdx.math.ab:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowOut -> com.badlogic.gdx.math.ac:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Swing -> com.badlogic.gdx.math.ad:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingIn -> com.badlogic.gdx.math.ae:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingOut -> com.badlogic.gdx.math.af:
    float scale -> J
    float apply(float) -> a
com.badlogic.gdx.math.Intersector -> com.badlogic.gdx.math.ag:
    com.badlogic.gdx.math.Vector3 v0 -> g
    com.badlogic.gdx.math.Vector3 v1 -> h
    com.badlogic.gdx.math.Vector3 v2 -> i
    com.badlogic.gdx.math.Plane p -> j
    com.badlogic.gdx.math.Vector3 i -> k
    com.badlogic.gdx.math.Vector3 dir -> l
    com.badlogic.gdx.math.Vector3 start -> m
    com.badlogic.gdx.math.Vector3 tmp -> a
    com.badlogic.gdx.math.Vector3 best -> b
    com.badlogic.gdx.math.Vector3 tmp1 -> c
    com.badlogic.gdx.math.Vector3 tmp2 -> d
    com.badlogic.gdx.math.Vector3 tmp3 -> e
    com.badlogic.gdx.math.Vector3 intersection -> f
    float getLowestPositiveRoot(float,float,float) -> a
    boolean isPointInTriangle(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectSegmentPlane(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Plane,com.badlogic.gdx.math.Vector3) -> a
    int pointLineSide(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    int pointLineSide(float,float,float,float,float,float) -> a
    boolean isPointInPolygon(java.util.List,com.badlogic.gdx.math.Vector2) -> a
    float distanceLinePoint(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> b
    float distanceLinePoint(float,float,float,float,float,float) -> b
    boolean intersectSegmentCircle(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
    float intersectSegmentCircleDisplace(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float,com.badlogic.gdx.math.Vector2) -> a
    boolean intersectRayPlane(com.badlogic.gdx.math.collision.Ray,com.badlogic.gdx.math.Plane,com.badlogic.gdx.math.Vector3) -> a
    float intersectLinePlane(float,float,float,float,float,float,com.badlogic.gdx.math.Plane,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRayTriangle(com.badlogic.gdx.math.collision.Ray,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRaySphere(com.badlogic.gdx.math.collision.Ray,com.badlogic.gdx.math.Vector3,float,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRayBounds(com.badlogic.gdx.math.collision.Ray,com.badlogic.gdx.math.collision.BoundingBox,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRayBoundsFast(com.badlogic.gdx.math.collision.Ray,com.badlogic.gdx.math.collision.BoundingBox) -> a
    boolean intersectRayTriangles(com.badlogic.gdx.math.collision.Ray,float[],com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRayTriangles(com.badlogic.gdx.math.collision.Ray,float[],short[],int,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectRayTriangles(com.badlogic.gdx.math.collision.Ray,java.util.List,com.badlogic.gdx.math.Vector3) -> a
    boolean intersectLines(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    boolean intersectSegments(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> b
    float det(float,float,float,float) -> a
    double detd(double,double,double,double) -> a
    boolean overlaps(com.badlogic.gdx.math.Circle,com.badlogic.gdx.math.Circle) -> a
    boolean overlaps(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    boolean overlaps(com.badlogic.gdx.math.Circle,com.badlogic.gdx.math.Rectangle) -> a
    boolean overlapConvexPolygons(com.badlogic.gdx.math.Polygon,com.badlogic.gdx.math.Polygon) -> a
    boolean overlapConvexPolygons(com.badlogic.gdx.math.Polygon,com.badlogic.gdx.math.Polygon,com.badlogic.gdx.math.Intersector$MinimumTranslationVector) -> a
    boolean overlapConvexPolygons(float[],float[],com.badlogic.gdx.math.Intersector$MinimumTranslationVector) -> a
    void splitTriangle(float[],com.badlogic.gdx.math.Plane,com.badlogic.gdx.math.Intersector$SplitTriangle) -> a
    void splitEdge(float[],int,int,int,com.badlogic.gdx.math.Plane,float[],int) -> a
    void main(java.lang.String[]) -> a
com.badlogic.gdx.math.Intersector$MinimumTranslationVector -> com.badlogic.gdx.math.ah:
    com.badlogic.gdx.math.Vector2 normal -> a
    float depth -> b
com.badlogic.gdx.math.Intersector$SplitTriangle -> com.badlogic.gdx.math.ai:
    float[] front -> a
    float[] back -> b
    float[] edgeSplit -> c
    int numFront -> d
    int numBack -> e
    int total -> f
    boolean frontCurrent -> g
    int frontOffset -> h
    int backOffset -> i
    java.lang.String toString() -> toString
    void setSide(boolean) -> a
    boolean getSide() -> a
    void add(float[],int,int) -> a
    void reset() -> b
com.badlogic.gdx.math.MathUtils -> com.badlogic.gdx.math.aj:
    float nanoToSec -> a
    float PI -> b
    float PI2 -> c
    int SIN_BITS -> j
    int SIN_MASK -> k
    int SIN_COUNT -> l
    float radFull -> m
    float degFull -> n
    float radToIndex -> o
    float degToIndex -> p
    float radiansToDegrees -> d
    float radDeg -> e
    float degreesToRadians -> f
    float degRad -> g
    int ATAN2_BITS -> q
    int ATAN2_BITS2 -> r
    int ATAN2_MASK -> s
    int ATAN2_COUNT -> t
    int ATAN2_DIM -> h
    float INV_ATAN2_DIM_MINUS_1 -> u
    java.util.Random random -> i
    int BIG_ENOUGH_INT -> v
    double BIG_ENOUGH_FLOOR -> w
    double CEIL -> x
    double BIG_ENOUGH_CEIL -> y
    double BIG_ENOUGH_ROUND -> z
    float sin(float) -> a
    float cos(float) -> b
    float sinDeg(float) -> c
    float cosDeg(float) -> d
    float atan2(float,float) -> a
    int random(int) -> a
    int random(int,int) -> a
    boolean randomBoolean() -> a
    float random() -> b
    float random(float) -> e
    float random(float,float) -> b
    int nextPowerOfTwo(int) -> b
    boolean isPowerOfTwo(int) -> c
    int clamp(int,int,int) -> a
    short clamp(short,short,short) -> a
    float clamp(float,float,float) -> a
    int floor(float) -> f
    int floorPositive(float) -> g
    int ceil(float) -> h
    int ceilPositive(float) -> i
    int round(float) -> j
    int roundPositive(float) -> k
com.badlogic.gdx.math.MathUtils$Atan2 -> com.badlogic.gdx.math.ak:
    float[] table -> a
com.badlogic.gdx.math.MathUtils$Sin -> com.badlogic.gdx.math.al:
    float[] table -> a
com.badlogic.gdx.math.Matrix3 -> com.badlogic.gdx.math.am:
    long serialVersionUID -> k
    float DEGREE_TO_RAD -> l
    int M00 -> a
    int M01 -> b
    int M02 -> c
    int M10 -> d
    int M11 -> e
    int M12 -> f
    int M20 -> g
    int M21 -> h
    int M22 -> i
    float[] val -> j
    float[] tmp -> m
    com.badlogic.gdx.math.Matrix3 idt() -> a
    com.badlogic.gdx.math.Matrix3 mul(com.badlogic.gdx.math.Matrix3) -> a
    com.badlogic.gdx.math.Matrix3 setToRotation(float) -> a
    com.badlogic.gdx.math.Matrix3 setToTranslation(float,float) -> a
    com.badlogic.gdx.math.Matrix3 setToTranslation(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Matrix3 setToScaling(float,float) -> b
    java.lang.String toString() -> toString
    float det() -> b
    com.badlogic.gdx.math.Matrix3 inv() -> c
    com.badlogic.gdx.math.Matrix3 set(com.badlogic.gdx.math.Matrix3) -> b
    com.badlogic.gdx.math.Matrix3 set(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix3 trn(com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Matrix3 trn(float,float) -> c
    com.badlogic.gdx.math.Matrix3 trn(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix3 translate(float,float) -> d
    com.badlogic.gdx.math.Matrix3 translate(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Matrix3 rotate(float) -> b
    com.badlogic.gdx.math.Matrix3 scale(float,float) -> e
    com.badlogic.gdx.math.Matrix3 scale(com.badlogic.gdx.math.Vector2) -> d
    float[] getValues() -> d
    com.badlogic.gdx.math.Matrix3 scl(float) -> c
    com.badlogic.gdx.math.Matrix3 scl(com.badlogic.gdx.math.Vector2) -> e
    com.badlogic.gdx.math.Matrix3 scl(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Matrix3 transpose() -> e
    void mul(float[],float[]) -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    long serialVersionUID -> B
    int M00 -> a
    int M01 -> b
    int M02 -> c
    int M03 -> d
    int M10 -> e
    int M11 -> f
    int M12 -> g
    int M13 -> h
    int M20 -> i
    int M21 -> j
    int M22 -> k
    int M23 -> l
    int M30 -> m
    int M31 -> n
    int M32 -> o
    int M33 -> p
    float[] tmp -> q
    float[] val -> r
    com.badlogic.gdx.math.Quaternion quat -> s
    com.badlogic.gdx.math.Vector3 l_vez -> t
    com.badlogic.gdx.math.Vector3 l_vex -> u
    com.badlogic.gdx.math.Vector3 l_vey -> v
    com.badlogic.gdx.math.Vector3 tmpVec -> w
    com.badlogic.gdx.math.Matrix4 tmpMat -> x
    com.badlogic.gdx.math.Vector3 right -> y
    com.badlogic.gdx.math.Vector3 tmpForward -> z
    com.badlogic.gdx.math.Vector3 tmpUp -> A
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix4 set(float[]) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 cpy() -> a
    com.badlogic.gdx.math.Matrix4 trn(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 trn(float,float,float) -> a
    float[] getValues() -> b
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 tra() -> c
    com.badlogic.gdx.math.Matrix4 idt() -> d
    com.badlogic.gdx.math.Matrix4 inv() -> e
    float det() -> f
    com.badlogic.gdx.math.Matrix4 setToProjection(float,float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> c
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 setTranslation(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Matrix4 setToTranslation(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 setToTranslationAndScaling(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToTranslationAndScaling(float,float,float,float,float,float) -> c
    com.badlogic.gdx.math.Matrix4 setToRotation(com.badlogic.gdx.math.Vector3,float) -> a
    com.badlogic.gdx.math.Matrix4 setToRotation(float,float,float,float) -> d
    com.badlogic.gdx.math.Matrix4 setToRotation(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Matrix4 setToRotation(float,float,float,float,float,float) -> d
    com.badlogic.gdx.math.Matrix4 setFromEulerAngles(float,float,float) -> c
    com.badlogic.gdx.math.Matrix4 setToScaling(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Matrix4 setToScaling(float,float,float) -> d
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToWorld(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> b
    java.lang.String toString() -> toString
    void lerp(com.badlogic.gdx.math.Matrix4,float) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix3) -> a
    com.badlogic.gdx.math.Matrix4 scl(com.badlogic.gdx.math.Vector3) -> e
    com.badlogic.gdx.math.Matrix4 scl(float,float,float) -> e
    com.badlogic.gdx.math.Matrix4 scl(float) -> a
    void getTranslation(com.badlogic.gdx.math.Vector3) -> f
    void getRotation(com.badlogic.gdx.math.Quaternion) -> b
    com.badlogic.gdx.math.Matrix4 toNormalMatrix() -> g
    void mul(float[],float[]) -> mul
    void mulVec(float[],float[]) -> mulVec
    void mulVec(float[],float[],int,int,int) -> mulVec
    void prj(float[],float[]) -> prj
    void prj(float[],float[],int,int,int) -> prj
    void rot(float[],float[]) -> rot
    void rot(float[],float[],int,int,int) -> rot
    boolean inv(float[]) -> inv
    float det(float[]) -> det
    com.badlogic.gdx.math.Matrix4 translate(com.badlogic.gdx.math.Vector3) -> g
    com.badlogic.gdx.math.Matrix4 translate(float,float,float) -> f
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Vector3,float) -> b
    com.badlogic.gdx.math.Matrix4 rotate(float,float,float,float) -> e
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Quaternion) -> c
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Matrix4 scale(float,float,float) -> g
com.badlogic.gdx.math.Path -> com.badlogic.gdx.math.an:
    java.lang.Object valueAt(java.lang.Object,float) -> a
    float approximate(java.lang.Object) -> b
    float locate(java.lang.Object) -> a
com.badlogic.gdx.math.Plane -> com.badlogic.gdx.math.ao:
    long serialVersionUID -> c
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    void set(float,float,float,float) -> a
    float distance(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Plane$PlaneSide testPoint(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Plane$PlaneSide testPoint(float,float,float) -> a
    boolean isFrontFacing(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 getNormal() -> a
    float getD() -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    void set(float,float,float,float,float,float) -> a
    void set(com.badlogic.gdx.math.Plane) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.math.Plane$PlaneSide -> com.badlogic.gdx.math.ap:
    com.badlogic.gdx.math.Plane$PlaneSide OnPlane -> a
    com.badlogic.gdx.math.Plane$PlaneSide Back -> b
    com.badlogic.gdx.math.Plane$PlaneSide Front -> c
    com.badlogic.gdx.math.Plane$PlaneSide[] $VALUES -> d
    com.badlogic.gdx.math.Plane$PlaneSide[] values() -> values
    com.badlogic.gdx.math.Plane$PlaneSide valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.math.Polygon -> com.badlogic.gdx.math.aq:
    float[] localVertices -> a
    float[] worldVertices -> b
    float x -> c
    float y -> d
    float originX -> e
    float originY -> f
    float rotation -> g
    float scaleX -> h
    float scaleY -> i
    boolean dirty -> j
    com.badlogic.gdx.math.Rectangle bounds -> k
    float[] getVertices() -> a
    float[] getTransformedVertices() -> b
    void setOrigin(float,float) -> a
    void setPosition(float,float) -> b
    void translate(float,float) -> c
    void setRotation(float) -> a
    void rotate(float) -> b
    void setScale(float,float) -> d
    void scale(float) -> c
    void dirty() -> c
    float area() -> d
    com.badlogic.gdx.math.Rectangle getBoundingRectangle() -> e
    boolean contains(float,float) -> e
    float getX() -> f
    float getY() -> g
    float getOriginX() -> h
    float getOriginY() -> i
    float getRotation() -> j
    float getScaleX() -> k
    float getScaleY() -> l
com.badlogic.gdx.math.Polyline -> com.badlogic.gdx.math.ar:
    float[] localVertices -> a
    float[] worldVertices -> b
    float x -> c
    float y -> d
    float originX -> e
    float originY -> f
    float rotation -> g
    float scaleX -> h
    float scaleY -> i
    float length -> j
    float scaledLength -> k
    boolean calculateScaledLength -> l
    boolean calculateLength -> m
    boolean dirty -> n
    float[] getVertices() -> a
    float[] getTransformedVertices() -> b
    float getLength() -> c
    float getScaledLength() -> d
    float getX() -> e
    float getY() -> f
    float getOriginX() -> g
    float getOriginY() -> h
    float getRotation() -> i
    float getScaleX() -> j
    float getScaleY() -> k
    void setOrigin(float,float) -> a
    void setPosition(float,float) -> b
    void setRotation(float) -> a
    void rotate(float) -> b
    void setScale(float,float) -> c
    void scale(float) -> c
    void calculateLength() -> l
    void calculateScaledLength() -> m
    void dirty() -> n
    void translate(float,float) -> d
com.badlogic.gdx.math.Quaternion -> com.badlogic.gdx.math.as:
    long serialVersionUID -> e
    float NORMALIZATION_TOLERANCE -> f
    com.badlogic.gdx.math.Quaternion tmp1 -> g
    com.badlogic.gdx.math.Quaternion tmp2 -> h
    float x -> a
    float y -> b
    float z -> c
    float w -> d
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Vector3,float) -> a
    com.badlogic.gdx.math.Quaternion cpy() -> a
    float len() -> b
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Quaternion setEulerAngles(float,float,float) -> a
    float len2() -> c
    com.badlogic.gdx.math.Quaternion nor() -> d
    com.badlogic.gdx.math.Quaternion conjugate() -> e
    com.badlogic.gdx.math.Vector3 transform(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Quaternion mul(com.badlogic.gdx.math.Quaternion) -> b
    com.badlogic.gdx.math.Quaternion mulLeft(com.badlogic.gdx.math.Quaternion) -> c
    void toMatrix(float[]) -> a
    com.badlogic.gdx.math.Quaternion idt() -> f
    com.badlogic.gdx.math.Quaternion setFromAxis(com.badlogic.gdx.math.Vector3,float) -> b
    com.badlogic.gdx.math.Quaternion setFromAxis(float,float,float,float) -> b
    com.badlogic.gdx.math.Quaternion setFromMatrix(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Quaternion setFromAxes(float,float,float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion setFromCross(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Quaternion setFromCross(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion slerp(com.badlogic.gdx.math.Quaternion,float) -> a
    boolean equals(java.lang.Object) -> equals
    float dot(com.badlogic.gdx.math.Quaternion) -> d
    com.badlogic.gdx.math.Quaternion mul(float) -> a
com.badlogic.gdx.math.Rectangle -> com.badlogic.gdx.math.at:
    com.badlogic.gdx.math.Rectangle tmp -> a
    com.badlogic.gdx.math.Rectangle tmp2 -> b
    long serialVersionUID -> g
    float x -> c
    float y -> d
    float width -> e
    float height -> f
    void set(float,float,float,float) -> a
    float getX() -> a
    void setX(float) -> a
    float getY() -> b
    void setY(float) -> b
    float getWidth() -> c
    void setWidth(float) -> c
    float getHeight() -> d
    void setHeight(float) -> d
    boolean contains(float,float) -> a
    boolean contains(com.badlogic.gdx.math.Rectangle) -> a
    boolean overlaps(com.badlogic.gdx.math.Rectangle) -> b
    void set(com.badlogic.gdx.math.Rectangle) -> c
    void merge(com.badlogic.gdx.math.Rectangle) -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.math.Vector -> com.badlogic.gdx.math.au:
    com.badlogic.gdx.math.Vector cpy() -> a
    float len() -> b
    float len2() -> c
    com.badlogic.gdx.math.Vector limit(float) -> a
    com.badlogic.gdx.math.Vector clamp(float,float) -> a
    com.badlogic.gdx.math.Vector set(com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector sub(com.badlogic.gdx.math.Vector) -> b
    com.badlogic.gdx.math.Vector nor() -> d
    com.badlogic.gdx.math.Vector add(com.badlogic.gdx.math.Vector) -> c
    float dot(com.badlogic.gdx.math.Vector) -> d
    com.badlogic.gdx.math.Vector scl(float) -> b
    com.badlogic.gdx.math.Vector scl(com.badlogic.gdx.math.Vector) -> e
    float dst(com.badlogic.gdx.math.Vector) -> f
    float dst2(com.badlogic.gdx.math.Vector) -> g
    com.badlogic.gdx.math.Vector lerp(com.badlogic.gdx.math.Vector,float) -> a
com.badlogic.gdx.math.Vector2 -> com.badlogic.gdx.math.av:
    long serialVersionUID -> f
    com.badlogic.gdx.math.Vector2 X -> a
    com.badlogic.gdx.math.Vector2 Y -> b
    com.badlogic.gdx.math.Vector2 Zero -> c
    float x -> d
    float y -> e
    com.badlogic.gdx.math.Vector2 cpy() -> e
    float len() -> b
    float len2() -> c
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 set(float,float) -> b
    com.badlogic.gdx.math.Vector2 sub(com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Vector2 nor() -> f
    com.badlogic.gdx.math.Vector2 add(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 add(float,float) -> c
    float dot(com.badlogic.gdx.math.Vector2) -> d
    com.badlogic.gdx.math.Vector2 scl(float) -> c
    com.badlogic.gdx.math.Vector2 mul(float) -> d
    com.badlogic.gdx.math.Vector2 scl(float,float) -> d
    com.badlogic.gdx.math.Vector2 mul(float,float) -> e
    com.badlogic.gdx.math.Vector2 scl(com.badlogic.gdx.math.Vector2) -> e
    com.badlogic.gdx.math.Vector2 mul(com.badlogic.gdx.math.Vector2) -> f
    com.badlogic.gdx.math.Vector2 div(float) -> e
    com.badlogic.gdx.math.Vector2 div(float,float) -> f
    com.badlogic.gdx.math.Vector2 div(com.badlogic.gdx.math.Vector2) -> g
    float dst(com.badlogic.gdx.math.Vector2) -> h
    float dst(float,float) -> g
    float dst2(com.badlogic.gdx.math.Vector2) -> i
    float dst2(float,float) -> h
    com.badlogic.gdx.math.Vector2 limit(float) -> f
    com.badlogic.gdx.math.Vector2 clamp(float,float) -> i
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Vector2 sub(float,float) -> j
    com.badlogic.gdx.math.Vector2 mul(com.badlogic.gdx.math.Matrix3) -> a
    float crs(com.badlogic.gdx.math.Vector2) -> j
    float crs(float,float) -> k
    float angle() -> g
    void setAngle(float) -> g
    com.badlogic.gdx.math.Vector2 rotate(float) -> h
    com.badlogic.gdx.math.Vector2 lerp(com.badlogic.gdx.math.Vector2,float) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    boolean epsilonEquals(com.badlogic.gdx.math.Vector2,float) -> b
    boolean epsilonEquals(float,float,float) -> a
    com.badlogic.gdx.math.Vector lerp(com.badlogic.gdx.math.Vector,float) -> a
    float dst2(com.badlogic.gdx.math.Vector) -> g
    float dst(com.badlogic.gdx.math.Vector) -> f
    com.badlogic.gdx.math.Vector scl(com.badlogic.gdx.math.Vector) -> e
    com.badlogic.gdx.math.Vector scl(float) -> b
    float dot(com.badlogic.gdx.math.Vector) -> d
    com.badlogic.gdx.math.Vector add(com.badlogic.gdx.math.Vector) -> c
    com.badlogic.gdx.math.Vector nor() -> d
    com.badlogic.gdx.math.Vector sub(com.badlogic.gdx.math.Vector) -> b
    com.badlogic.gdx.math.Vector set(com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector clamp(float,float) -> a
    com.badlogic.gdx.math.Vector limit(float) -> a
    com.badlogic.gdx.math.Vector cpy() -> a
com.badlogic.gdx.math.Vector3 -> com.badlogic.gdx.math.aw:
    long serialVersionUID -> k
    float x -> a
    float y -> b
    float z -> c
    com.badlogic.gdx.math.Vector3 tmp -> d
    com.badlogic.gdx.math.Vector3 tmp2 -> e
    com.badlogic.gdx.math.Vector3 tmp3 -> f
    com.badlogic.gdx.math.Vector3 X -> g
    com.badlogic.gdx.math.Vector3 Y -> h
    com.badlogic.gdx.math.Vector3 Z -> i
    com.badlogic.gdx.math.Vector3 Zero -> j
    com.badlogic.gdx.math.Matrix4 tmpMat -> l
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Vector3 set(float[]) -> a
    com.badlogic.gdx.math.Vector3 cpy() -> e
    com.badlogic.gdx.math.Vector3 tmp() -> f
    com.badlogic.gdx.math.Vector3 tmp2() -> g
    com.badlogic.gdx.math.Vector3 tmp3() -> h
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> b
    com.badlogic.gdx.math.Vector3 add(float) -> c
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 sub(float) -> d
    com.badlogic.gdx.math.Vector3 scl(float) -> e
    com.badlogic.gdx.math.Vector3 mul(float) -> f
    com.badlogic.gdx.math.Vector3 scl(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Vector3) -> e
    com.badlogic.gdx.math.Vector3 scl(float,float,float) -> d
    com.badlogic.gdx.math.Vector3 mul(float,float,float) -> e
    com.badlogic.gdx.math.Vector3 scale(float,float,float) -> f
    com.badlogic.gdx.math.Vector3 div(float) -> g
    com.badlogic.gdx.math.Vector3 div(float,float,float) -> g
    com.badlogic.gdx.math.Vector3 div(com.badlogic.gdx.math.Vector3) -> f
    float len(float,float,float) -> h
    float len() -> b
    float len2(float,float,float) -> i
    float len2() -> c
    boolean idt(com.badlogic.gdx.math.Vector3) -> g
    float dst(float,float,float,float,float,float) -> a
    float dst(com.badlogic.gdx.math.Vector3) -> h
    float dst(float,float,float) -> j
    float dst2(float,float,float,float,float,float) -> b
    float dst2(com.badlogic.gdx.math.Vector3) -> i
    float dst2(float,float,float) -> k
    com.badlogic.gdx.math.Vector3 nor() -> i
    float dot(float,float,float,float,float,float) -> c
    float dot(com.badlogic.gdx.math.Vector3) -> j
    float dot(float,float,float) -> l
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> k
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> m
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Vector3 rot(com.badlogic.gdx.math.Matrix4) -> c
    com.badlogic.gdx.math.Vector3 rotate(float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 rotate(com.badlogic.gdx.math.Vector3,float) -> a
    boolean isUnit() -> j
    boolean isUnit(float) -> h
    boolean isZero() -> k
    boolean isZero(float) -> i
    com.badlogic.gdx.math.Vector3 lerp(com.badlogic.gdx.math.Vector3,float) -> b
    com.badlogic.gdx.math.Vector3 slerp(com.badlogic.gdx.math.Vector3,float) -> c
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Vector3 limit(float) -> j
    com.badlogic.gdx.math.Vector3 clamp(float,float) -> b
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    boolean epsilonEquals(com.badlogic.gdx.math.Vector3,float) -> d
    boolean epsilonEquals(float,float,float,float) -> b
    com.badlogic.gdx.math.Vector lerp(com.badlogic.gdx.math.Vector,float) -> a
    float dst2(com.badlogic.gdx.math.Vector) -> g
    float dst(com.badlogic.gdx.math.Vector) -> f
    com.badlogic.gdx.math.Vector scl(com.badlogic.gdx.math.Vector) -> e
    com.badlogic.gdx.math.Vector scl(float) -> b
    float dot(com.badlogic.gdx.math.Vector) -> d
    com.badlogic.gdx.math.Vector add(com.badlogic.gdx.math.Vector) -> c
    com.badlogic.gdx.math.Vector nor() -> d
    com.badlogic.gdx.math.Vector sub(com.badlogic.gdx.math.Vector) -> b
    com.badlogic.gdx.math.Vector set(com.badlogic.gdx.math.Vector) -> a
    com.badlogic.gdx.math.Vector clamp(float,float) -> a
    com.badlogic.gdx.math.Vector limit(float) -> a
    com.badlogic.gdx.math.Vector cpy() -> a
com.badlogic.gdx.math.WindowedMean -> com.badlogic.gdx.math.ax:
    float[] values -> a
    int added_values -> b
    int last_value -> c
    float mean -> d
    boolean dirty -> e
    boolean hasEnoughData() -> a
    void clear() -> b
    void addValue(float) -> a
    float getMean() -> c
    float getOldest() -> d
    float getLatest() -> e
    float standardDeviation() -> f
com.badlogic.gdx.math.collision.BoundingBox -> com.badlogic.gdx.math.a.a:
    long serialVersionUID -> g
    com.badlogic.gdx.math.Vector3[] crn -> a
    com.badlogic.gdx.math.Vector3 min -> b
    com.badlogic.gdx.math.Vector3 max -> c
    com.badlogic.gdx.math.Vector3 cnt -> d
    com.badlogic.gdx.math.Vector3 dim -> e
    boolean crn_dirty -> f
    com.badlogic.gdx.math.Vector3 getCenter() -> a
    void updateCorners() -> b
    com.badlogic.gdx.math.Vector3[] getCorners() -> c
    com.badlogic.gdx.math.Vector3 getDimensions() -> d
    com.badlogic.gdx.math.Vector3 getMin() -> e
    com.badlogic.gdx.math.Vector3 getMax() -> f
    com.badlogic.gdx.math.collision.BoundingBox set(com.badlogic.gdx.math.collision.BoundingBox) -> a
    com.badlogic.gdx.math.collision.BoundingBox set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.collision.BoundingBox set(com.badlogic.gdx.math.Vector3[]) -> a
    com.badlogic.gdx.math.collision.BoundingBox set(java.util.List) -> a
    com.badlogic.gdx.math.collision.BoundingBox inf() -> g
    com.badlogic.gdx.math.collision.BoundingBox ext(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.collision.BoundingBox clr() -> h
    boolean isValid() -> i
    com.badlogic.gdx.math.collision.BoundingBox ext(com.badlogic.gdx.math.collision.BoundingBox) -> b
    com.badlogic.gdx.math.collision.BoundingBox mul(com.badlogic.gdx.math.Matrix4) -> a
    boolean contains(com.badlogic.gdx.math.collision.BoundingBox) -> c
    boolean contains(com.badlogic.gdx.math.Vector3) -> b
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.collision.BoundingBox ext(float,float,float) -> a
    float min(float,float) -> a
    float max(float,float) -> b
com.badlogic.gdx.math.collision.Ray -> com.badlogic.gdx.math.a.b:
    long serialVersionUID -> d
    com.badlogic.gdx.math.Vector3 origin -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 tmp -> c
    com.badlogic.gdx.math.collision.Ray cpy() -> a
    com.badlogic.gdx.math.Vector3 getEndPoint(float) -> a
    com.badlogic.gdx.math.collision.Ray mul(com.badlogic.gdx.math.Matrix4) -> a
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.collision.Ray set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.collision.Ray set(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.collision.Ray set(com.badlogic.gdx.math.collision.Ray) -> a
com.badlogic.gdx.math.collision.Segment -> com.badlogic.gdx.math.a.c:
    long serialVersionUID -> c
    com.badlogic.gdx.math.Vector3 a -> a
    com.badlogic.gdx.math.Vector3 b -> b
com.badlogic.gdx.math.collision.Sphere -> com.badlogic.gdx.math.a.d:
    long serialVersionUID -> c
    float radius -> a
    com.badlogic.gdx.math.Vector3 center -> b
    boolean overlaps(com.badlogic.gdx.math.collision.Sphere) -> a
com.badlogic.gdx.net.HttpParametersUtils -> com.badlogic.gdx.g.a:
    java.lang.String defaultEncoding -> a
    java.lang.String nameValueSeparator -> b
    java.lang.String parameterSeparator -> c
    java.lang.String convertHttpParameters(java.util.Map) -> a
    java.lang.String encode(java.lang.String,java.lang.String) -> a
com.badlogic.gdx.net.HttpStatus -> com.badlogic.gdx.g.b:
    int statusCode -> a
    int SC_CONTINUE -> b
    int SC_SWITCHING_PROTOCOLS -> c
    int SC_PROCESSING -> d
    int SC_OK -> e
    int SC_CREATED -> f
    int SC_ACCEPTED -> g
    int SC_NON_AUTHORITATIVE_INFORMATION -> h
    int SC_NO_CONTENT -> i
    int SC_RESET_CONTENT -> j
    int SC_PARTIAL_CONTENT -> k
    int SC_MULTI_STATUS -> l
    int SC_MULTIPLE_CHOICES -> m
    int SC_MOVED_PERMANENTLY -> n
    int SC_MOVED_TEMPORARILY -> o
    int SC_SEE_OTHER -> p
    int SC_NOT_MODIFIED -> q
    int SC_USE_PROXY -> r
    int SC_TEMPORARY_REDIRECT -> s
    int SC_BAD_REQUEST -> t
    int SC_UNAUTHORIZED -> u
    int SC_PAYMENT_REQUIRED -> v
    int SC_FORBIDDEN -> w
    int SC_NOT_FOUND -> x
    int SC_METHOD_NOT_ALLOWED -> y
    int SC_NOT_ACCEPTABLE -> z
    int SC_PROXY_AUTHENTICATION_REQUIRED -> A
    int SC_REQUEST_TIMEOUT -> B
    int SC_CONFLICT -> C
    int SC_GONE -> D
    int SC_LENGTH_REQUIRED -> E
    int SC_PRECONDITION_FAILED -> F
    int SC_REQUEST_TOO_LONG -> G
    int SC_REQUEST_URI_TOO_LONG -> H
    int SC_UNSUPPORTED_MEDIA_TYPE -> I
    int SC_REQUESTED_RANGE_NOT_SATISFIABLE -> J
    int SC_EXPECTATION_FAILED -> K
    int SC_INSUFFICIENT_SPACE_ON_RESOURCE -> L
    int SC_METHOD_FAILURE -> M
    int SC_UNPROCESSABLE_ENTITY -> N
    int SC_LOCKED -> O
    int SC_FAILED_DEPENDENCY -> P
    int SC_INTERNAL_SERVER_ERROR -> Q
    int SC_NOT_IMPLEMENTED -> R
    int SC_BAD_GATEWAY -> S
    int SC_SERVICE_UNAVAILABLE -> T
    int SC_GATEWAY_TIMEOUT -> U
    int SC_HTTP_VERSION_NOT_SUPPORTED -> V
    int SC_INSUFFICIENT_STORAGE -> W
    int getStatusCode() -> a
com.badlogic.gdx.net.NetJavaImpl -> com.badlogic.gdx.g.c:
    java.util.concurrent.ExecutorService executorService -> a
    void sendHttpRequest(com.badlogic.gdx.Net$HttpRequest,com.badlogic.gdx.Net$HttpResponseListener) -> a
com.badlogic.gdx.net.NetJavaImpl$1 -> com.badlogic.gdx.g.d:
    java.lang.String val$method -> a
    com.badlogic.gdx.Net$HttpRequest val$httpRequest -> b
    java.net.HttpURLConnection val$connection -> c
    com.badlogic.gdx.Net$HttpResponseListener val$httpResponseListener -> d
    com.badlogic.gdx.net.NetJavaImpl this$0 -> e
    void run() -> run
com.badlogic.gdx.net.NetJavaImpl$1$1 -> com.badlogic.gdx.g.e:
    com.badlogic.gdx.net.NetJavaImpl$HttpClientResponse val$clientResponse -> a
    com.badlogic.gdx.net.NetJavaImpl$1 this$1 -> b
    void run() -> run
com.badlogic.gdx.net.NetJavaImpl$1$2 -> com.badlogic.gdx.g.f:
    java.lang.Exception val$e -> a
    com.badlogic.gdx.net.NetJavaImpl$1 this$1 -> b
    void run() -> run
com.badlogic.gdx.net.NetJavaImpl$HttpClientResponse -> com.badlogic.gdx.g.g:
    java.net.HttpURLConnection connection -> a
    com.badlogic.gdx.net.HttpStatus status -> b
    java.io.InputStream inputStream -> c
    byte[] getResult() -> a
    java.lang.String getResultAsString() -> b
    java.io.InputStream getResultAsStream() -> c
    com.badlogic.gdx.net.HttpStatus getStatus() -> d
com.badlogic.gdx.net.ServerSocket -> com.badlogic.gdx.g.h:
    com.badlogic.gdx.Net$Protocol getProtocol() -> a
    com.badlogic.gdx.net.Socket accept(com.badlogic.gdx.net.SocketHints) -> a
com.badlogic.gdx.net.ServerSocketHints -> com.badlogic.gdx.g.i:
    int backlog -> a
    int performancePrefConnectionTime -> b
    int performancePrefLatency -> c
    int performancePrefBandwidth -> d
    boolean reuseAddress -> e
    int acceptTimeout -> f
    int receiveBufferSize -> g
com.badlogic.gdx.net.Socket -> com.badlogic.gdx.g.j:
    boolean isConnected() -> a
    java.io.InputStream getInputStream() -> b
    java.io.OutputStream getOutputStream() -> c
com.badlogic.gdx.net.SocketHints -> com.badlogic.gdx.g.k:
    int connectTimeout -> a
    int performancePrefConnectionTime -> b
    int performancePrefLatency -> c
    int performancePrefBandwidth -> d
    int trafficClass -> e
    boolean keepAlive -> f
    boolean tcpNoDelay -> g
    int sendBufferSize -> h
    int receiveBufferSize -> i
    boolean linger -> j
    int lingerDuration -> k
com.badlogic.gdx.physics.box2d.Body -> com.badlogic.gdx.physics.box2d.Body:
    long addr -> a
    float[] tmp -> g
    com.badlogic.gdx.physics.box2d.World world -> h
    java.util.ArrayList fixtures -> i
    java.util.ArrayList joints -> b
    java.lang.Object userData -> j
    com.badlogic.gdx.physics.box2d.Transform transform -> k
    com.badlogic.gdx.math.Vector2 position -> l
    com.badlogic.gdx.math.Vector2 worldCenter -> m
    com.badlogic.gdx.math.Vector2 localCenter -> n
    com.badlogic.gdx.math.Vector2 linearVelocity -> o
    com.badlogic.gdx.physics.box2d.MassData massData -> p
    com.badlogic.gdx.math.Vector2 localPoint -> q
    com.badlogic.gdx.math.Vector2 worldVector -> r
    com.badlogic.gdx.math.Vector2 localPoint2 -> c
    com.badlogic.gdx.math.Vector2 localVector -> d
    com.badlogic.gdx.math.Vector2 linVelWorld -> e
    com.badlogic.gdx.math.Vector2 linVelLoc -> f
    void reset(long) -> a
    com.badlogic.gdx.physics.box2d.Fixture createFixture(com.badlogic.gdx.physics.box2d.FixtureDef) -> a
    long jniCreateFixture(long,long,float,float,float,boolean,short,short,short) -> jniCreateFixture
    com.badlogic.gdx.physics.box2d.Fixture createFixture(com.badlogic.gdx.physics.box2d.Shape,float) -> a
    long jniCreateFixture(long,long,float) -> jniCreateFixture
    void destroyFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
    void jniDestroyFixture(long,long) -> jniDestroyFixture
    void setTransform(com.badlogic.gdx.math.Vector2,float) -> a
    void setTransform(float,float,float) -> a
    void jniSetTransform(long,float,float,float) -> jniSetTransform
    com.badlogic.gdx.physics.box2d.Transform getTransform() -> a
    void jniGetTransform(long,float[]) -> jniGetTransform
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    void jniGetPosition(long,float[]) -> jniGetPosition
    float getAngle() -> c
    float jniGetAngle(long) -> jniGetAngle
    com.badlogic.gdx.math.Vector2 getWorldCenter() -> d
    void jniGetWorldCenter(long,float[]) -> jniGetWorldCenter
    com.badlogic.gdx.math.Vector2 getLocalCenter() -> e
    void jniGetLocalCenter(long,float[]) -> jniGetLocalCenter
    void setLinearVelocity(com.badlogic.gdx.math.Vector2) -> a
    void setLinearVelocity(float,float) -> a
    void jniSetLinearVelocity(long,float,float) -> jniSetLinearVelocity
    com.badlogic.gdx.math.Vector2 getLinearVelocity() -> f
    void jniGetLinearVelocity(long,float[]) -> jniGetLinearVelocity
    void setAngularVelocity(float) -> a
    void jniSetAngularVelocity(long,float) -> jniSetAngularVelocity
    float getAngularVelocity() -> g
    float jniGetAngularVelocity(long) -> jniGetAngularVelocity
    void applyForce(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> a
    void applyForce(float,float,float,float,boolean) -> a
    void jniApplyForce(long,float,float,float,float,boolean) -> jniApplyForce
    void applyForceToCenter(com.badlogic.gdx.math.Vector2,boolean) -> a
    void applyForceToCenter(float,float,boolean) -> a
    void jniApplyForceToCenter(long,float,float,boolean) -> jniApplyForceToCenter
    void applyTorque(float,boolean) -> a
    void jniApplyTorque(long,float,boolean) -> jniApplyTorque
    void applyLinearImpulse(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> b
    void applyLinearImpulse(float,float,float,float,boolean) -> b
    void jniApplyLinearImpulse(long,float,float,float,float,boolean) -> jniApplyLinearImpulse
    void applyAngularImpulse(float,boolean) -> b
    void jniApplyAngularImpulse(long,float,boolean) -> jniApplyAngularImpulse
    float getMass() -> h
    float jniGetMass(long) -> jniGetMass
    float getInertia() -> i
    float jniGetInertia(long) -> jniGetInertia
    com.badlogic.gdx.physics.box2d.MassData getMassData() -> j
    void jniGetMassData(long,float[]) -> jniGetMassData
    void setMassData(com.badlogic.gdx.physics.box2d.MassData) -> a
    void jniSetMassData(long,float,float,float,float) -> jniSetMassData
    void resetMassData() -> k
    void jniResetMassData(long) -> jniResetMassData
    com.badlogic.gdx.math.Vector2 getWorldPoint(com.badlogic.gdx.math.Vector2) -> b
    void jniGetWorldPoint(long,float,float,float[]) -> jniGetWorldPoint
    com.badlogic.gdx.math.Vector2 getWorldVector(com.badlogic.gdx.math.Vector2) -> c
    void jniGetWorldVector(long,float,float,float[]) -> jniGetWorldVector
    com.badlogic.gdx.math.Vector2 getLocalPoint(com.badlogic.gdx.math.Vector2) -> d
    void jniGetLocalPoint(long,float,float,float[]) -> jniGetLocalPoint
    com.badlogic.gdx.math.Vector2 getLocalVector(com.badlogic.gdx.math.Vector2) -> e
    void jniGetLocalVector(long,float,float,float[]) -> jniGetLocalVector
    com.badlogic.gdx.math.Vector2 getLinearVelocityFromWorldPoint(com.badlogic.gdx.math.Vector2) -> f
    void jniGetLinearVelocityFromWorldPoint(long,float,float,float[]) -> jniGetLinearVelocityFromWorldPoint
    com.badlogic.gdx.math.Vector2 getLinearVelocityFromLocalPoint(com.badlogic.gdx.math.Vector2) -> g
    void jniGetLinearVelocityFromLocalPoint(long,float,float,float[]) -> jniGetLinearVelocityFromLocalPoint
    float getLinearDamping() -> l
    float jniGetLinearDamping(long) -> jniGetLinearDamping
    void setLinearDamping(float) -> b
    void jniSetLinearDamping(long,float) -> jniSetLinearDamping
    float getAngularDamping() -> m
    float jniGetAngularDamping(long) -> jniGetAngularDamping
    void setAngularDamping(float) -> c
    void jniSetAngularDamping(long,float) -> jniSetAngularDamping
    void setType(com.badlogic.gdx.physics.box2d.BodyDef$BodyType) -> a
    void jniSetType(long,int) -> jniSetType
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType getType() -> n
    int jniGetType(long) -> jniGetType
    void setBullet(boolean) -> a
    void jniSetBullet(long,boolean) -> jniSetBullet
    boolean isBullet() -> o
    boolean jniIsBullet(long) -> jniIsBullet
    void setSleepingAllowed(boolean) -> b
    void jniSetSleepingAllowed(long,boolean) -> jniSetSleepingAllowed
    boolean isSleepingAllowed() -> p
    boolean jniIsSleepingAllowed(long) -> jniIsSleepingAllowed
    void setAwake(boolean) -> c
    void jniSetAwake(long,boolean) -> jniSetAwake
    boolean isAwake() -> q
    boolean jniIsAwake(long) -> jniIsAwake
    void setActive(boolean) -> d
    void jniSetActive(long,boolean) -> jniSetActive
    boolean isActive() -> r
    boolean jniIsActive(long) -> jniIsActive
    void setFixedRotation(boolean) -> e
    void jniSetFixedRotation(long,boolean) -> jniSetFixedRotation
    boolean isFixedRotation() -> s
    boolean jniIsFixedRotation(long) -> jniIsFixedRotation
    java.util.ArrayList getFixtureList() -> t
    java.util.ArrayList getJointList() -> u
    float getGravityScale() -> v
    float jniGetGravityScale(long) -> jniGetGravityScale
    void setGravityScale(float) -> d
    void jniSetGravityScale(long,float) -> jniSetGravityScale
    com.badlogic.gdx.physics.box2d.World getWorld() -> w
    java.lang.Object getUserData() -> x
    void setUserData(java.lang.Object) -> a
com.badlogic.gdx.physics.box2d.BodyDef -> com.badlogic.gdx.physics.box2d.a:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType type -> a
    com.badlogic.gdx.math.Vector2 position -> b
    float angle -> c
    com.badlogic.gdx.math.Vector2 linearVelocity -> d
    float angularVelocity -> e
    float linearDamping -> f
    float angularDamping -> g
    boolean allowSleep -> h
    boolean awake -> i
    boolean fixedRotation -> j
    boolean bullet -> k
    boolean active -> l
    float gravityScale -> m
com.badlogic.gdx.physics.box2d.BodyDef$BodyType -> com.badlogic.gdx.physics.box2d.b:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType StaticBody -> a
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType KinematicBody -> b
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType DynamicBody -> c
    int value -> d
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] $VALUES -> e
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] values() -> values
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType valueOf(java.lang.String) -> valueOf
    int getValue() -> a
com.badlogic.gdx.physics.box2d.Box2DDebugRenderer -> com.badlogic.gdx.physics.box2d.c:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer renderer -> a
    com.badlogic.gdx.math.Vector2[] vertices -> b
    com.badlogic.gdx.math.Vector2 lower -> c
    com.badlogic.gdx.math.Vector2 upper -> d
    boolean drawBodies -> e
    boolean drawJoints -> f
    boolean drawAABBs -> g
    boolean drawInactiveBodies -> h
    boolean drawVelocities -> i
    boolean drawContacts -> j
    com.badlogic.gdx.graphics.Color SHAPE_NOT_ACTIVE -> k
    com.badlogic.gdx.graphics.Color SHAPE_STATIC -> l
    com.badlogic.gdx.graphics.Color SHAPE_KINEMATIC -> m
    com.badlogic.gdx.graphics.Color SHAPE_NOT_AWAKE -> n
    com.badlogic.gdx.graphics.Color SHAPE_AWAKE -> o
    com.badlogic.gdx.graphics.Color JOINT_COLOR -> p
    com.badlogic.gdx.graphics.Color AABB_COLOR -> q
    com.badlogic.gdx.graphics.Color VELOCITY_COLOR -> r
    com.badlogic.gdx.math.Vector2 t -> s
    com.badlogic.gdx.math.Vector2 axis -> t
    com.badlogic.gdx.math.Vector2 f -> u
    com.badlogic.gdx.math.Vector2 v -> v
    com.badlogic.gdx.math.Vector2 lv -> w
    void render(com.badlogic.gdx.physics.box2d.World,com.badlogic.gdx.math.Matrix4) -> a
    void renderBodies(com.badlogic.gdx.physics.box2d.World) -> a
    void renderBody(com.badlogic.gdx.physics.box2d.Body) -> a
    com.badlogic.gdx.graphics.Color getColorByBody(com.badlogic.gdx.physics.box2d.Body) -> b
    void drawAABB(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Transform) -> a
    void drawShape(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Transform,com.badlogic.gdx.graphics.Color) -> a
    void drawSolidCircle(com.badlogic.gdx.math.Vector2,float,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.graphics.Color) -> a
    void drawSolidPolygon(com.badlogic.gdx.math.Vector2[],int,com.badlogic.gdx.graphics.Color,boolean) -> a
    void drawJoint(com.badlogic.gdx.physics.box2d.Joint) -> a
    void drawSegment(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.graphics.Color) -> a
    void drawContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    boolean isDrawBodies() -> a
    void setDrawBodies(boolean) -> a
    boolean isDrawJoints() -> b
    void setDrawJoints(boolean) -> b
    boolean isDrawAABBs() -> c
    void setDrawAABBs(boolean) -> c
    boolean isDrawInactiveBodies() -> d
    void setDrawInactiveBodies(boolean) -> d
    boolean isDrawVelocities() -> e
    void setDrawVelocities(boolean) -> e
    boolean isDrawContacts() -> f
    void setDrawContacts(boolean) -> f
    com.badlogic.gdx.math.Vector2 getAxis() -> g
    void setAxis(com.badlogic.gdx.math.Vector2) -> a
    void dispose() -> h
com.badlogic.gdx.physics.box2d.ChainShape -> com.badlogic.gdx.physics.box2d.ChainShape:
    boolean isLooped -> a
    float[] verts -> c
    long newChainShape() -> newChainShape
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
    void createLoop(com.badlogic.gdx.math.Vector2[]) -> a
    void jniCreateLoop(long,float[],int) -> jniCreateLoop
    void createChain(com.badlogic.gdx.math.Vector2[]) -> b
    void jniCreateChain(long,float[],int) -> jniCreateChain
    void setPrevVertex(com.badlogic.gdx.math.Vector2) -> a
    void setPrevVertex(float,float) -> a
    void jniSetPrevVertex(long,float,float) -> jniSetPrevVertex
    void setNextVertex(com.badlogic.gdx.math.Vector2) -> b
    void setNextVertex(float,float) -> b
    void jniSetNextVertex(long,float,float) -> jniSetNextVertex
    int getVertexCount() -> b
    int jniGetVertexCount(long) -> jniGetVertexCount
    void getVertex(int,com.badlogic.gdx.math.Vector2) -> a
    void jniGetVertex(long,int,float[]) -> jniGetVertex
    boolean isLooped() -> c
com.badlogic.gdx.physics.box2d.CircleShape -> com.badlogic.gdx.physics.box2d.CircleShape:
    float[] tmp -> a
    com.badlogic.gdx.math.Vector2 position -> c
    long newCircleShape() -> newCircleShape
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    void jniGetPosition(long,float[]) -> jniGetPosition
    void setPosition(com.badlogic.gdx.math.Vector2) -> a
    void jniSetPosition(long,float,float) -> jniSetPosition
com.badlogic.gdx.physics.box2d.Contact -> com.badlogic.gdx.physics.box2d.Contact:
    long addr -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    com.badlogic.gdx.physics.box2d.WorldManifold worldManifold -> c
    float[] tmp -> d
    com.badlogic.gdx.physics.box2d.WorldManifold getWorldManifold() -> a
    int jniGetWorldManifold(long,float[]) -> jniGetWorldManifold
    boolean isTouching() -> b
    boolean jniIsTouching(long) -> jniIsTouching
    void setEnabled(boolean) -> a
    void jniSetEnabled(long,boolean) -> jniSetEnabled
    boolean isEnabled() -> c
    boolean jniIsEnabled(long) -> jniIsEnabled
    com.badlogic.gdx.physics.box2d.Fixture getFixtureA() -> d
    long jniGetFixtureA(long) -> jniGetFixtureA
    com.badlogic.gdx.physics.box2d.Fixture getFixtureB() -> e
    long jniGetFixtureB(long) -> jniGetFixtureB
    int getChildIndexA() -> f
    int jniGetChildIndexA(long) -> jniGetChildIndexA
    int getChildIndexB() -> g
    int jniGetChildIndexB(long) -> jniGetChildIndexB
    void setFriction(float) -> a
    void jniSetFriction(long,float) -> jniSetFriction
    float getFriction() -> h
    float jniGetFriction(long) -> jniGetFriction
    void resetFriction() -> i
    void jniResetFriction(long) -> jniResetFriction
    void setRestitution(float) -> b
    void jniSetRestitution(long,float) -> jniSetRestitution
    float getRestitution() -> j
    float jniGetRestitution(long) -> jniGetRestitution
    void ResetRestitution() -> k
    void jniResetRestitution(long) -> jniResetRestitution
com.badlogic.gdx.physics.box2d.ContactFilter -> com.badlogic.gdx.physics.box2d.d:
    boolean shouldCollide(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.ContactImpulse -> com.badlogic.gdx.physics.box2d.ContactImpulse:
    com.badlogic.gdx.physics.box2d.World world -> a
    long addr -> b
    float[] tmp -> c
    float[] normalImpulses -> d
    float[] tangentImpulses -> e
    float[] getNormalImpulses() -> a
    void jniGetNormalImpulses(long,float[]) -> jniGetNormalImpulses
    float[] getTangentImpulses() -> b
    void jniGetTangentImpulses(long,float[]) -> jniGetTangentImpulses
    int getCount() -> c
    int jniGetCount(long) -> jniGetCount
com.badlogic.gdx.physics.box2d.ContactListener -> com.badlogic.gdx.physics.box2d.e:
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
com.badlogic.gdx.physics.box2d.DestructionListener -> com.badlogic.gdx.physics.box2d.f:
com.badlogic.gdx.physics.box2d.EdgeShape -> com.badlogic.gdx.physics.box2d.EdgeShape:
    float[] vertex -> a
    long newEdgeShape() -> newEdgeShape
    void set(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void set(float,float,float,float) -> a
    void jniSet(long,float,float,float,float) -> jniSet
    void getVertex1(com.badlogic.gdx.math.Vector2) -> a
    void jniGetVertex1(long,float[]) -> jniGetVertex1
    void getVertex2(com.badlogic.gdx.math.Vector2) -> b
    void jniGetVertex2(long,float[]) -> jniGetVertex2
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
com.badlogic.gdx.physics.box2d.Filter -> com.badlogic.gdx.physics.box2d.g:
    short categoryBits -> a
    short maskBits -> b
    short groupIndex -> c
com.badlogic.gdx.physics.box2d.Fixture -> com.badlogic.gdx.physics.box2d.Fixture:
    com.badlogic.gdx.physics.box2d.Body body -> d
    long addr -> a
    com.badlogic.gdx.physics.box2d.Shape shape -> b
    java.lang.Object userData -> c
    short[] tmp -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
    void reset(com.badlogic.gdx.physics.box2d.Body,long) -> a
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
    int jniGetType(long) -> jniGetType
    com.badlogic.gdx.physics.box2d.Shape getShape() -> b
    long jniGetShape(long) -> jniGetShape
    void setSensor(boolean) -> a
    void jniSetSensor(long,boolean) -> jniSetSensor
    boolean isSensor() -> c
    boolean jniIsSensor(long) -> jniIsSensor
    void setFilterData(com.badlogic.gdx.physics.box2d.Filter) -> a
    void jniSetFilterData(long,short,short,short) -> jniSetFilterData
    com.badlogic.gdx.physics.box2d.Filter getFilterData() -> d
    void jniGetFilterData(long,short[]) -> jniGetFilterData
    void refilter() -> e
    void jniRefilter(long) -> jniRefilter
    com.badlogic.gdx.physics.box2d.Body getBody() -> f
    boolean testPoint(com.badlogic.gdx.math.Vector2) -> a
    boolean testPoint(float,float) -> a
    boolean jniTestPoint(long,float,float) -> jniTestPoint
    void setDensity(float) -> a
    void jniSetDensity(long,float) -> jniSetDensity
    float getDensity() -> g
    float jniGetDensity(long) -> jniGetDensity
    float getFriction() -> h
    float jniGetFriction(long) -> jniGetFriction
    void setFriction(float) -> b
    void jniSetFriction(long,float) -> jniSetFriction
    float getRestitution() -> i
    float jniGetRestitution(long) -> jniGetRestitution
    void setRestitution(float) -> c
    void jniSetRestitution(long,float) -> jniSetRestitution
    void setUserData(java.lang.Object) -> a
    java.lang.Object getUserData() -> j
com.badlogic.gdx.physics.box2d.FixtureDef -> com.badlogic.gdx.physics.box2d.h:
    com.badlogic.gdx.physics.box2d.Shape shape -> a
    float friction -> b
    float restitution -> c
    float density -> d
    boolean isSensor -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
com.badlogic.gdx.physics.box2d.Joint -> com.badlogic.gdx.physics.box2d.Joint:
    long addr -> a
    com.badlogic.gdx.physics.box2d.World world -> d
    float[] tmp -> e
    java.lang.Object userData -> f
    com.badlogic.gdx.physics.box2d.JointEdge jointEdgeA -> b
    com.badlogic.gdx.physics.box2d.JointEdge jointEdgeB -> c
    com.badlogic.gdx.math.Vector2 anchorA -> g
    com.badlogic.gdx.math.Vector2 anchorB -> h
    com.badlogic.gdx.math.Vector2 reactionForce -> i
    com.badlogic.gdx.physics.box2d.JointDef$JointType getType() -> a
    int jniGetType(long) -> jniGetType
    com.badlogic.gdx.physics.box2d.Body getBodyA() -> b
    long jniGetBodyA(long) -> jniGetBodyA
    com.badlogic.gdx.physics.box2d.Body getBodyB() -> c
    long jniGetBodyB(long) -> jniGetBodyB
    com.badlogic.gdx.math.Vector2 getAnchorA() -> d
    void jniGetAnchorA(long,float[]) -> jniGetAnchorA
    com.badlogic.gdx.math.Vector2 getAnchorB() -> e
    void jniGetAnchorB(long,float[]) -> jniGetAnchorB
    com.badlogic.gdx.math.Vector2 getReactionForce(float) -> a
    void jniGetReactionForce(long,float,float[]) -> jniGetReactionForce
    float getReactionTorque(float) -> b
    float jniGetReactionTorque(long,float) -> jniGetReactionTorque
    java.lang.Object getUserData() -> f
    void setUserData(java.lang.Object) -> a
    boolean isActive() -> g
    boolean jniIsActive(long) -> jniIsActive
com.badlogic.gdx.physics.box2d.JointDef -> com.badlogic.gdx.physics.box2d.i:
    com.badlogic.gdx.physics.box2d.JointDef$JointType type -> a
    com.badlogic.gdx.physics.box2d.Body bodyA -> b
    com.badlogic.gdx.physics.box2d.Body bodyB -> c
    boolean collideConnected -> d
com.badlogic.gdx.physics.box2d.JointDef$JointType -> com.badlogic.gdx.physics.box2d.j:
    com.badlogic.gdx.physics.box2d.JointDef$JointType Unknown -> a
    com.badlogic.gdx.physics.box2d.JointDef$JointType RevoluteJoint -> b
    com.badlogic.gdx.physics.box2d.JointDef$JointType PrismaticJoint -> c
    com.badlogic.gdx.physics.box2d.JointDef$JointType DistanceJoint -> d
    com.badlogic.gdx.physics.box2d.JointDef$JointType PulleyJoint -> e
    com.badlogic.gdx.physics.box2d.JointDef$JointType MouseJoint -> f
    com.badlogic.gdx.physics.box2d.JointDef$JointType GearJoint -> g
    com.badlogic.gdx.physics.box2d.JointDef$JointType WheelJoint -> h
    com.badlogic.gdx.physics.box2d.JointDef$JointType WeldJoint -> i
    com.badlogic.gdx.physics.box2d.JointDef$JointType FrictionJoint -> j
    com.badlogic.gdx.physics.box2d.JointDef$JointType RopeJoint -> k
    com.badlogic.gdx.physics.box2d.JointDef$JointType[] valueTypes -> l
    int value -> m
    com.badlogic.gdx.physics.box2d.JointDef$JointType[] $VALUES -> n
    com.badlogic.gdx.physics.box2d.JointDef$JointType[] values() -> values
    com.badlogic.gdx.physics.box2d.JointDef$JointType valueOf(java.lang.String) -> valueOf
    int getValue() -> a
com.badlogic.gdx.physics.box2d.JointEdge -> com.badlogic.gdx.physics.box2d.k:
    com.badlogic.gdx.physics.box2d.Body other -> a
    com.badlogic.gdx.physics.box2d.Joint joint -> b
com.badlogic.gdx.physics.box2d.Manifold -> com.badlogic.gdx.physics.box2d.Manifold:
    long addr -> a
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint[] points -> b
    com.badlogic.gdx.math.Vector2 localNormal -> c
    com.badlogic.gdx.math.Vector2 localPoint -> d
    int[] tmpInt -> e
    float[] tmpFloat -> f
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType getType() -> a
    int jniGetType(long) -> jniGetType
    int getPointCount() -> b
    int jniGetPointCount(long) -> jniGetPointCount
    com.badlogic.gdx.math.Vector2 getLocalNormal() -> c
    void jniGetLocalNormal(long,float[]) -> jniGetLocalNormal
    com.badlogic.gdx.math.Vector2 getLocalPoint() -> d
    void jniGetLocalPoint(long,float[]) -> jniGetLocalPoint
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint[] getPoints() -> e
    int jniGetPoint(long,float[],int) -> jniGetPoint
com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint -> com.badlogic.gdx.physics.box2d.l:
    com.badlogic.gdx.math.Vector2 localPoint -> a
    float normalImpulse -> b
    float tangentImpulse -> c
    int contactID -> d
    com.badlogic.gdx.physics.box2d.Manifold this$0 -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.physics.box2d.Manifold$ManifoldType -> com.badlogic.gdx.physics.box2d.m:
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType Circle -> a
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType FaceA -> b
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType FaceB -> c
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType[] $VALUES -> d
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType[] values() -> values
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.physics.box2d.MassData -> com.badlogic.gdx.physics.box2d.n:
    float mass -> a
    com.badlogic.gdx.math.Vector2 center -> b
    float I -> c
com.badlogic.gdx.physics.box2d.PolygonShape -> com.badlogic.gdx.physics.box2d.PolygonShape:
    float[] verts -> a
    long newPolygonShape() -> newPolygonShape
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
    void set(com.badlogic.gdx.math.Vector2[]) -> a
    void set(float[]) -> a
    void set(float[],int,int) -> a
    void jniSet(long,float[],int,int) -> jniSet
    void setAsBox(float,float) -> a
    void jniSetAsBox(long,float,float) -> jniSetAsBox
    void setAsBox(float,float,com.badlogic.gdx.math.Vector2,float) -> a
    void jniSetAsBox(long,float,float,float,float,float) -> jniSetAsBox
    int getVertexCount() -> b
    int jniGetVertexCount(long) -> jniGetVertexCount
    void getVertex(int,com.badlogic.gdx.math.Vector2) -> a
    void jniGetVertex(long,int,float[]) -> jniGetVertex
com.badlogic.gdx.physics.box2d.QueryCallback -> com.badlogic.gdx.physics.box2d.o:
    boolean reportFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.RayCastCallback -> com.badlogic.gdx.physics.box2d.p:
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.physics.box2d.Shape -> com.badlogic.gdx.physics.box2d.Shape:
    long addr -> b
    com.badlogic.gdx.physics.box2d.Shape$Type getType() -> a
    float getRadius() -> d
    float jniGetRadius(long) -> jniGetRadius
    void setRadius(float) -> a
    void jniSetRadius(long,float) -> jniSetRadius
    void dispose() -> e
    void jniDispose(long) -> jniDispose
    int jniGetType(long) -> jniGetType
    int getChildCount() -> f
    int jniGetChildCount(long) -> jniGetChildCount
com.badlogic.gdx.physics.box2d.Shape$Type -> com.badlogic.gdx.physics.box2d.q:
    com.badlogic.gdx.physics.box2d.Shape$Type Circle -> a
    com.badlogic.gdx.physics.box2d.Shape$Type Polygon -> b
    com.badlogic.gdx.physics.box2d.Shape$Type Edge -> c
    com.badlogic.gdx.physics.box2d.Shape$Type Chain -> d
    com.badlogic.gdx.physics.box2d.Shape$Type[] $VALUES -> e
    com.badlogic.gdx.physics.box2d.Shape$Type[] values() -> values
    com.badlogic.gdx.physics.box2d.Shape$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.physics.box2d.Transform -> com.badlogic.gdx.physics.box2d.r:
    int POS_X -> a
    int POS_Y -> b
    int COS -> c
    int SIN -> d
    float[] vals -> e
    com.badlogic.gdx.math.Vector2 position -> f
    com.badlogic.gdx.math.Vector2 mul(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> a
    void setRotation(float) -> a
    float getRotation() -> b
    void setPosition(com.badlogic.gdx.math.Vector2) -> b
com.badlogic.gdx.physics.box2d.World -> com.badlogic.gdx.physics.box2d.World:
    com.badlogic.gdx.utils.Pool freeBodies -> a
    com.badlogic.gdx.utils.Pool freeFixtures -> b
    long addr -> j
    com.badlogic.gdx.utils.LongMap bodies -> c
    com.badlogic.gdx.utils.LongMap fixtures -> d
    com.badlogic.gdx.utils.LongMap joints -> e
    com.badlogic.gdx.physics.box2d.ContactFilter contactFilter -> f
    com.badlogic.gdx.physics.box2d.ContactListener contactListener -> g
    float[] tmpGravity -> h
    com.badlogic.gdx.math.Vector2 gravity -> i
    com.badlogic.gdx.physics.box2d.QueryCallback queryCallback -> k
    long[] contactAddrs -> l
    java.util.ArrayList contacts -> m
    java.util.ArrayList freeContacts -> n
    com.badlogic.gdx.physics.box2d.Contact contact -> o
    com.badlogic.gdx.physics.box2d.Manifold manifold -> p
    com.badlogic.gdx.physics.box2d.ContactImpulse impulse -> q
    com.badlogic.gdx.physics.box2d.RayCastCallback rayCastCallback -> r
    com.badlogic.gdx.math.Vector2 rayPoint -> s
    com.badlogic.gdx.math.Vector2 rayNormal -> t
    long newWorld(float,float,boolean) -> newWorld
    void setDestructionListener(com.badlogic.gdx.physics.box2d.DestructionListener) -> a
    void setContactFilter(com.badlogic.gdx.physics.box2d.ContactFilter) -> a
    void setUseDefaultContactFilter(boolean) -> setUseDefaultContactFilter
    void setContactListener(com.badlogic.gdx.physics.box2d.ContactListener) -> a
    com.badlogic.gdx.physics.box2d.Body createBody(com.badlogic.gdx.physics.box2d.BodyDef) -> a
    long jniCreateBody(long,int,float,float,float,float,float,float,float,float,boolean,boolean,boolean,boolean,boolean,float) -> jniCreateBody
    void destroyBody(com.badlogic.gdx.physics.box2d.Body) -> a
    void jniDestroyBody(long,long) -> jniDestroyBody
    com.badlogic.gdx.physics.box2d.Joint createJoint(com.badlogic.gdx.physics.box2d.JointDef) -> a
    long createProperJoint(com.badlogic.gdx.physics.box2d.JointDef) -> b
    long jniCreateWheelJoint(long,long,long,boolean,float,float,float,float,float,float,boolean,float,float,float,float) -> jniCreateWheelJoint
    long jniCreateRopeJoint(long,long,long,boolean,float,float,float,float,float) -> jniCreateRopeJoint
    long jniCreateDistanceJoint(long,long,long,boolean,float,float,float,float,float,float,float) -> jniCreateDistanceJoint
    long jniCreateFrictionJoint(long,long,long,boolean,float,float,float,float,float,float) -> jniCreateFrictionJoint
    long jniCreateGearJoint(long,long,long,boolean,long,long,float) -> jniCreateGearJoint
    long jniCreateMouseJoint(long,long,long,boolean,float,float,float,float,float) -> jniCreateMouseJoint
    long jniCreatePrismaticJoint(long,long,long,boolean,float,float,float,float,float,float,float,boolean,float,float,boolean,float,float) -> jniCreatePrismaticJoint
    long jniCreatePulleyJoint(long,long,long,boolean,float,float,float,float,float,float,float,float,float,float,float) -> jniCreatePulleyJoint
    long jniCreateRevoluteJoint(long,long,long,boolean,float,float,float,float,float,boolean,float,float,boolean,float,float) -> jniCreateRevoluteJoint
    long jniCreateWeldJoint(long,long,long,boolean,float,float,float,float,float) -> jniCreateWeldJoint
    void destroyJoint(com.badlogic.gdx.physics.box2d.Joint) -> a
    void jniDestroyJoint(long,long) -> jniDestroyJoint
    void step(float,int,int) -> a
    void jniStep(long,float,int,int) -> jniStep
    void clearForces() -> a
    void jniClearForces(long) -> jniClearForces
    void setWarmStarting(boolean) -> a
    void jniSetWarmStarting(long,boolean) -> jniSetWarmStarting
    void setContinuousPhysics(boolean) -> b
    void jniSetContiousPhysics(long,boolean) -> jniSetContiousPhysics
    int getProxyCount() -> b
    int jniGetProxyCount(long) -> jniGetProxyCount
    int getBodyCount() -> c
    int jniGetBodyCount(long) -> jniGetBodyCount
    int getJointCount() -> d
    int jniGetJointcount(long) -> jniGetJointcount
    int getContactCount() -> f
    int jniGetContactCount(long) -> jniGetContactCount
    void setGravity(com.badlogic.gdx.math.Vector2) -> a
    void jniSetGravity(long,float,float) -> jniSetGravity
    com.badlogic.gdx.math.Vector2 getGravity() -> g
    void jniGetGravity(long,float[]) -> jniGetGravity
    boolean isLocked() -> h
    boolean jniIsLocked(long) -> jniIsLocked
    void setAutoClearForces(boolean) -> c
    void jniSetAutoClearForces(long,boolean) -> jniSetAutoClearForces
    boolean getAutoClearForces() -> i
    boolean jniGetAutoClearForces(long) -> jniGetAutoClearForces
    void QueryAABB(com.badlogic.gdx.physics.box2d.QueryCallback,float,float,float,float) -> a
    void jniQueryAABB(long,float,float,float,float) -> jniQueryAABB
    java.util.List getContactList() -> j
    java.util.Iterator getBodies() -> k
    java.util.Iterator getJoints() -> l
    void jniGetContactList(long,long[]) -> jniGetContactList
    void dispose() -> e
    void jniDispose(long) -> jniDispose
    boolean contactFilter(long,long) -> a
    void beginContact(long) -> a
    void endContact(long) -> b
    void preSolve(long,long) -> b
    void postSolve(long,long) -> c
    boolean reportFixture(long) -> c
    void setVelocityThreshold(float) -> setVelocityThreshold
    float getVelocityThreshold() -> getVelocityThreshold
    void rayCast(com.badlogic.gdx.physics.box2d.RayCastCallback,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void jniRayCast(long,float,float,float,float) -> jniRayCast
    float reportRayFixture(long,float,float,float,float,float) -> a
com.badlogic.gdx.physics.box2d.World$1 -> com.badlogic.gdx.physics.box2d.s:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Body newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.World$2 -> com.badlogic.gdx.physics.box2d.t:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Fixture newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.WorldManifold -> com.badlogic.gdx.physics.box2d.u:
    com.badlogic.gdx.math.Vector2 normal -> a
    com.badlogic.gdx.math.Vector2[] points -> b
    int numContactPoints -> c
    com.badlogic.gdx.math.Vector2 getNormal() -> a
    com.badlogic.gdx.math.Vector2[] getPoints() -> b
    int getNumberOfContactPoints() -> c
com.badlogic.gdx.physics.box2d.joints.DistanceJoint -> com.badlogic.gdx.physics.box2d.joints.DistanceJoint:
    void setLength(float) -> c
    void jniSetLength(long,float) -> jniSetLength
    float getLength() -> h
    float jniGetLength(long) -> jniGetLength
    void setFrequency(float) -> d
    void jniSetFrequency(long,float) -> jniSetFrequency
    float getFrequency() -> i
    float jniGetFrequency(long) -> jniGetFrequency
    void setDampingRatio(float) -> e
    void jniSetDampingRatio(long,float) -> jniSetDampingRatio
    float getDampingRatio() -> j
    float jniGetDampingRatio(long) -> jniGetDampingRatio
com.badlogic.gdx.physics.box2d.joints.DistanceJointDef -> com.badlogic.gdx.physics.box2d.joints.a:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    float length -> g
    float frequencyHz -> h
    float dampingRatio -> i
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.joints.FrictionJoint -> com.badlogic.gdx.physics.box2d.joints.FrictionJoint:
    void setMaxForce(float) -> c
    void jniSetMaxForce(long,float) -> jniSetMaxForce
    float getMaxForce() -> h
    float jniGetMaxForce(long) -> jniGetMaxForce
    void setMaxTorque(float) -> d
    void jniSetMaxTorque(long,float) -> jniSetMaxTorque
    float getMaxTorque() -> i
    float jniGetMaxTorque(long) -> jniGetMaxTorque
com.badlogic.gdx.physics.box2d.joints.FrictionJointDef -> com.badlogic.gdx.physics.box2d.joints.b:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    float maxForce -> g
    float maxTorque -> h
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.joints.GearJoint -> com.badlogic.gdx.physics.box2d.joints.GearJoint:
    void setRatio(float) -> c
    void jniSetRatio(long,float) -> jniSetRatio
    float getRatio() -> h
    float jniGetRatio(long) -> jniGetRatio
com.badlogic.gdx.physics.box2d.joints.GearJointDef -> com.badlogic.gdx.physics.box2d.joints.c:
    com.badlogic.gdx.physics.box2d.Joint joint1 -> e
    com.badlogic.gdx.physics.box2d.Joint joint2 -> f
    float ratio -> g
com.badlogic.gdx.physics.box2d.joints.MouseJoint -> com.badlogic.gdx.physics.box2d.joints.MouseJoint:
    float[] tmp -> d
    com.badlogic.gdx.math.Vector2 target -> e
    void setTarget(com.badlogic.gdx.math.Vector2) -> a
    void jniSetTarget(long,float,float) -> jniSetTarget
    com.badlogic.gdx.math.Vector2 getTarget() -> h
    void jniGetTarget(long,float[]) -> jniGetTarget
    void setMaxForce(float) -> c
    void jniSetMaxForce(long,float) -> jniSetMaxForce
    float getMaxForce() -> i
    float jniGetMaxForce(long) -> jniGetMaxForce
    void setFrequency(float) -> d
    void jniSetFrequency(long,float) -> jniSetFrequency
    float getFrequency() -> j
    float jniGetFrequency(long) -> jniGetFrequency
    void setDampingRatio(float) -> e
    void jniSetDampingRatio(long,float) -> jniSetDampingRatio
    float getDampingRatio() -> k
    float jniGetDampingRatio(long) -> jniGetDampingRatio
com.badlogic.gdx.physics.box2d.joints.MouseJointDef -> com.badlogic.gdx.physics.box2d.joints.d:
    com.badlogic.gdx.math.Vector2 target -> e
    float maxForce -> f
    float frequencyHz -> g
    float dampingRatio -> h
com.badlogic.gdx.physics.box2d.joints.PrismaticJoint -> com.badlogic.gdx.physics.box2d.joints.PrismaticJoint:
    float getJointTranslation() -> h
    float jniGetJointTranslation(long) -> jniGetJointTranslation
    float getJointSpeed() -> i
    float jniGetJointSpeed(long) -> jniGetJointSpeed
    boolean isLimitEnabled() -> j
    boolean jniIsLimitEnabled(long) -> jniIsLimitEnabled
    void enableLimit(boolean) -> a
    void jniEnableLimit(long,boolean) -> jniEnableLimit
    float getLowerLimit() -> k
    float jniGetLowerLimit(long) -> jniGetLowerLimit
    float getUpperLimit() -> l
    float jniGetUpperLimit(long) -> jniGetUpperLimit
    void setLimits(float,float) -> a
    void jniSetLimits(long,float,float) -> jniSetLimits
    boolean isMotorEnabled() -> m
    boolean jniIsMotorEnabled(long) -> jniIsMotorEnabled
    void enableMotor(boolean) -> b
    void jniEnableMotor(long,boolean) -> jniEnableMotor
    void setMotorSpeed(float) -> c
    void jniSetMotorSpeed(long,float) -> jniSetMotorSpeed
    float getMotorSpeed() -> n
    float jniGetMotorSpeed(long) -> jniGetMotorSpeed
    void setMaxMotorForce(float) -> d
    void jniSetMaxMotorForce(long,float) -> jniSetMaxMotorForce
    float getMotorForce(float) -> e
    float jniGetMotorForce(long,float) -> jniGetMotorForce
com.badlogic.gdx.physics.box2d.joints.PrismaticJointDef -> com.badlogic.gdx.physics.box2d.joints.e:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    com.badlogic.gdx.math.Vector2 localAxisA -> g
    float referenceAngle -> h
    boolean enableLimit -> i
    float lowerTranslation -> j
    float upperTranslation -> k
    boolean enableMotor -> l
    float maxMotorForce -> m
    float motorSpeed -> n
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.joints.PulleyJoint -> com.badlogic.gdx.physics.box2d.joints.PulleyJoint:
    float[] tmp -> d
    com.badlogic.gdx.math.Vector2 groundAnchorA -> e
    com.badlogic.gdx.math.Vector2 groundAnchorB -> f
    com.badlogic.gdx.math.Vector2 getGroundAnchorA() -> h
    void jniGetGroundAnchorA(long,float[]) -> jniGetGroundAnchorA
    com.badlogic.gdx.math.Vector2 getGroundAnchorB() -> i
    void jniGetGroundAnchorB(long,float[]) -> jniGetGroundAnchorB
    float getLength1() -> j
    float jniGetLength1(long) -> jniGetLength1
    float getLength2() -> k
    float jniGetLength2(long) -> jniGetLength2
    float getRatio() -> l
    float jniGetRatio(long) -> jniGetRatio
com.badlogic.gdx.physics.box2d.joints.PulleyJointDef -> com.badlogic.gdx.physics.box2d.joints.f:
    float minPulleyLength -> l
    com.badlogic.gdx.math.Vector2 groundAnchorA -> e
    com.badlogic.gdx.math.Vector2 groundAnchorB -> f
    com.badlogic.gdx.math.Vector2 localAnchorA -> g
    com.badlogic.gdx.math.Vector2 localAnchorB -> h
    float lengthA -> i
    float lengthB -> j
    float ratio -> k
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.physics.box2d.joints.RevoluteJoint -> com.badlogic.gdx.physics.box2d.joints.RevoluteJoint:
    float getJointAngle() -> h
    float jniGetJointAngle(long) -> jniGetJointAngle
    float getJointSpeed() -> i
    float jniGetJointSpeed(long) -> jniGetJointSpeed
    boolean isLimitEnabled() -> j
    boolean jniIsLimitEnabled(long) -> jniIsLimitEnabled
    void enableLimit(boolean) -> a
    void jniEnableLimit(long,boolean) -> jniEnableLimit
    float getLowerLimit() -> k
    float jniGetLowerLimit(long) -> jniGetLowerLimit
    float getUpperLimit() -> l
    float jniGetUpperLimit(long) -> jniGetUpperLimit
    void setLimits(float,float) -> a
    void jniSetLimits(long,float,float) -> jniSetLimits
    boolean isMotorEnabled() -> m
    boolean jniIsMotorEnabled(long) -> jniIsMotorEnabled
    void enableMotor(boolean) -> b
    void jniEnableMotor(long,boolean) -> jniEnableMotor
    void setMotorSpeed(float) -> c
    void jniSetMotorSpeed(long,float) -> jniSetMotorSpeed
    float getMotorSpeed() -> n
    float jniGetMotorSpeed(long) -> jniGetMotorSpeed
    void setMaxMotorTorque(float) -> d
    void jniSetMaxMotorTorque(long,float) -> jniSetMaxMotorTorque
    float getMotorTorque(float) -> e
    float jniGetMotorTorque(long,float) -> jniGetMotorTorque
com.badlogic.gdx.physics.box2d.joints.RevoluteJointDef -> com.badlogic.gdx.physics.box2d.joints.g:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    float referenceAngle -> g
    boolean enableLimit -> h
    float lowerAngle -> i
    float upperAngle -> j
    boolean enableMotor -> k
    float motorSpeed -> l
    float maxMotorTorque -> m
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.joints.RopeJoint -> com.badlogic.gdx.physics.box2d.joints.RopeJoint:
    float getMaxLength() -> h
    float jniGetMaxLength(long) -> jniGetMaxLength
    void setMaxLength(float) -> c
    float jniSetMaxLength(long,float) -> jniSetMaxLength
com.badlogic.gdx.physics.box2d.joints.RopeJointDef -> com.badlogic.gdx.physics.box2d.joints.h:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    float maxLength -> g
com.badlogic.gdx.physics.box2d.joints.WeldJoint -> com.badlogic.gdx.physics.box2d.joints.WeldJoint:
    float getReferenceAngle() -> h
    float jniGetReferenceAngle(long) -> jniGetReferenceAngle
com.badlogic.gdx.physics.box2d.joints.WeldJointDef -> com.badlogic.gdx.physics.box2d.joints.i:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    float referenceAngle -> g
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.joints.WheelJoint -> com.badlogic.gdx.physics.box2d.joints.WheelJoint:
    float getJointTranslation() -> h
    float jniGetJointTranslation(long) -> jniGetJointTranslation
    float getJointSpeed() -> i
    float jniGetJointSpeed(long) -> jniGetJointSpeed
    boolean isMotorEnabled() -> n
    boolean jniIsMotorEnabled(long) -> jniIsMotorEnabled
    void enableMotor(boolean) -> a
    void jniEnableMotor(long,boolean) -> jniEnableMotor
    void setMotorSpeed(float) -> c
    void jniSetMotorSpeed(long,float) -> jniSetMotorSpeed
    float getMotorSpeed() -> j
    float jniGetMotorSpeed(long) -> jniGetMotorSpeed
    void setMaxMotorTorque(float) -> d
    void jniSetMaxMotorTorque(long,float) -> jniSetMaxMotorTorque
    float getMaxMotorTorque() -> k
    float jniGetMaxMotorTorque(long) -> jniGetMaxMotorTorque
    float getMotorTorque(float) -> e
    float jniGetMotorTorque(long,float) -> jniGetMotorTorque
    void setSpringFrequencyHz(float) -> f
    void jniSetSpringFrequencyHz(long,float) -> jniSetSpringFrequencyHz
    float getSpringFrequencyHz() -> l
    float jniGetSpringFrequencyHz(long) -> jniGetSpringFrequencyHz
    void setSpringDampingRatio(float) -> g
    void jniSetSpringDampingRatio(long,float) -> jniSetSpringDampingRatio
    float getSpringDampingRatio() -> m
    float jniGetSpringDampingRatio(long) -> jniGetSpringDampingRatio
com.badlogic.gdx.physics.box2d.joints.WheelJointDef -> com.badlogic.gdx.physics.box2d.joints.j:
    com.badlogic.gdx.math.Vector2 localAnchorA -> e
    com.badlogic.gdx.math.Vector2 localAnchorB -> f
    com.badlogic.gdx.math.Vector2 localAxisA -> g
    boolean enableMotor -> h
    float maxMotorTorque -> i
    float motorSpeed -> j
    float frequencyHz -> k
    float dampingRatio -> l
    void initialize(com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.physics.box2d.Body,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.scenes.scene2d.Action -> com.badlogic.gdx.h.a.a:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    com.badlogic.gdx.utils.Pool pool -> b
    boolean act(float) -> a
    void restart() -> a
    com.badlogic.gdx.scenes.scene2d.Actor getActor() -> b
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void reset() -> c
    com.badlogic.gdx.utils.Pool getPool() -> d
    void setPool(com.badlogic.gdx.utils.Pool) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Actor -> com.badlogic.gdx.h.a.b:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> k
    com.badlogic.gdx.scenes.scene2d.Group parent -> l
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> m
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> n
    com.badlogic.gdx.utils.Array actions -> o
    java.lang.String name -> p
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> q
    boolean visible -> r
    float x -> a
    float y -> b
    float width -> c
    float height -> d
    float originX -> e
    float originY -> f
    float scaleX -> g
    float scaleY -> h
    float rotation -> i
    com.badlogic.gdx.graphics.Color color -> j
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void act(float) -> a
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean remove() -> a
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b
    com.badlogic.gdx.utils.Array getListeners() -> b
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> c
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> d
    com.badlogic.gdx.utils.Array getCaptureListeners() -> c
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void removeAction(com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.utils.Array getActions() -> d
    void clearActions() -> e
    void clearListeners() -> f
    void clear() -> g
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> h
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean isAscendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean hasParent() -> i
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> j
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> a
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> k
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
    boolean isVisible() -> l
    void setVisible(boolean) -> a
    float getX() -> m
    void setX(float) -> b
    float getY() -> n
    void setY(float) -> c
    void setPosition(float,float) -> a
    void translate(float,float) -> b
    float getWidth() -> o
    void setWidth(float) -> d
    float getHeight() -> p
    void setHeight(float) -> e
    float getTop() -> q
    float getRight() -> r
    void setSize(float,float) -> c
    void size(float) -> f
    void size(float,float) -> d
    void setBounds(float,float,float,float) -> a
    float getOriginX() -> s
    void setOriginX(float) -> g
    float getOriginY() -> t
    void setOriginY(float) -> h
    void setOrigin(float,float) -> e
    float getScaleX() -> u
    void setScaleX(float) -> i
    float getScaleY() -> v
    void setScaleY(float) -> j
    void setScale(float) -> k
    void setScale(float,float) -> f
    void scale(float) -> l
    void scale(float,float) -> g
    float getRotation() -> w
    void setRotation(float) -> m
    void rotate(float) -> n
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setColor(float,float,float,float) -> b
    com.badlogic.gdx.graphics.Color getColor() -> x
    java.lang.String getName() -> y
    void setName(java.lang.String) -> a
    void toFront() -> z
    void toBack() -> A
    void setZIndex(int) -> a
    int getZIndex() -> B
    boolean clipBegin() -> C
    boolean clipBegin(float,float,float,float) -> c
    void clipEnd() -> D
    com.badlogic.gdx.math.Vector2 screenToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Vector2 localToStageCoordinates(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 localToParentCoordinates(com.badlogic.gdx.math.Vector2) -> d
    com.badlogic.gdx.math.Vector2 localToAscendantCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Event -> com.badlogic.gdx.h.a.c:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    boolean capture -> d
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    void handle() -> a
    void cancel() -> b
    void stop() -> d
    void reset() -> c
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> e
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> f
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean getBubbles() -> g
    void setBubbles(boolean) -> a
    boolean isHandled() -> h
    boolean isStopped() -> i
    boolean isCancelled() -> j
    void setCapture(boolean) -> b
    boolean isCapture() -> k
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> l
com.badlogic.gdx.scenes.scene2d.EventListener -> com.badlogic.gdx.h.a.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> com.badlogic.gdx.h.a.e:
    com.badlogic.gdx.utils.SnapshotArray children -> k
    com.badlogic.gdx.math.Matrix3 localTransform -> l
    com.badlogic.gdx.math.Matrix3 worldTransform -> m
    com.badlogic.gdx.math.Matrix4 batchTransform -> n
    com.badlogic.gdx.math.Matrix4 oldBatchTransform -> o
    boolean transform -> p
    com.badlogic.gdx.math.Rectangle cullingArea -> q
    com.badlogic.gdx.math.Vector2 point -> r
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void drawChildren(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> b
    void applyTransform(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix4 computeTransform() -> E
    void resetTransform(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void childrenChanged() -> F
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void addActorAt(int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActorBefore(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActorAfter(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    void clearChildren() -> G
    void clear() -> g
    com.badlogic.gdx.scenes.scene2d.Actor findActor(java.lang.String) -> b
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean swapActor(int,int) -> a
    boolean swapActor(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> H
    boolean hasChildren() -> I
    void setTransform(boolean) -> b
    boolean isTransform() -> J
    com.badlogic.gdx.math.Vector2 localToDescendantCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> b
    void print() -> K
    void print(java.lang.String) -> c
com.badlogic.gdx.scenes.scene2d.InputEvent -> com.badlogic.gdx.h.a.f:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> a
    float stageX -> b
    float stageY -> c
    int pointer -> d
    int button -> e
    int keyCode -> f
    int scrollAmount -> g
    char character -> h
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> i
    void reset() -> c
    float getStageX() -> m
    void setStageX(float) -> a
    float getStageY() -> n
    void setStageY(float) -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> o
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> a
    int getPointer() -> p
    void setPointer(int) -> a
    int getButton() -> q
    void setButton(int) -> b
    int getKeyCode() -> r
    void setKeyCode(int) -> c
    char getCharacter() -> s
    void setCharacter(char) -> a
    int getScrollAmount() -> t
    void setScrollAmount(int) -> d
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> u
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> com.badlogic.gdx.h.a.g:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] values() -> values
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.InputListener -> com.badlogic.gdx.h.a.h:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> com.badlogic.gdx.h.a.i:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> com.badlogic.gdx.h.a.j:
    com.badlogic.gdx.math.Vector2 actorCoords -> a
    com.badlogic.gdx.math.Vector3 cameraCoords -> b
    float width -> c
    float height -> d
    float gutterWidth -> e
    float gutterHeight -> f
    float centerX -> g
    float centerY -> h
    com.badlogic.gdx.graphics.Camera camera -> i
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> j
    boolean ownsBatch -> k
    com.badlogic.gdx.scenes.scene2d.Group root -> l
    com.badlogic.gdx.math.Vector2 stageCoords -> m
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> n
    boolean[] pointerTouched -> o
    int[] pointerScreenX -> p
    int[] pointerScreenY -> q
    int mouseScreenX -> r
    int mouseScreenY -> s
    com.badlogic.gdx.scenes.scene2d.Actor mouseOverActor -> t
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> u
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> v
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> w
    void initialize(float,float,boolean) -> c
    void setViewport(float,float,boolean) -> a
    void draw() -> a
    void act() -> b
    void act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor fireEnterAndExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean mouseMoved(int,int) -> a
    boolean scrolled(int) -> c
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> a
    void removeTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> b
    void cancelTouchFocus() -> c
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.utils.Array getActors() -> d
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean removeListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> b
    boolean addCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> c
    boolean removeCaptureListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> d
    void clear() -> f
    void unfocusAll() -> g
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void setKeyboardFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.scenes.scene2d.Actor getKeyboardFocus() -> h
    void setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    com.badlogic.gdx.scenes.scene2d.Actor getScrollFocus() -> i
    float getWidth() -> j
    float getHeight() -> k
    float getGutterWidth() -> l
    float getGutterHeight() -> m
    com.badlogic.gdx.graphics.g2d.SpriteBatch getSpriteBatch() -> n
    com.badlogic.gdx.graphics.Camera getCamera() -> o
    void setCamera(com.badlogic.gdx.graphics.Camera) -> a
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> p
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> b
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 stageToScreenCoordinates(com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Vector2 toScreenCoordinates(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Matrix4) -> a
    void dispose() -> e
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> com.badlogic.gdx.h.a.k:
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    int pointer -> d
    int button -> e
    void reset() -> c
com.badlogic.gdx.scenes.scene2d.Touchable -> com.badlogic.gdx.h.a.l:
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable[] values() -> values
    com.badlogic.gdx.scenes.scene2d.Touchable valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.actions.Actions -> com.badlogic.gdx.h.a.a.a:
    com.badlogic.gdx.scenes.scene2d.Action action(java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AddAction addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AddAction addAction(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RemoveAction removeAction(com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.RemoveAction removeAction(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.MoveToAction moveTo(float,float,float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float) -> b
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float) -> b
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float,com.badlogic.gdx.math.Interpolation) -> b
    com.badlogic.gdx.scenes.scene2d.actions.SizeToAction sizeTo(float,float) -> c
    com.badlogic.gdx.scenes.scene2d.actions.SizeToAction sizeTo(float,float,float) -> c
    com.badlogic.gdx.scenes.scene2d.actions.SizeToAction sizeTo(float,float,float,com.badlogic.gdx.math.Interpolation) -> c
    com.badlogic.gdx.scenes.scene2d.actions.SizeByAction sizeBy(float,float) -> d
    com.badlogic.gdx.scenes.scene2d.actions.SizeByAction sizeBy(float,float,float) -> d
    com.badlogic.gdx.scenes.scene2d.actions.SizeByAction sizeBy(float,float,float,com.badlogic.gdx.math.Interpolation) -> d
    com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction scaleTo(float,float) -> e
    com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction scaleTo(float,float,float) -> e
    com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction scaleTo(float,float,float,com.badlogic.gdx.math.Interpolation) -> e
    com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction scaleBy(float,float) -> f
    com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction scaleBy(float,float,float) -> f
    com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction scaleBy(float,float,float,com.badlogic.gdx.math.Interpolation) -> f
    com.badlogic.gdx.scenes.scene2d.actions.RotateToAction rotateTo(float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RotateToAction rotateTo(float,float) -> g
    com.badlogic.gdx.scenes.scene2d.actions.RotateToAction rotateTo(float,float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RotateByAction rotateBy(float) -> b
    com.badlogic.gdx.scenes.scene2d.actions.RotateByAction rotateBy(float,float) -> h
    com.badlogic.gdx.scenes.scene2d.actions.RotateByAction rotateBy(float,float,com.badlogic.gdx.math.Interpolation) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ColorAction color(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.actions.ColorAction color(com.badlogic.gdx.graphics.Color,float) -> a
    com.badlogic.gdx.scenes.scene2d.actions.ColorAction color(com.badlogic.gdx.graphics.Color,float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float) -> c
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float) -> i
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float,com.badlogic.gdx.math.Interpolation) -> c
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float) -> d
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float,com.badlogic.gdx.math.Interpolation) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float) -> e
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float,com.badlogic.gdx.math.Interpolation) -> b
    com.badlogic.gdx.scenes.scene2d.actions.VisibleAction show() -> a
    com.badlogic.gdx.scenes.scene2d.actions.VisibleAction hide() -> b
    com.badlogic.gdx.scenes.scene2d.actions.VisibleAction visible(boolean) -> a
    com.badlogic.gdx.scenes.scene2d.actions.TouchableAction touchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction removeActor() -> c
    com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.actions.DelayAction delay(float) -> f
    com.badlogic.gdx.scenes.scene2d.actions.DelayAction delay(float,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.TimeScaleAction timeScale(float,com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action) -> c
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action[]) -> a
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence() -> d
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action) -> d
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel(com.badlogic.gdx.scenes.scene2d.Action[]) -> b
    com.badlogic.gdx.scenes.scene2d.actions.ParallelAction parallel() -> e
    com.badlogic.gdx.scenes.scene2d.actions.RepeatAction repeat(int,com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RepeatAction forever(com.badlogic.gdx.scenes.scene2d.Action) -> e
    com.badlogic.gdx.scenes.scene2d.actions.RunnableAction run(java.lang.Runnable) -> a
    com.badlogic.gdx.scenes.scene2d.actions.LayoutAction layout(boolean) -> b
    com.badlogic.gdx.scenes.scene2d.actions.AfterAction after(com.badlogic.gdx.scenes.scene2d.Action) -> f
    com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction addListener(com.badlogic.gdx.scenes.scene2d.EventListener,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction addListener(com.badlogic.gdx.scenes.scene2d.EventListener,boolean,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction removeListener(com.badlogic.gdx.scenes.scene2d.EventListener,boolean) -> b
    com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction removeListener(com.badlogic.gdx.scenes.scene2d.EventListener,boolean,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.badlogic.gdx.scenes.scene2d.actions.AddAction -> com.badlogic.gdx.h.a.a.b:
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Action action -> c
    boolean act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getTargetActor() -> e
    void setTargetActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.Action getAction() -> f
    void setAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void restart() -> a
    void reset() -> c
com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction -> com.badlogic.gdx.h.a.a.c:
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> c
    boolean capture -> d
    boolean act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getTargetActor() -> e
    void setTargetActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.EventListener getListener() -> f
    void setListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean getCapture() -> g
    void setCapture(boolean) -> a
    void reset() -> c
com.badlogic.gdx.scenes.scene2d.actions.AfterAction -> com.badlogic.gdx.h.a.a.d:
    com.badlogic.gdx.utils.Array waitForActions -> c
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void restart() -> a
    boolean act(float) -> a
com.badlogic.gdx.scenes.scene2d.actions.AlphaAction -> com.badlogic.gdx.h.a.a.e:
    float start -> b
    float end -> c
    com.badlogic.gdx.graphics.Color color -> d
    void begin() -> e
    void update(float) -> b
    void reset() -> c
    com.badlogic.gdx.graphics.Color getColor() -> f
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    float getAlpha() -> g
    void setAlpha(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.ColorAction -> com.badlogic.gdx.h.a.a.f:
    float startR -> b
    float startG -> c
    float startB -> d
    float startA -> e
    com.badlogic.gdx.graphics.Color color -> f
    com.badlogic.gdx.graphics.Color end -> g
    void begin() -> e
    void update(float) -> b
    void reset() -> c
    com.badlogic.gdx.graphics.Color getColor() -> f
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color getEndColor() -> g
    void setEndColor(com.badlogic.gdx.graphics.Color) -> b
com.badlogic.gdx.scenes.scene2d.actions.DelayAction -> com.badlogic.gdx.h.a.a.g:
    float duration -> c
    float time -> d
    boolean act(float) -> a
    void finish() -> e
    void restart() -> a
    float getTime() -> f
    void setTime(float) -> b
    float getDuration() -> g
    void setDuration(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.DelegateAction -> com.badlogic.gdx.h.a.a.h:
    com.badlogic.gdx.scenes.scene2d.Action action -> b
    void setAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    com.badlogic.gdx.scenes.scene2d.Action getAction() -> h
    void restart() -> a
    void reset() -> c
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.actions.FloatAction -> com.badlogic.gdx.h.a.a.i:
    float start -> b
    float end -> c
    float value -> d
    void begin() -> e
    void update(float) -> b
    float getValue() -> f
    void setValue(float) -> c
    float getStart() -> g
    void setStart(float) -> d
    float getEnd() -> h
    void setEnd(float) -> e
com.badlogic.gdx.scenes.scene2d.actions.IntAction -> com.badlogic.gdx.h.a.a.j:
    int start -> b
    int end -> c
    int value -> d
    void begin() -> e
    void update(float) -> b
    int getValue() -> f
    void setValue(int) -> a
    int getStart() -> g
    void setStart(int) -> b
    int getEnd() -> h
    void setEnd(int) -> c
com.badlogic.gdx.scenes.scene2d.actions.LayoutAction -> com.badlogic.gdx.h.a.a.k:
    boolean enabled -> b
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean act(float) -> a
    boolean isEnabled() -> e
    void setLayoutEnabled(boolean) -> a
com.badlogic.gdx.scenes.scene2d.actions.MoveByAction -> com.badlogic.gdx.h.a.a.l:
    float amountX -> b
    float amountY -> c
    void updateRelative(float) -> c
    void setAmount(float,float) -> a
    float getAmountX() -> f
    void setAmountX(float) -> d
    float getAmountY() -> g
    void setAmountY(float) -> e
com.badlogic.gdx.scenes.scene2d.actions.MoveToAction -> com.badlogic.gdx.h.a.a.m:
    float startX -> b
    float startY -> c
    float endX -> d
    float endY -> e
    void begin() -> e
    void update(float) -> b
    void setPosition(float,float) -> a
    float getX() -> f
    void setX(float) -> c
    float getY() -> g
    void setY(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.ParallelAction -> com.badlogic.gdx.h.a.a.n:
    com.badlogic.gdx.utils.Array actions -> b
    boolean complete -> c
    boolean act(float) -> a
    void restart() -> a
    void reset() -> c
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.utils.Array getActions() -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction -> com.badlogic.gdx.h.a.a.o:
    float lastPercent -> b
    void begin() -> e
    void update(float) -> b
    void updateRelative(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.RemoveAction -> com.badlogic.gdx.h.a.a.p:
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Action action -> c
    boolean act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getTargetActor() -> e
    void setTargetActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.Action getAction() -> f
    void setAction(com.badlogic.gdx.scenes.scene2d.Action) -> a
    void reset() -> c
com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction -> com.badlogic.gdx.h.a.a.q:
    com.badlogic.gdx.scenes.scene2d.Actor removeActor -> b
    boolean removed -> c
    boolean act(float) -> a
    void restart() -> a
    void reset() -> c
    com.badlogic.gdx.scenes.scene2d.Actor getRemoveActor() -> e
    void setRemoveActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction -> com.badlogic.gdx.h.a.a.r:
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> c
    boolean capture -> d
    boolean act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getTargetActor() -> e
    void setTargetActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.EventListener getListener() -> f
    void setListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    boolean getCapture() -> g
    void setCapture(boolean) -> a
    void reset() -> c
com.badlogic.gdx.scenes.scene2d.actions.RepeatAction -> com.badlogic.gdx.h.a.a.s:
    int FOREVER -> c
    int repeatCount -> d
    int executedCount -> e
    boolean finished -> f
    boolean act(float) -> a
    void finish() -> e
    void restart() -> a
    void setCount(int) -> a
    int getCount() -> f
com.badlogic.gdx.scenes.scene2d.actions.RotateByAction -> com.badlogic.gdx.h.a.a.t:
    float amount -> b
    void updateRelative(float) -> c
    float getAmount() -> f
    void setAmount(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.RotateToAction -> com.badlogic.gdx.h.a.a.u:
    float start -> b
    float end -> c
    void begin() -> e
    void update(float) -> b
    float getRotation() -> f
    void setRotation(float) -> c
com.badlogic.gdx.scenes.scene2d.actions.RunnableAction -> com.badlogic.gdx.h.a.a.v:
    java.lang.Runnable runnable -> b
    boolean ran -> c
    boolean act(float) -> a
    void run() -> e
    void restart() -> a
    void reset() -> c
    java.lang.Runnable getRunnable() -> f
    void setRunnable(java.lang.Runnable) -> a
com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction -> com.badlogic.gdx.h.a.a.w:
    float amountX -> b
    float amountY -> c
    void updateRelative(float) -> c
    void setAmount(float,float) -> a
    void setAmount(float) -> d
    float getAmountX() -> f
    void setAmountX(float) -> e
    float getAmountY() -> g
    void setAmountY(float) -> f
com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction -> com.badlogic.gdx.h.a.a.x:
    float startX -> b
    float startY -> c
    float endX -> d
    float endY -> e
    void begin() -> e
    void update(float) -> b
    void setScale(float,float) -> a
    void setScale(float) -> c
    float getX() -> f
    void setX(float) -> d
    float getY() -> g
    void setY(float) -> e
com.badlogic.gdx.scenes.scene2d.actions.SequenceAction -> com.badlogic.gdx.h.a.a.y:
    int index -> c
    boolean act(float) -> a
    void restart() -> a
com.badlogic.gdx.scenes.scene2d.actions.SizeByAction -> com.badlogic.gdx.h.a.a.z:
    float amountWidth -> b
    float amountHeight -> c
    void updateRelative(float) -> c
    void setAmount(float,float) -> a
    float getAmountWidth() -> f
    void setAmountWidth(float) -> d
    float getAmountHeight() -> g
    void setAmountHeight(float) -> e
com.badlogic.gdx.scenes.scene2d.actions.SizeToAction -> com.badlogic.gdx.h.a.a.aa:
    float startWidth -> b
    float startHeight -> c
    float endWidth -> d
    float endHeight -> e
    void begin() -> e
    void update(float) -> b
    void setSize(float,float) -> a
    float getWidth() -> f
    void setWidth(float) -> c
    float getHeight() -> g
    void setHeight(float) -> d
com.badlogic.gdx.scenes.scene2d.actions.TemporalAction -> com.badlogic.gdx.h.a.a.ab:
    float duration -> b
    float time -> c
    com.badlogic.gdx.math.Interpolation interpolation -> d
    boolean reverse -> e
    boolean complete -> f
    boolean act(float) -> a
    void begin() -> e
    void end() -> i
    void update(float) -> b
    void finish() -> j
    void restart() -> a
    void reset() -> c
    float getTime() -> k
    void setTime(float) -> g
    float getDuration() -> l
    void setDuration(float) -> h
    com.badlogic.gdx.math.Interpolation getInterpolation() -> m
    void setInterpolation(com.badlogic.gdx.math.Interpolation) -> a
    boolean isReverse() -> n
    void setReverse(boolean) -> a
com.badlogic.gdx.scenes.scene2d.actions.TimeScaleAction -> com.badlogic.gdx.h.a.a.ac:
    float scale -> c
    boolean act(float) -> a
    float getScale() -> e
    void setScale(float) -> b
com.badlogic.gdx.scenes.scene2d.actions.TouchableAction -> com.badlogic.gdx.h.a.a.ad:
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> b
    boolean act(float) -> a
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> e
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
com.badlogic.gdx.scenes.scene2d.actions.VisibleAction -> com.badlogic.gdx.h.a.a.ae:
    boolean visible -> b
    boolean act(float) -> a
    boolean isVisible() -> e
    void setVisible(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.Button -> com.badlogic.gdx.h.a.b.a:
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> n
    boolean isChecked -> k
    boolean isDisabled -> l
    com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup buttonGroup -> m
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> o
    void initialize() -> W
    void setChecked(boolean) -> c
    void toggle() -> b_
    boolean isChecked() -> c_
    boolean isPressed() -> N
    boolean isOver() -> O
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener getClickListener() -> P
    boolean isDisabled() -> Q
    void setDisabled(boolean) -> d
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle getStyle() -> R
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> c
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinWidth() -> U
    float getMinHeight() -> V
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> com.badlogic.gdx.h.a.b.b:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> com.badlogic.gdx.h.a.b.c:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> f
    float pressedOffsetX -> g
    float pressedOffsetY -> h
    float unpressedOffsetX -> i
    float unpressedOffsetY -> j
com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup -> com.badlogic.gdx.h.a.b.d:
    com.badlogic.gdx.utils.Array buttons -> a
    com.badlogic.gdx.utils.Array checkedButtons -> b
    int minCheckCount -> c
    int maxCheckCount -> d
    boolean uncheckLast -> e
    com.badlogic.gdx.scenes.scene2d.ui.Button lastChecked -> f
    void add(com.badlogic.gdx.scenes.scene2d.ui.Button) -> a
    void add(com.badlogic.gdx.scenes.scene2d.ui.Button[]) -> a
    void remove(com.badlogic.gdx.scenes.scene2d.ui.Button) -> b
    void remove(com.badlogic.gdx.scenes.scene2d.ui.Button[]) -> b
    void setChecked(java.lang.String) -> a
    boolean canCheck(com.badlogic.gdx.scenes.scene2d.ui.Button,boolean) -> a
    void uncheckAll() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Button getChecked() -> b
    com.badlogic.gdx.utils.Array getAllChecked() -> c
    com.badlogic.gdx.utils.Array getButtons() -> d
    void setMinCheckCount(int) -> a
    void setMaxCheckCount(int) -> b
    void setUncheckLast(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.CheckBox -> com.badlogic.gdx.h.a.b.e:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> n
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle style -> o
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle getStyle() -> W
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Image getImage() -> X
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle getStyle() -> Y
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle getStyle() -> R
com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle -> com.badlogic.gdx.h.a.b.f:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOn -> k
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOff -> l
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkboxOver -> m
com.badlogic.gdx.scenes.scene2d.ui.Dialog -> com.badlogic.gdx.h.a.b.g:
    float fadeDuration -> k
    com.badlogic.gdx.scenes.scene2d.ui.Table contentTable -> l
    com.badlogic.gdx.scenes.scene2d.ui.Table buttonTable -> m
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> x
    com.badlogic.gdx.utils.ObjectMap values -> n
    boolean cancelHide -> o
    com.badlogic.gdx.scenes.scene2d.Actor previousKeyboardFocus -> p
    com.badlogic.gdx.scenes.scene2d.Actor previousScrollFocus -> q
    com.badlogic.gdx.scenes.scene2d.InputListener ignoreTouchDown -> r
    void initialize() -> W
    com.badlogic.gdx.scenes.scene2d.ui.Table getContentTable() -> L
    com.badlogic.gdx.scenes.scene2d.ui.Table getButtonTable() -> M
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(java.lang.String) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(java.lang.String,com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog text(com.badlogic.gdx.scenes.scene2d.ui.Label) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(java.lang.String) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(java.lang.String,java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(java.lang.String,java.lang.Object,com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(com.badlogic.gdx.scenes.scene2d.ui.Button) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog button(com.badlogic.gdx.scenes.scene2d.ui.Button,java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog show(com.badlogic.gdx.scenes.scene2d.Stage) -> b
    void hide() -> N
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> a
    void setObject(com.badlogic.gdx.scenes.scene2d.Actor,java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Dialog key(int,java.lang.Object) -> a
    void result(java.lang.Object) -> a
    void cancel() -> O
com.badlogic.gdx.scenes.scene2d.ui.Dialog$1 -> com.badlogic.gdx.h.a.b.h:
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Dialog$2 -> com.badlogic.gdx.h.a.b.i:
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Dialog$3 -> com.badlogic.gdx.h.a.b.j:
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
    void focusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent) -> a
com.badlogic.gdx.scenes.scene2d.ui.Dialog$4 -> com.badlogic.gdx.h.a.b.k:
    int val$keycode -> a
    java.lang.Object val$object -> b
    com.badlogic.gdx.scenes.scene2d.ui.Dialog this$0 -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Image -> com.badlogic.gdx.h.a.b.l:
    com.badlogic.gdx.utils.Scaling scaling -> k
    int align -> l
    float imageX -> m
    float imageY -> n
    float imageWidth -> o
    float imageHeight -> p
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> q
    void layout() -> f_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable() -> F
    void setScaling(com.badlogic.gdx.utils.Scaling) -> a
    void setAlign(int) -> b
    float getMinWidth() -> U
    float getMinHeight() -> V
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getImageX() -> G
    float getImageY() -> H
    float getImageWidth() -> I
    float getImageHeight() -> J
com.badlogic.gdx.scenes.scene2d.ui.ImageButton -> com.badlogic.gdx.h.a.b.m:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> n
    com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle style -> o
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle getStyle() -> W
    void updateImage() -> Z
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Image getImage() -> X
    com.esotericsoftware.tablelayout.Cell getImageCell() -> Y
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle getStyle() -> R
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle -> com.badlogic.gdx.h.a.b.n:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageUp -> k
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDown -> l
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageOver -> m
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageChecked -> n
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageCheckedOver -> o
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDisabled -> p
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton -> com.badlogic.gdx.h.a.b.o:
    com.badlogic.gdx.scenes.scene2d.ui.Image image -> n
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> o
    com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle style -> p
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle getStyle() -> W
    void updateImage() -> aE
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Image getImage() -> X
    com.esotericsoftware.tablelayout.Cell getImageCell() -> Y
    com.badlogic.gdx.scenes.scene2d.ui.Label getLabel() -> Z
    com.esotericsoftware.tablelayout.Cell getLabelCell() -> aa
    void setText(java.lang.String) -> c
    java.lang.CharSequence getText() -> ab
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle getStyle() -> R
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle -> com.badlogic.gdx.h.a.b.p:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageUp -> k
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDown -> l
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageOver -> m
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageChecked -> n
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageCheckedOver -> o
    com.badlogic.gdx.scenes.scene2d.utils.Drawable imageDisabled -> p
com.badlogic.gdx.scenes.scene2d.ui.Label -> com.badlogic.gdx.h.a.b.q:
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds bounds -> l
    com.badlogic.gdx.utils.StringBuilder text -> m
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> n
    int labelAlign -> o
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment lineAlign -> p
    boolean wrap -> q
    float lastPrefHeight -> r
    boolean sizeInvalid -> s
    float fontScaleX -> t
    float fontScaleY -> u
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> F
    void setText(java.lang.CharSequence) -> a
    boolean textEquals(java.lang.CharSequence) -> b
    java.lang.CharSequence getText() -> G
    void invalidate() -> d_
    void computeSize() -> N
    void layout() -> f_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getTextBounds() -> I
    void setWrap(boolean) -> b
    void setAlignment(int) -> b
    void setAlignment(int,int) -> a
    void setFontScale(float) -> o
    void setFontScale(float,float) -> h
    float getFontScaleX() -> J
    void setFontScaleX(float) -> p
    float getFontScaleY() -> K
    void setFontScaleY(float) -> q
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> com.badlogic.gdx.h.a.b.r:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
com.badlogic.gdx.scenes.scene2d.ui.List -> com.badlogic.gdx.h.a.b.s:
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle style -> k
    java.lang.String[] items -> l
    int selectedIndex -> m
    com.badlogic.gdx.math.Rectangle cullingArea -> n
    float prefWidth -> o
    float prefHeight -> p
    float itemHeight -> q
    float textOffsetX -> r
    float textOffsetY -> s
    void touchDown(float) -> o
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle getStyle() -> F
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    int getSelectedIndex() -> G
    void setSelectedIndex(int) -> b
    java.lang.String getSelection() -> I
    int setSelection(java.lang.String) -> b
    void setItems(java.lang.Object[]) -> a
    java.lang.String[] getItems() -> J
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.ui.List$1 -> com.badlogic.gdx.h.a.b.t:
    com.badlogic.gdx.scenes.scene2d.ui.List this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle -> com.badlogic.gdx.h.a.b.u:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColorSelected -> b
    com.badlogic.gdx.graphics.Color fontColorUnselected -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> d
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane -> com.badlogic.gdx.h.a.b.v:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle style -> M
    com.badlogic.gdx.scenes.scene2d.Actor widget -> N
    com.badlogic.gdx.math.Rectangle hScrollBounds -> k
    com.badlogic.gdx.math.Rectangle vScrollBounds -> l
    com.badlogic.gdx.math.Rectangle hKnobBounds -> m
    com.badlogic.gdx.math.Rectangle vKnobBounds -> n
    com.badlogic.gdx.math.Rectangle widgetAreaBounds -> O
    com.badlogic.gdx.math.Rectangle widgetCullingArea -> P
    com.badlogic.gdx.math.Rectangle scissorBounds -> Q
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener flickScrollListener -> R
    boolean scrollX -> o
    boolean scrollY -> p
    float amountX -> q
    float amountY -> r
    float visualAmountX -> s
    float visualAmountY -> t
    float maxX -> u
    float maxY -> v
    boolean touchScrollH -> w
    boolean touchScrollV -> x
    com.badlogic.gdx.math.Vector2 lastPoint -> y
    float areaWidth -> z
    float areaHeight -> A
    boolean fadeScrollBars -> S
    boolean smoothScrolling -> T
    float fadeAlpha -> B
    float fadeAlphaSeconds -> C
    float fadeDelay -> D
    float fadeDelaySeconds -> E
    boolean cancelTouchFocus -> F
    boolean flickScroll -> G
    float velocityX -> H
    float velocityY -> I
    float flingTimer -> J
    boolean overscrollX -> U
    boolean overscrollY -> V
    float flingTime -> K
    float overscrollDistance -> W
    float overscrollSpeedMin -> X
    float overscrollSpeedMax -> Y
    boolean forceOverscrollX -> Z
    boolean forceOverscrollY -> aa
    boolean disableX -> ab
    boolean disableY -> ac
    boolean clamp -> ad
    boolean scrollbarsOnTop -> ae
    int draggingPointer -> L
    void resetFade() -> L
    void cancelTouchFocusedChild(com.badlogic.gdx.scenes.scene2d.InputEvent) -> a
    void clamp() -> M
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle getStyle() -> N
    void act(float) -> a
    void layout() -> f_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinWidth() -> U
    float getMinHeight() -> V
    void setWidget(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    com.badlogic.gdx.scenes.scene2d.Actor getWidget() -> O
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void addActorAt(int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActorBefore(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActorAfter(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void scrollX(float) -> o
    void scrollY(float) -> p
    void visualScrollX(float) -> q
    void visualScrollY(float) -> r
    void setScrollX(float) -> s
    float getScrollX() -> P
    void setScrollY(float) -> t
    float getScrollY() -> Q
    float getVisualScrollX() -> R
    float getVisualScrollY() -> W
    float getScrollPercentX() -> X
    void setScrollPercentX(float) -> u
    float getScrollPercentY() -> Y
    void setScrollPercentY(float) -> v
    void setFlickScroll(boolean) -> c
    void scrollTo(float,float,float,float) -> d
    void scrollToCenter(float,float,float,float) -> e
    float getMaxX() -> Z
    float getMaxY() -> aa
    float getScrollBarHeight() -> ab
    float getScrollBarWidth() -> ac
    boolean isScrollX() -> ad
    boolean isScrollY() -> k_
    void setScrollingDisabled(boolean,boolean) -> a
    boolean isDragging() -> af
    boolean isPanning() -> ag
    boolean isFlinging() -> ah
    void setVelocityX(float) -> w
    float getVelocityX() -> ai
    void setVelocityY(float) -> x
    float getVelocityY() -> aj
    void setOverscroll(boolean,boolean) -> b
    void setupOverscroll(float,float,float) -> a
    void setForceOverscroll(boolean,boolean) -> c
    void setFlingTime(float) -> y
    void setClamp(boolean) -> d
    void setFadeScrollBars(boolean) -> e
    void setupFadeScrollBars(float,float) -> h
    void setSmoothScrolling(boolean) -> f
    void setScrollbarsOnTop(boolean) -> a_
    void setCancelTouchFocus(boolean) -> h
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$1 -> com.badlogic.gdx.h.a.b.w:
    float handlePosition -> b
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$2 -> com.badlogic.gdx.h.a.b.x:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$3 -> com.badlogic.gdx.h.a.b.y:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane this$0 -> a
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> com.badlogic.gdx.h.a.b.z:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable corner -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScroll -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable hScrollKnob -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScroll -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable vScrollKnob -> f
com.badlogic.gdx.scenes.scene2d.ui.SelectBox -> com.badlogic.gdx.h.a.b.aa:
    com.badlogic.gdx.math.Vector2 tmpCoords -> k
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle style -> l
    java.lang.String[] items -> m
    int selectedIndex -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds bounds -> q
    com.badlogic.gdx.math.Vector2 screenCoords -> o
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectList list -> p
    float prefWidth -> r
    float prefHeight -> s
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> t
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle getStyle() -> F
    void setItems(java.lang.Object[]) -> a
    java.lang.String[] getItems() -> G
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void setSelection(int) -> b
    void setSelection(java.lang.String) -> b
    int getSelectionIndex() -> I
    java.lang.String getSelection() -> J
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    void hideList() -> K
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$1 -> com.badlogic.gdx.h.a.b.ab:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle -> com.badlogic.gdx.h.a.b.ac:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOver -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable backgroundOpen -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable listBackground -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable listSelection -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> f
    com.badlogic.gdx.graphics.Color fontColor -> g
    float itemSpacing -> h
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectList -> com.badlogic.gdx.h.a.b.ad:
    com.badlogic.gdx.math.Vector2 oldScreenCoords -> k
    float itemHeight -> l
    float textOffsetX -> m
    float textOffsetY -> n
    int listSelectedIndex -> o
    com.badlogic.gdx.scenes.scene2d.InputListener stageListener -> p
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox this$0 -> q
    void layout() -> E
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void act(float) -> a
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectList$1 -> com.badlogic.gdx.h.a.b.ae:
    com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectList this$1 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin -> com.badlogic.gdx.h.a.b.af:
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    void load(com.badlogic.gdx.files.FileHandle) -> a
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void add(java.lang.String,java.lang.Object) -> a
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> a
    java.lang.Object get(java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    java.lang.Object optional(java.lang.String,java.lang.Class) -> b
    boolean has(java.lang.String,java.lang.Class) -> c
    com.badlogic.gdx.utils.ObjectMap getAll(java.lang.Class) -> b
    com.badlogic.gdx.graphics.Color getColor(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont(java.lang.String) -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> c
    com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable getTiledDrawable(java.lang.String) -> d
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> e
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> g
    java.lang.String find(java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String) -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,float,float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,float,float,float,float) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> a
    void setEnabled(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas getAtlas() -> a
    void dispose() -> e
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> b
    java.lang.reflect.Method findMethod(java.lang.Class,java.lang.String) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> com.badlogic.gdx.h.a.b.ag:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> com.badlogic.gdx.h.a.b.ah:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> com.badlogic.gdx.h.a.b.ai:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> com.badlogic.gdx.h.a.b.aj:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> com.badlogic.gdx.h.a.b.ak:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> com.badlogic.gdx.h.a.b.al:
    java.lang.String name -> a
    com.badlogic.gdx.graphics.Color color -> b
com.badlogic.gdx.scenes.scene2d.ui.Slider -> com.badlogic.gdx.h.a.b.am:
    com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle style -> l
    float min -> m
    float max -> n
    float stepSize -> o
    float value -> p
    float animateFromValue -> q
    float sliderPos -> r
    boolean vertical -> s
    int draggingPointer -> k
    float animateDuration -> t
    float animateTime -> u
    com.badlogic.gdx.math.Interpolation animateInterpolation -> v
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle getStyle() -> F
    void act(float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    boolean calculatePositionAndValue(float,float) -> h
    boolean isDragging() -> G
    float getValue() -> I
    float getVisualValue() -> J
    boolean setValue(float) -> o
    void setRange(float,float) -> i
    void setStepSize(float) -> p
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinValue() -> K
    float getMaxValue() -> L
    float getStepSize() -> M
    void setAnimateDuration(float) -> q
    void setAnimateInterpolation(com.badlogic.gdx.math.Interpolation) -> a
com.badlogic.gdx.scenes.scene2d.ui.Slider$1 -> com.badlogic.gdx.h.a.b.an:
    com.badlogic.gdx.scenes.scene2d.ui.Slider this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle -> com.badlogic.gdx.h.a.b.ao:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knob -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobBefore -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knobAfter -> d
com.badlogic.gdx.scenes.scene2d.ui.SplitPane -> com.badlogic.gdx.h.a.b.ap:
    com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle style -> k
    com.badlogic.gdx.scenes.scene2d.Actor firstWidget -> s
    com.badlogic.gdx.scenes.scene2d.Actor secondWidget -> t
    boolean vertical -> l
    float splitAmount -> m
    float minAmount -> n
    float maxAmount -> o
    float oldSplitAmount -> u
    com.badlogic.gdx.math.Rectangle firstWidgetBounds -> v
    com.badlogic.gdx.math.Rectangle secondWidgetBounds -> w
    com.badlogic.gdx.math.Rectangle handleBounds -> p
    com.badlogic.gdx.math.Rectangle firstScissors -> x
    com.badlogic.gdx.math.Rectangle secondScissors -> y
    com.badlogic.gdx.math.Vector2 lastPoint -> q
    com.badlogic.gdx.math.Vector2 handlePosition -> r
    void initialize() -> N
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle getStyle() -> L
    void layout() -> f_
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinWidth() -> U
    float getMinHeight() -> V
    void setVertical(boolean) -> c
    void calculateHorizBoundsAndPositions() -> O
    void calculateVertBoundsAndPositions() -> P
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void setSplitAmount(float) -> o
    float getSplit() -> M
    void setMinSplitAmount(float) -> p
    void setMaxSplitAmount(float) -> q
    void setFirstWidget(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void setSecondWidget(com.badlogic.gdx.scenes.scene2d.Actor) -> f
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void addActorAt(int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActorBefore(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$1 -> com.badlogic.gdx.h.a.b.aq:
    int draggingPointer -> a
    com.badlogic.gdx.scenes.scene2d.ui.SplitPane this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle -> com.badlogic.gdx.h.a.b.ar:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable handle -> a
com.badlogic.gdx.scenes.scene2d.ui.Stack -> com.badlogic.gdx.h.a.b.as:
    float prefWidth -> k
    float prefHeight -> l
    float minWidth -> m
    float minHeight -> n
    float maxWidth -> o
    float maxHeight -> p
    boolean sizeInvalid -> q
    void invalidate() -> d_
    void computeSize() -> N
    void add(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void layout() -> f_
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinWidth() -> U
    float getMinHeight() -> V
    float getMaxWidth() -> i_
    float getMaxHeight() -> j_
com.badlogic.gdx.scenes.scene2d.ui.Table -> com.badlogic.gdx.h.a.b.at:
    com.badlogic.gdx.scenes.scene2d.ui.TableLayout layout -> k
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> l
    boolean clip -> m
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> n
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> c
    void invalidate() -> d_
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMinWidth() -> U
    float getMinHeight() -> V
    void setBackground(java.lang.String) -> e
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackground() -> ac
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void setClip(boolean) -> e
    int getRow(float) -> o
    void clearChildren() -> G
    com.esotericsoftware.tablelayout.Cell add(java.lang.String) -> f
    com.esotericsoftware.tablelayout.Cell add(java.lang.String,java.lang.String) -> a
    com.esotericsoftware.tablelayout.Cell add(java.lang.String,java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    com.esotericsoftware.tablelayout.Cell add(java.lang.String,java.lang.String,java.lang.String) -> a
    com.esotericsoftware.tablelayout.Cell add() -> ad
    com.esotericsoftware.tablelayout.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    com.esotericsoftware.tablelayout.Cell stack(com.badlogic.gdx.scenes.scene2d.Actor[]) -> a
    com.esotericsoftware.tablelayout.Cell row() -> e_
    com.esotericsoftware.tablelayout.Cell columnDefaults(int) -> b
    com.esotericsoftware.tablelayout.Cell defaults() -> af
    void layout() -> f_
    void reset() -> ag
    com.esotericsoftware.tablelayout.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> f
    java.util.List getCells() -> ah
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.esotericsoftware.tablelayout.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table padTop(com.esotericsoftware.tablelayout.Value) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Table padLeft(com.esotericsoftware.tablelayout.Value) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table padBottom(com.esotericsoftware.tablelayout.Value) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(com.esotericsoftware.tablelayout.Value) -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float) -> p
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float,float,float,float) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table padTop(float) -> q
    com.badlogic.gdx.scenes.scene2d.ui.Table padLeft(float) -> r
    com.badlogic.gdx.scenes.scene2d.ui.Table padBottom(float) -> s
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(float) -> t
    com.badlogic.gdx.scenes.scene2d.ui.Table align(int) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table center() -> ai
    com.badlogic.gdx.scenes.scene2d.ui.Table top() -> aj
    com.badlogic.gdx.scenes.scene2d.ui.Table left() -> ak
    com.badlogic.gdx.scenes.scene2d.ui.Table bottom() -> al
    com.badlogic.gdx.scenes.scene2d.ui.Table right() -> am
    com.badlogic.gdx.scenes.scene2d.ui.Table debug() -> an
    com.badlogic.gdx.scenes.scene2d.ui.Table debugTable() -> ao
    com.badlogic.gdx.scenes.scene2d.ui.Table debugCell() -> ap
    com.badlogic.gdx.scenes.scene2d.ui.Table debugWidget() -> aq
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.esotericsoftware.tablelayout.BaseTableLayout$Debug) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug getDebug() -> ar
    com.esotericsoftware.tablelayout.Value getPadTopValue() -> as
    float getPadTop() -> at
    com.esotericsoftware.tablelayout.Value getPadLeftValue() -> au
    float getPadLeft() -> av
    com.esotericsoftware.tablelayout.Value getPadBottomValue() -> aw
    float getPadBottom() -> ax
    com.esotericsoftware.tablelayout.Value getPadRightValue() -> ay
    float getPadRight() -> az
    float getPadX() -> aA
    float getPadY() -> aB
    int getAlign() -> aC
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> a
    void setRound(boolean) -> f
    void drawDebug(com.badlogic.gdx.scenes.scene2d.Stage) -> c
    void drawDebug(com.badlogic.gdx.utils.Array,com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.badlogic.gdx.scenes.scene2d.ui.TableLayout -> com.badlogic.gdx.h.a.b.au:
    com.badlogic.gdx.utils.Array debugRects -> a
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer debugRenderer -> p
    boolean round -> b
    void layout() -> a
    void invalidateHierarchy() -> b
    void toStageCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    void drawDebug(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> a
com.badlogic.gdx.scenes.scene2d.ui.TableToolkit -> com.badlogic.gdx.h.a.b.av:
    boolean drawDebug -> a
    void addChild(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void removeChild(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    float getMinWidth(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    float getMinHeight(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    float getPrefWidth(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    float getPrefHeight(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    float getMaxWidth(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    float getMaxHeight(com.badlogic.gdx.scenes.scene2d.Actor) -> f
    float getWidth(com.badlogic.gdx.scenes.scene2d.Actor) -> g
    float getHeight(com.badlogic.gdx.scenes.scene2d.Actor) -> h
    void clearDebugRectangles(com.badlogic.gdx.scenes.scene2d.ui.TableLayout) -> a
    void addDebugRectangle(com.badlogic.gdx.scenes.scene2d.ui.TableLayout,com.esotericsoftware.tablelayout.BaseTableLayout$Debug,float,float,float,float) -> a
    void addDebugRectangle(com.esotericsoftware.tablelayout.BaseTableLayout,com.esotericsoftware.tablelayout.BaseTableLayout$Debug,float,float,float,float) -> a
    void clearDebugRectangles(com.esotericsoftware.tablelayout.BaseTableLayout) -> a
    float getHeight(java.lang.Object) -> a
    float getWidth(java.lang.Object) -> b
    float getMaxHeight(java.lang.Object) -> c
    float getMaxWidth(java.lang.Object) -> d
    float getPrefHeight(java.lang.Object) -> e
    float getPrefWidth(java.lang.Object) -> f
    float getMinHeight(java.lang.Object) -> g
    float getMinWidth(java.lang.Object) -> h
    void removeChild(java.lang.Object,java.lang.Object) -> a
    void addChild(java.lang.Object,java.lang.Object) -> b
com.badlogic.gdx.scenes.scene2d.ui.TableToolkit$DebugRect -> com.badlogic.gdx.h.a.b.aw:
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug type -> g
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> com.badlogic.gdx.h.a.b.ax:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> n
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> o
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle getStyle() -> Y
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Label getLabel() -> Z
    com.esotericsoftware.tablelayout.Cell getLabelCell() -> aa
    void setText(java.lang.String) -> c
    java.lang.CharSequence getText() -> ab
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle getStyle() -> R
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> com.badlogic.gdx.h.a.b.ay:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> q
    com.badlogic.gdx.graphics.Color fontColor -> r
    com.badlogic.gdx.graphics.Color downFontColor -> s
    com.badlogic.gdx.graphics.Color overFontColor -> t
    com.badlogic.gdx.graphics.Color checkedFontColor -> u
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> v
    com.badlogic.gdx.graphics.Color disabledFontColor -> w
com.badlogic.gdx.scenes.scene2d.ui.TextField -> com.badlogic.gdx.h.a.b.az:
    char BACKSPACE -> G
    char ENTER_DESKTOP -> H
    char ENTER_ANDROID -> I
    char TAB -> J
    char DELETE -> K
    char BULLET -> L
    com.badlogic.gdx.math.Vector2 tmp1 -> M
    com.badlogic.gdx.math.Vector2 tmp2 -> N
    com.badlogic.gdx.math.Vector2 tmp3 -> O
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle style -> k
    java.lang.String text -> l
    java.lang.String messageText -> m
    java.lang.CharSequence displayText -> P
    int cursor -> n
    com.badlogic.gdx.utils.Clipboard clipboard -> Q
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener listener -> o
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter filter -> p
    com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard keyboard -> q
    boolean focusTraversal -> r
    boolean disabled -> s
    boolean passwordMode -> R
    java.lang.StringBuilder passwordBuffer -> S
    com.badlogic.gdx.math.Rectangle fieldBounds -> T
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds textBounds -> U
    com.badlogic.gdx.math.Rectangle scissor -> V
    float renderOffset -> t
    float textOffset -> u
    int visibleTextStart -> W
    int visibleTextEnd -> X
    com.badlogic.gdx.utils.FloatArray glyphAdvances -> Y
    com.badlogic.gdx.utils.FloatArray glyphPositions -> v
    boolean cursorOn -> w
    float blinkTime -> Z
    long lastBlink -> x
    boolean hasSelection -> y
    int selectionStart -> z
    float selectionX -> aa
    float selectionWidth -> ab
    char passwordCharacter -> ac
    com.badlogic.gdx.scenes.scene2d.InputListener inputListener -> A
    com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask keyRepeatTask -> B
    float keyRepeatInitialTime -> C
    float keyRepeatTime -> D
    boolean rightAligned -> E
    int maxLength -> F
    void initialize() -> ag
    void setMaxLength(int) -> b
    int getMaxLength() -> F
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle) -> a
    void setPasswordCharacter(char) -> a
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle getStyle() -> G
    void calculateOffsets() -> ah
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void updateDisplayText() -> I
    void blink() -> ai
    void copy() -> J
    void cut() -> K
    void paste() -> N
    void delete() -> O
    void next(boolean) -> b
    com.badlogic.gdx.scenes.scene2d.ui.TextField findNextTextField(com.badlogic.gdx.utils.Array,com.badlogic.gdx.scenes.scene2d.ui.TextField,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> a
    void setTextFieldListener(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener) -> a
    void setTextFieldFilter(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter) -> a
    void setFocusTraversal(boolean) -> c
    java.lang.String getMessageText() -> P
    void setMessageText(java.lang.String) -> b
    void setText(java.lang.String) -> c
    java.lang.String getText() -> Q
    void setSelection(int,int) -> a
    void selectAll() -> R
    void clearSelection() -> W
    void setCursorPosition(int) -> c
    int getCursorPosition() -> X
    com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard getOnscreenKeyboard() -> Y
    void setOnscreenKeyboard(com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard) -> a
    void setClipboard(com.badlogic.gdx.utils.Clipboard) -> a
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    void setRightAligned(boolean) -> d
    void setPasswordMode(boolean) -> e
    void setBlinkTime(float) -> o
    void setDisabled(boolean) -> f
    boolean isDisabled() -> Z
    boolean isPasswordMode() -> aa
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter getTextFieldFilter() -> ab
com.badlogic.gdx.scenes.scene2d.ui.TextField$1 -> com.badlogic.gdx.h.a.b.ba:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void setCursorPosition(float) -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$DefaultOnscreenKeyboard -> com.badlogic.gdx.h.a.b.bb:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask -> com.badlogic.gdx.h.a.b.bc:
    int keycode -> a
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> b
    void run() -> run
com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard -> com.badlogic.gdx.h.a.b.bd:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter -> com.badlogic.gdx.h.a.b.be:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter$DigitsOnlyFilter -> com.badlogic.gdx.h.a.b.bf:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener -> com.badlogic.gdx.h.a.b.bg:
    void keyTyped(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle -> com.badlogic.gdx.h.a.b.bh:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.graphics.Color focusedFontColor -> c
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focusedBackground -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledBackground -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable cursor -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> i
    com.badlogic.gdx.graphics.g2d.BitmapFont messageFont -> j
    com.badlogic.gdx.graphics.Color messageFontColor -> k
com.badlogic.gdx.scenes.scene2d.ui.Touchpad -> com.badlogic.gdx.h.a.b.bi:
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle style -> l
    boolean touched -> k
    float deadzoneRadius -> m
    com.badlogic.gdx.math.Circle knobBounds -> n
    com.badlogic.gdx.math.Circle touchBounds -> o
    com.badlogic.gdx.math.Circle deadzoneBounds -> p
    com.badlogic.gdx.math.Vector2 knobPosition -> q
    com.badlogic.gdx.math.Vector2 knobPercent -> r
    void calculatePositionAndValue(float,float,boolean) -> b
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle getStyle() -> F
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void layout() -> f_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    boolean isTouched() -> G
    void setDeadzone(float) -> o
    float getKnobX() -> I
    float getKnobY() -> J
    float getKnobPercentX() -> K
    float getKnobPercentY() -> N
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$1 -> com.badlogic.gdx.h.a.b.bj:
    com.badlogic.gdx.scenes.scene2d.ui.Touchpad this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle -> com.badlogic.gdx.h.a.b.bk:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable knob -> b
com.badlogic.gdx.scenes.scene2d.ui.Tree -> com.badlogic.gdx.h.a.b.bl:
    com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle style -> k
    com.badlogic.gdx.utils.Array rootNodes -> l
    com.badlogic.gdx.utils.Array selectedNodes -> m
    float ySpacing -> n
    float iconSpacing -> o
    float padding -> p
    float indentSpacing -> q
    float leftColumnWidth -> t
    float prefWidth -> u
    float prefHeight -> v
    boolean sizeInvalid -> w
    boolean multiSelect -> r
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node foundNode -> x
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node overNode -> s
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> y
    void initialize() -> aa
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle) -> a
    void add(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> a
    void insert(int,com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> a
    void remove(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> b
    void clearChildren() -> G
    com.badlogic.gdx.utils.Array getNodes() -> N
    void invalidate() -> d_
    void computeSize() -> ab
    void computeSize(com.badlogic.gdx.utils.Array,float) -> a
    void layout() -> f_
    float layout(com.badlogic.gdx.utils.Array,float,float) -> b
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.badlogic.gdx.utils.Array,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node getNodeAt(float) -> o
    float getNodeAt(com.badlogic.gdx.utils.Array,float,float) -> c
    void selectNodes(com.badlogic.gdx.utils.Array,float,float) -> a
    com.badlogic.gdx.utils.Array getSelection() -> O
    void setSelection(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> c
    void setSelection(com.badlogic.gdx.utils.Array) -> a
    void addSelection(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> d
    void clearSelection() -> P
    com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle getStyle() -> Q
    com.badlogic.gdx.utils.Array getRootNodes() -> R
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node getOverNode() -> W
    void setOverNode(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> e
    void setPadding(float) -> p
    void setYSpacing(float) -> q
    void setIconSpacing(float) -> r
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node findNode(java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node findNode(com.badlogic.gdx.utils.Array,java.lang.Object) -> a
    void collapseAll() -> X
    void collapseAll(com.badlogic.gdx.utils.Array) -> b
    void expandAll() -> Y
    void expandAll(com.badlogic.gdx.utils.Array) -> c
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener getClickListener() -> Z
    void setMultiSelect(boolean) -> c
com.badlogic.gdx.scenes.scene2d.ui.Tree$1 -> com.badlogic.gdx.h.a.b.bm:
    com.badlogic.gdx.scenes.scene2d.ui.Tree this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
com.badlogic.gdx.scenes.scene2d.ui.Tree$Node -> com.badlogic.gdx.h.a.b.bn:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node parent -> b
    com.badlogic.gdx.utils.Array children -> c
    boolean selectable -> d
    boolean expanded -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable icon -> f
    float height -> g
    java.lang.Object object -> h
    void setExpanded(boolean) -> a
    void addToTree(com.badlogic.gdx.scenes.scene2d.ui.Tree) -> a
    void removeFromTree(com.badlogic.gdx.scenes.scene2d.ui.Tree) -> b
    void add(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void insert(int,com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> a
    void remove() -> a
    void remove(com.badlogic.gdx.scenes.scene2d.ui.Tree$Node) -> b
    void removeAll() -> b
    com.badlogic.gdx.scenes.scene2d.ui.Tree getTree() -> c
    com.badlogic.gdx.scenes.scene2d.Actor getActor() -> d
    boolean isExpanded() -> e
    com.badlogic.gdx.utils.Array getChildren() -> f
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node getParent() -> g
    void setIcon(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> a
    java.lang.Object getObject() -> h
    void setObject(java.lang.Object) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getIcon() -> i
    com.badlogic.gdx.scenes.scene2d.ui.Tree$Node findNode(java.lang.Object) -> b
    void collapseAll() -> j
    void expandAll() -> k
    void expandTo() -> l
    boolean isSelectable() -> m
    void setSelectable(boolean) -> b
com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle -> com.badlogic.gdx.h.a.b.bo:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable plus -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable minus -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup -> com.badlogic.gdx.h.a.b.bp:
    float prefWidth -> k
    float prefHeight -> l
    boolean sizeInvalid -> m
    int alignment -> n
    boolean reverse -> o
    void setAlignment(int) -> b
    void setReverse(boolean) -> c
    void invalidate() -> d_
    void computeSize() -> N
    void layout() -> f_
    float getPrefWidth() -> S
    float getPrefHeight() -> T
com.badlogic.gdx.scenes.scene2d.ui.Widget -> com.badlogic.gdx.h.a.b.bq:
    boolean needsLayout -> k
    boolean fillParent -> l
    boolean layoutEnabled -> m
    float getMinWidth() -> U
    float getMinHeight() -> V
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMaxWidth() -> i_
    float getMaxHeight() -> j_
    void setLayoutEnabled(boolean) -> g
    void validate() -> g_
    boolean needsLayout() -> ad
    void invalidate() -> d_
    void invalidateHierarchy() -> ae
    void pack() -> h_
    void setFillParent(boolean) -> b_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void layout() -> f_
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> com.badlogic.gdx.h.a.b.br:
    boolean needsLayout -> k
    boolean fillParent -> l
    boolean layoutEnabled -> m
    float getMinWidth() -> U
    float getMinHeight() -> V
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMaxWidth() -> i_
    float getMaxHeight() -> j_
    void setLayoutEnabled(boolean) -> g
    void setLayoutEnabled(com.badlogic.gdx.scenes.scene2d.Group,boolean) -> a
    void validate() -> g_
    boolean needsLayout() -> aD
    void invalidate() -> d_
    void invalidateHierarchy() -> ae
    void childrenChanged() -> F
    void pack() -> h_
    void setFillParent(boolean) -> b_
    void layout() -> f_
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.Window -> com.badlogic.gdx.h.a.b.bs:
    com.badlogic.gdx.math.Vector2 tmpPosition -> k
    com.badlogic.gdx.math.Vector2 tmpSize -> l
    com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle style -> m
    java.lang.String title -> n
    com.badlogic.gdx.graphics.g2d.BitmapFontCache titleCache -> o
    boolean isMovable -> s
    boolean isModal -> t
    com.badlogic.gdx.math.Vector2 dragOffset -> u
    boolean dragging -> v
    int titleAlignment -> p
    boolean keepWithinStage -> w
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle getStyle() -> P
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> c
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void setTitle(java.lang.String) -> g
    java.lang.String getTitle() -> Q
    void setTitleAlignment(int) -> d
    void setMovable(boolean) -> c
    void setModal(boolean) -> d
    void setKeepWithinStage(boolean) -> i
    boolean isDragging() -> R
    float getPrefWidth() -> S
com.badlogic.gdx.scenes.scene2d.ui.Window$1 -> com.badlogic.gdx.h.a.b.bt:
    com.badlogic.gdx.scenes.scene2d.ui.Window this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Window$2 -> com.badlogic.gdx.h.a.b.bu:
    com.badlogic.gdx.scenes.scene2d.ui.Window this$0 -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle -> com.badlogic.gdx.h.a.b.bv:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont titleFont -> b
    com.badlogic.gdx.graphics.Color titleFontColor -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable stageBackground -> d
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener -> com.badlogic.gdx.h.a.c.a:
    com.badlogic.gdx.math.Vector2 tmpCoords -> b
    com.badlogic.gdx.input.GestureDetector detector -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent event -> c
    com.badlogic.gdx.scenes.scene2d.Actor actor -> d
    com.badlogic.gdx.scenes.scene2d.Actor touchDownTarget -> e
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void tap(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> c
    boolean longPress(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    void fling(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void pan(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> a
    void zoom(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void pinch(com.badlogic.gdx.scenes.scene2d.InputEvent,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.input.GestureDetector getGestureDetector() -> a
    com.badlogic.gdx.scenes.scene2d.Actor getTouchDownTarget() -> b
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$1 -> com.badlogic.gdx.h.a.c.b:
    com.badlogic.gdx.math.Vector2 initialPointer1 -> b
    com.badlogic.gdx.math.Vector2 initialPointer2 -> c
    com.badlogic.gdx.math.Vector2 pointer1 -> d
    com.badlogic.gdx.math.Vector2 pointer2 -> e
    com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener this$0 -> a
    boolean tap(float,float,int,int) -> b
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
    boolean pan(float,float,float,float) -> a
    boolean zoom(float,float) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener$2 -> com.badlogic.gdx.h.a.c.c:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.Align -> com.badlogic.gdx.h.a.c.d:
    int center -> a
    int top -> b
    int bottom -> c
    int left -> d
    int right -> e
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> com.badlogic.gdx.h.a.c.e:
    float leftWidth -> a
    float rightWidth -> b
    float topHeight -> c
    float bottomHeight -> d
    float minWidth -> e
    float minHeight -> f
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    float getLeftWidth() -> a
    void setLeftWidth(float) -> a
    float getRightWidth() -> b
    void setRightWidth(float) -> b
    float getTopHeight() -> c
    void setTopHeight(float) -> c
    float getBottomHeight() -> d
    void setBottomHeight(float) -> d
    float getMinWidth() -> e
    void setMinWidth(float) -> e
    float getMinHeight() -> f
    void setMinHeight(float) -> f
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener -> com.badlogic.gdx.h.a.c.f:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> com.badlogic.gdx.h.a.c.g:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> com.badlogic.gdx.h.a.c.h:
    float tapSquareSize -> a
    float touchDownX -> b
    float touchDownY -> c
    int pressedPointer -> d
    int button -> e
    boolean pressed -> f
    boolean over -> g
    boolean cancelled -> h
    long tapCountInterval -> i
    int tapCount -> j
    long lastTapTime -> k
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void cancel() -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    void dragStart(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> c
    void drag(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> d
    void dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> e
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    boolean inTapSquare(float,float) -> a
    void invalidateTapSquare() -> b
    boolean isPressed() -> c
    boolean isOver() -> d
    void setTapSquareSize(float) -> a
    float getTapSquareSize() -> e
    void setTapCountInterval(float) -> b
    int getTapCount() -> f
    float getTouchDownX() -> g
    float getTouchDownY() -> h
    int getButton() -> i
    void setButton(int) -> a
com.badlogic.gdx.scenes.scene2d.utils.Cullable -> com.badlogic.gdx.h.a.c.i:
    void setCullingArea(com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop -> com.badlogic.gdx.h.a.c.j:
    com.badlogic.gdx.math.Vector2 tmpVector -> a
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source source -> b
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload payload -> c
    com.badlogic.gdx.scenes.scene2d.Actor dragActor -> d
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Target target -> e
    boolean isValidTarget -> f
    com.badlogic.gdx.utils.Array targets -> g
    com.badlogic.gdx.utils.ObjectMap sourceListeners -> h
    float tapSquareSize -> n
    int button -> o
    float dragActorX -> i
    float dragActorY -> j
    long dragStartTime -> k
    int dragTime -> l
    int activePointer -> m
    void addSource(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source) -> a
    void removeSource(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source) -> b
    void addTarget(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Target) -> a
    void removeTarget(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Target) -> b
    void setTapSquareSize(float) -> a
    void setButton(int) -> a
    void setDragActorPosition(float,float) -> a
    boolean isDragging() -> a
    com.badlogic.gdx.scenes.scene2d.Actor getDragActor() -> b
    void setDragTime(int) -> b
com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$1 -> com.badlogic.gdx.h.a.c.k:
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source val$source -> a
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop this$0 -> b
    void dragStart(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> c
    void drag(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> d
    void dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> e
com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload -> com.badlogic.gdx.h.a.c.l:
    com.badlogic.gdx.scenes.scene2d.Actor dragActor -> a
    com.badlogic.gdx.scenes.scene2d.Actor validDragActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor invalidDragActor -> c
    java.lang.Object object -> d
    void setDragActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getDragActor() -> a
    void setValidDragActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.scenes.scene2d.Actor getValidDragActor() -> b
    void setInvalidDragActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    com.badlogic.gdx.scenes.scene2d.Actor getInvalidDragActor() -> c
    java.lang.Object getObject() -> d
    void setObject(java.lang.Object) -> a
com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source -> com.badlogic.gdx.h.a.c.m:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload dragStart(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Target) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getActor() -> a
com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Target -> com.badlogic.gdx.h.a.c.n:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    boolean drag(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source,com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload,float,float,int) -> a
    void reset(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source,com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload) -> a
    void drop(com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Source,com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop$Payload,float,float,int) -> b
    com.badlogic.gdx.scenes.scene2d.Actor getActor() -> a
com.badlogic.gdx.scenes.scene2d.utils.DragListener -> com.badlogic.gdx.h.a.c.o:
    float tapSquareSize -> a
    float touchDownX -> b
    float touchDownY -> c
    int pressedPointer -> d
    int button -> e
    boolean dragging -> f
    float deltaX -> g
    float deltaY -> h
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void dragStart(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> c
    void drag(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> d
    void dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> e
    void cancel() -> a
    boolean isDragging() -> b
    void setTapSquareSize(float) -> a
    float getTapSquareSize() -> c
    float getTouchDownX() -> d
    float getTouchDownY() -> e
    float getDeltaX() -> f
    float getDeltaY() -> g
    int getButton() -> h
    void setButton(int) -> a
com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener -> com.badlogic.gdx.h.a.c.p:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane scroll -> g
    com.badlogic.gdx.utils.Timer$Task scrollUp -> h
    com.badlogic.gdx.utils.Timer$Task scrollDown -> i
    com.badlogic.gdx.math.Interpolation interpolation -> a
    float minSpeed -> b
    float maxSpeed -> c
    float tickSecs -> d
    long startTime -> e
    long rampTime -> f
    void setup(float,float,float,float) -> a
    float getScrollPixels() -> i
    void drag(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> d
    void dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> e
com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener$1 -> com.badlogic.gdx.h.a.c.q:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane val$scroll -> a
    com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener this$0 -> b
    void run() -> run
com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener$2 -> com.badlogic.gdx.h.a.c.r:
    com.badlogic.gdx.scenes.scene2d.ui.ScrollPane val$scroll -> a
    com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener this$0 -> b
    void run() -> run
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> com.badlogic.gdx.h.a.c.s:
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    float getLeftWidth() -> a
    void setLeftWidth(float) -> a
    float getRightWidth() -> b
    void setRightWidth(float) -> b
    float getTopHeight() -> c
    void setTopHeight(float) -> c
    float getBottomHeight() -> d
    void setBottomHeight(float) -> d
    float getMinWidth() -> e
    void setMinWidth(float) -> e
    float getMinHeight() -> f
    void setMinHeight(float) -> f
com.badlogic.gdx.scenes.scene2d.utils.FocusListener -> com.badlogic.gdx.h.a.c.t:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void keyboardFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> a
    void scrollFocusChanged(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent,com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> b
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$1 -> com.badlogic.gdx.h.a.c.u:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$utils$FocusListener$FocusEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> com.badlogic.gdx.h.a.c.v:
    boolean focused -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> b
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> c
    void reset() -> c
    boolean isFocused() -> m
    void setFocused(boolean) -> c
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type getType() -> n
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> o
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> com.badlogic.gdx.h.a.c.w:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> c
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] values() -> values
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.utils.Layout -> com.badlogic.gdx.h.a.c.x:
    void layout() -> f_
    void invalidate() -> d_
    void invalidateHierarchy() -> ae
    void validate() -> g_
    void pack() -> h_
    void setFillParent(boolean) -> b_
    void setLayoutEnabled(boolean) -> g
    float getMinWidth() -> U
    float getMinHeight() -> V
    float getPrefWidth() -> S
    float getPrefHeight() -> T
    float getMaxWidth() -> i_
    float getMaxHeight() -> j_
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> com.badlogic.gdx.h.a.c.y:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> g
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> com.badlogic.gdx.h.a.c.z:
    com.badlogic.gdx.utils.Array scissors -> c
    com.badlogic.gdx.math.Vector3 tmp -> a
    com.badlogic.gdx.math.Rectangle viewport -> b
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Rectangle popScissors() -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    void calculateScissors(com.badlogic.gdx.graphics.Camera,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Rectangle getViewport() -> b
    void toWindowCoordinates(com.badlogic.gdx.graphics.Camera,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> com.badlogic.gdx.h.a.c.aa:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> g
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> com.badlogic.gdx.h.a.c.ab:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> a
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> g
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> com.badlogic.gdx.h.a.c.ac:
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float,float,float,float) -> a
com.badlogic.gdx.utils.Array -> com.badlogic.gdx.utils.a:
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> e
    com.badlogic.gdx.utils.Predicate$PredicateIterable predicateIterable -> f
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> a
    void addAll(java.lang.Object[]) -> a
    void addAll(java.lang.Object[],int,int) -> a
    java.lang.Object get(int) -> a
    void set(int,java.lang.Object) -> a
    void insert(int,java.lang.Object) -> b
    void swap(int,int) -> a
    boolean contains(java.lang.Object,boolean) -> a
    int indexOf(java.lang.Object,boolean) -> b
    int lastIndexOf(java.lang.Object,boolean) -> c
    boolean removeValue(java.lang.Object,boolean) -> d
    java.lang.Object removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.Array,boolean) -> a
    java.lang.Object pop() -> a
    java.lang.Object peek() -> b
    java.lang.Object first() -> c
    void clear() -> d
    void shrink() -> e
    java.lang.Object[] ensureCapacity(int) -> c
    java.lang.Object[] resize(int) -> d
    void sort() -> f
    void sort(java.util.Comparator) -> a
    void reverse() -> g
    void shuffle() -> h
    java.util.Iterator iterator() -> iterator
    java.lang.Iterable select(com.badlogic.gdx.utils.Predicate) -> a
    void truncate(int) -> e
    java.lang.Object random() -> i
    java.lang.Object[] toArray() -> j
    java.lang.Object[] toArray(java.lang.Class) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.Array$ArrayIterable -> com.badlogic.gdx.utils.b:
    com.badlogic.gdx.utils.Array$ArrayIterator iterator -> a
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.Array$ArrayIterator -> com.badlogic.gdx.utils.c:
    com.badlogic.gdx.utils.Array array -> c
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    void reset() -> a
com.badlogic.gdx.utils.ArrayMap -> com.badlogic.gdx.utils.d:
    java.lang.Object[] keys -> a
    java.lang.Object[] values -> b
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    com.badlogic.gdx.utils.ArrayMap$Values valuesIter1 -> g
    com.badlogic.gdx.utils.ArrayMap$Values valuesIter2 -> h
    com.badlogic.gdx.utils.ArrayMap$Keys keysIter1 -> i
    com.badlogic.gdx.utils.ArrayMap$Keys keysIter2 -> j
    void put(java.lang.Object,java.lang.Object) -> a
    void put(java.lang.Object,java.lang.Object,int) -> a
    void addAll(com.badlogic.gdx.utils.ArrayMap) -> a
    void addAll(com.badlogic.gdx.utils.ArrayMap,int,int) -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object getKey(java.lang.Object,boolean) -> a
    java.lang.Object getKeyAt(int) -> a
    java.lang.Object getValueAt(int) -> b
    java.lang.Object firstKey() -> a
    java.lang.Object firstValue() -> b
    void setKey(int,java.lang.Object) -> a
    void setValue(int,java.lang.Object) -> b
    void insert(int,java.lang.Object,java.lang.Object) -> a
    boolean containsKey(java.lang.Object) -> b
    boolean containsValue(java.lang.Object,boolean) -> b
    int indexOfKey(java.lang.Object) -> c
    int indexOfValue(java.lang.Object,boolean) -> c
    java.lang.Object removeKey(java.lang.Object) -> d
    boolean removeValue(java.lang.Object,boolean) -> d
    void removeIndex(int) -> c
    java.lang.Object peekKey() -> c
    java.lang.Object peekValue() -> d
    void clear() -> e
    void shrink() -> f
    void ensureCapacity(int) -> d
    void resize(int) -> e
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> f
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> i
    com.badlogic.gdx.utils.ArrayMap$Values values() -> j
    com.badlogic.gdx.utils.ArrayMap$Keys keys() -> k
com.badlogic.gdx.utils.ArrayMap$Entries -> com.badlogic.gdx.utils.e:
    com.badlogic.gdx.utils.ArrayMap map -> d
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    int index -> b
    boolean valid -> c
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ArrayMap$Keys -> com.badlogic.gdx.utils.f:
    com.badlogic.gdx.utils.ArrayMap map -> c
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
    void remove() -> remove
    void reset() -> a
com.badlogic.gdx.utils.ArrayMap$Values -> com.badlogic.gdx.utils.g:
    com.badlogic.gdx.utils.ArrayMap map -> c
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
    void remove() -> remove
    void reset() -> a
com.badlogic.gdx.utils.AtomicQueue -> com.badlogic.gdx.utils.h:
    java.util.concurrent.atomic.AtomicInteger writeIndex -> a
    java.util.concurrent.atomic.AtomicInteger readIndex -> b
    java.util.concurrent.atomic.AtomicReferenceArray queue -> c
    int next(int) -> a
    boolean put(java.lang.Object) -> a
    java.lang.Object poll() -> a
com.badlogic.gdx.utils.Base64Coder -> com.badlogic.gdx.utils.i:
    java.lang.String systemLineSeparator -> a
    char[] map1 -> b
    byte[] map2 -> c
    java.lang.String encodeString(java.lang.String) -> a
    java.lang.String encodeLines(byte[]) -> a
    java.lang.String encodeLines(byte[],int,int,int,java.lang.String) -> a
    char[] encode(byte[]) -> b
    char[] encode(byte[],int) -> a
    char[] encode(byte[],int,int) -> a
    java.lang.String decodeString(java.lang.String) -> b
    byte[] decodeLines(java.lang.String) -> c
    byte[] decode(java.lang.String) -> d
    byte[] decode(char[]) -> a
    byte[] decode(char[],int,int) -> a
com.badlogic.gdx.utils.BinaryHeap -> com.badlogic.gdx.utils.j:
    int size -> a
    com.badlogic.gdx.utils.BinaryHeap$Node[] nodes -> b
    boolean isMaxHeap -> c
    com.badlogic.gdx.utils.BinaryHeap$Node add(com.badlogic.gdx.utils.BinaryHeap$Node) -> a
    com.badlogic.gdx.utils.BinaryHeap$Node peek() -> a
    com.badlogic.gdx.utils.BinaryHeap$Node pop() -> b
    void setValue(com.badlogic.gdx.utils.BinaryHeap$Node,float) -> a
    void up(int) -> a
    void down(int) -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.BinaryHeap$Node -> com.badlogic.gdx.utils.k:
    float value -> a
    int index -> b
    float getValue() -> a
com.badlogic.gdx.utils.Bits -> com.badlogic.gdx.utils.l:
    long[] bits -> a
    boolean get(int) -> a
    void set(int) -> b
    void flip(int) -> c
    void checkCapacity(int) -> e
    void clear(int) -> d
    void clear() -> a
    int numBits() -> b
com.badlogic.gdx.utils.BooleanArray -> com.badlogic.gdx.utils.m:
    boolean[] items -> a
    int size -> b
    boolean ordered -> c
    void add(boolean) -> a
    void addAll(com.badlogic.gdx.utils.BooleanArray) -> a
    void addAll(com.badlogic.gdx.utils.BooleanArray,int,int) -> a
    void addAll(boolean[]) -> a
    void addAll(boolean[],int,int) -> a
    boolean get(int) -> a
    void set(int,boolean) -> a
    void insert(int,boolean) -> b
    void swap(int,int) -> a
    boolean removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.BooleanArray) -> b
    boolean pop() -> a
    boolean peek() -> b
    boolean first() -> c
    void clear() -> d
    void shrink() -> e
    boolean[] ensureCapacity(int) -> c
    boolean[] resize(int) -> d
    void reverse() -> f
    void shuffle() -> g
    void truncate(int) -> e
    boolean random() -> h
    boolean[] toArray() -> i
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    void copy(byte[],int,java.nio.Buffer,int) -> a
    void copy(short[],int,java.nio.Buffer,int) -> a
    void copy(char[],int,java.nio.Buffer,int) -> a
    void copy(int[],int,java.nio.Buffer,int) -> a
    void copy(long[],int,java.nio.Buffer,int) -> a
    void copy(float[],int,java.nio.Buffer,int) -> a
    void copy(double[],int,java.nio.Buffer,int) -> a
    void copy(java.nio.Buffer,java.nio.Buffer,int) -> a
    int positionInBytes(java.nio.Buffer) -> b
    int bytesToElements(java.nio.Buffer,int) -> a
    int elementsToBytes(java.nio.Buffer,int) -> b
    java.nio.FloatBuffer newFloatBuffer(int) -> a
    java.nio.DoubleBuffer newDoubleBuffer(int) -> b
    java.nio.ByteBuffer newByteBuffer(int) -> c
    java.nio.ShortBuffer newShortBuffer(int) -> d
    java.nio.CharBuffer newCharBuffer(int) -> e
    java.nio.IntBuffer newIntBuffer(int) -> f
    java.nio.LongBuffer newLongBuffer(int) -> g
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> h
    long getUnsafeBufferAddress(java.nio.Buffer) -> a
    java.nio.ByteBuffer newUnsafeByteBuffer(java.nio.ByteBuffer) -> b
    int getAllocatedBytesUnsafe() -> a
    void freeMemory(java.nio.ByteBuffer) -> freeMemory
    java.nio.ByteBuffer newDisposableByteBuffer(int) -> newDisposableByteBuffer
    long getBufferAddress(java.nio.Buffer) -> getBufferAddress
    void clear(java.nio.ByteBuffer,int) -> clear
    void copyJni(float[],java.nio.Buffer,int,int) -> copyJni
    void copyJni(byte[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(char[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(short[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(int[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(long[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(float[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(double[],int,java.nio.Buffer,int,int) -> copyJni
    void copyJni(java.nio.Buffer,int,java.nio.Buffer,int,int) -> copyJni
com.badlogic.gdx.utils.CharArray -> com.badlogic.gdx.utils.n:
    char[] items -> a
    int size -> b
    boolean ordered -> c
    void add(char) -> a
    void addAll(com.badlogic.gdx.utils.CharArray) -> a
    void addAll(com.badlogic.gdx.utils.CharArray,int,int) -> a
    void addAll(char[]) -> a
    void addAll(char[],int,int) -> a
    char get(int) -> a
    void set(int,char) -> a
    void insert(int,char) -> b
    void swap(int,int) -> a
    boolean contains(char) -> b
    int indexOf(char) -> c
    int lastIndexOf(char) -> d
    boolean removeValue(char) -> e
    char removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.CharArray) -> b
    char pop() -> a
    char peek() -> b
    char first() -> c
    void clear() -> d
    void shrink() -> e
    char[] ensureCapacity(int) -> c
    char[] resize(int) -> d
    void sort() -> f
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
    char random() -> i
    char[] toArray() -> j
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.Clipboard -> com.badlogic.gdx.utils.o:
    java.lang.String getContents() -> a
    void setContents(java.lang.String) -> a
com.badlogic.gdx.utils.ComparableTimSort -> com.badlogic.gdx.utils.p:
    int MIN_MERGE -> a
    java.lang.Object[] a -> b
    int MIN_GALLOP -> c
    int minGallop -> d
    int INITIAL_TMP_STORAGE_LENGTH -> e
    java.lang.Object[] tmp -> f
    int stackSize -> g
    int[] runBase -> h
    int[] runLen -> i
    boolean DEBUG -> j
    void doSort(java.lang.Object[],int,int) -> a
    void sort(java.lang.Object[]) -> a
    void sort(java.lang.Object[],int,int) -> b
    void binarySort(java.lang.Object[],int,int,int) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int) -> c
    void reverseRange(java.lang.Object[],int,int) -> d
    int minRunLength(int) -> a
    void pushRun(int,int) -> a
    void mergeCollapse() -> a
    void mergeForceCollapse() -> b
    void mergeAt(int) -> b
    int gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int) -> a
    int gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int) -> b
    void mergeLo(int,int,int,int) -> a
    void mergeHi(int,int,int,int) -> b
    java.lang.Object[] ensureCapacity(int) -> c
    void rangeCheck(int,int,int) -> a
com.badlogic.gdx.utils.DataInput -> com.badlogic.gdx.utils.q:
    char[] chars -> a
    int readInt(boolean) -> a
    java.lang.String readString() -> a
    void readUtf8_slow(int,int,int) -> a
com.badlogic.gdx.utils.DataOutput -> com.badlogic.gdx.utils.r:
    int writeInt(int,boolean) -> a
    void writeString(java.lang.String) -> a
    void writeString_slow(java.lang.String,int,int) -> a
com.badlogic.gdx.utils.DelayedRemovalArray -> com.badlogic.gdx.utils.s:
    boolean iterating -> d
    com.badlogic.gdx.utils.IntArray remove -> e
    void begin() -> k
    void end() -> l
    void remove(int) -> f
    boolean removeValue(java.lang.Object,boolean) -> d
    java.lang.Object removeIndex(int) -> b
    void set(int,java.lang.Object) -> a
    void insert(int,java.lang.Object) -> b
    void swap(int,int) -> a
    java.lang.Object pop() -> a
    void clear() -> d
    void sort() -> f
    void sort(java.util.Comparator) -> a
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
com.badlogic.gdx.utils.Disposable -> com.badlogic.gdx.utils.t:
    void dispose() -> e
com.badlogic.gdx.utils.FloatArray -> com.badlogic.gdx.utils.u:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray,int,int) -> a
    void addAll(float[]) -> a
    void addAll(float[],int,int) -> a
    float get(int) -> a
    void set(int,float) -> a
    void insert(int,float) -> b
    void swap(int,int) -> a
    boolean contains(float) -> b
    int indexOf(float) -> c
    int lastIndexOf(char) -> a
    boolean removeValue(float) -> d
    float removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.FloatArray) -> b
    float pop() -> a
    float peek() -> b
    float first() -> c
    void clear() -> d
    void shrink() -> e
    float[] ensureCapacity(int) -> c
    float[] resize(int) -> d
    void sort() -> f
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
    float random() -> i
    float[] toArray() -> j
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.GdxBuild -> com.badlogic.gdx.utils.v:
    void main(java.lang.String[]) -> a
com.badlogic.gdx.utils.GdxNativesLoader -> com.badlogic.gdx.utils.w:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> com.badlogic.gdx.utils.x:
    long serialVersionUID -> a
com.badlogic.gdx.utils.GwtModuleGenerator -> com.badlogic.gdx.utils.y:
    void gatherJavaFiles(com.badlogic.gdx.files.FileHandle,java.util.Set,java.util.Map,boolean) -> a
    void main(java.lang.String[]) -> a
com.badlogic.gdx.utils.IdentityMap -> com.badlogic.gdx.utils.z:
    int PRIME1 -> f
    int PRIME2 -> g
    int PRIME3 -> h
    int size -> a
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> i
    int hashShift -> j
    int mask -> k
    int threshold -> l
    int stashCapacity -> m
    int pushIterations -> n
    com.badlogic.gdx.utils.IdentityMap$Entries entries1 -> o
    com.badlogic.gdx.utils.IdentityMap$Entries entries2 -> p
    com.badlogic.gdx.utils.IdentityMap$Values values1 -> q
    com.badlogic.gdx.utils.IdentityMap$Values values2 -> r
    com.badlogic.gdx.utils.IdentityMap$Keys keys1 -> s
    com.badlogic.gdx.utils.IdentityMap$Keys keys2 -> t
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    void putResize(java.lang.Object,java.lang.Object) -> c
    void push(java.lang.Object,java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,java.lang.Object) -> d
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object get(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getStash(java.lang.Object,java.lang.Object) -> e
    java.lang.Object remove(java.lang.Object) -> b
    java.lang.Object removeStash(java.lang.Object) -> c
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(java.lang.Object,boolean) -> a
    boolean containsKey(java.lang.Object) -> d
    boolean containsKeyStash(java.lang.Object) -> e
    java.lang.Object findKey(java.lang.Object,boolean) -> b
    void ensureCapacity(int) -> b
    void resize(int) -> c
    int hash2(int) -> d
    int hash3(int) -> e
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.IdentityMap$Entries entries() -> b
    com.badlogic.gdx.utils.IdentityMap$Values values() -> c
    com.badlogic.gdx.utils.IdentityMap$Keys keys() -> d
com.badlogic.gdx.utils.IdentityMap$Entries -> com.badlogic.gdx.utils.aa:
    com.badlogic.gdx.utils.IdentityMap$Entry entry -> f
    com.badlogic.gdx.utils.IdentityMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.IdentityMap$Entry -> com.badlogic.gdx.utils.ab:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.IdentityMap$Keys -> com.badlogic.gdx.utils.ac:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IdentityMap$MapIterator -> com.badlogic.gdx.utils.ad:
    boolean hasNext -> a
    com.badlogic.gdx.utils.IdentityMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.IdentityMap$Values -> com.badlogic.gdx.utils.ae:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void toArray(com.badlogic.gdx.utils.Array) -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntArray -> com.badlogic.gdx.utils.af:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    void addAll(com.badlogic.gdx.utils.IntArray) -> a
    void addAll(com.badlogic.gdx.utils.IntArray,int,int) -> a
    void addAll(int[]) -> a
    void addAll(int[],int,int) -> a
    int get(int) -> b
    void set(int,int) -> a
    void insert(int,int) -> b
    void swap(int,int) -> c
    boolean contains(int) -> c
    int indexOf(int) -> d
    int lastIndexOf(int) -> e
    boolean removeValue(int) -> f
    int removeIndex(int) -> g
    boolean removeAll(com.badlogic.gdx.utils.IntArray) -> b
    int pop() -> a
    int peek() -> b
    int first() -> c
    void clear() -> d
    void shrink() -> e
    int[] ensureCapacity(int) -> h
    int[] resize(int) -> i
    void sort() -> f
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> j
    int random() -> i
    int[] toArray() -> j
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.IntFloatMap -> com.badlogic.gdx.utils.ag:
    int PRIME1 -> h
    int PRIME2 -> i
    int PRIME3 -> j
    int EMPTY -> k
    int size -> a
    int[] keyTable -> b
    float[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> l
    int hashShift -> m
    int mask -> n
    int threshold -> o
    int stashCapacity -> p
    int pushIterations -> q
    com.badlogic.gdx.utils.IntFloatMap$Entries entries1 -> r
    com.badlogic.gdx.utils.IntFloatMap$Entries entries2 -> s
    com.badlogic.gdx.utils.IntFloatMap$Values values1 -> t
    com.badlogic.gdx.utils.IntFloatMap$Values values2 -> u
    com.badlogic.gdx.utils.IntFloatMap$Keys keys1 -> v
    com.badlogic.gdx.utils.IntFloatMap$Keys keys2 -> w
    void put(int,float) -> a
    void putAll(com.badlogic.gdx.utils.IntFloatMap) -> a
    void putResize(int,float) -> e
    void push(int,float,int,int,int,int,int,int) -> a
    void putStash(int,float) -> f
    float get(int,float) -> b
    float getStash(int,float) -> g
    float getAndIncrement(int,float,float) -> a
    float getAndIncrementStash(int,float,float) -> b
    float remove(int,float) -> c
    float removeStash(int,float) -> d
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(float) -> a
    boolean containsValue(float,float) -> a
    boolean containsKey(int) -> b
    boolean containsKeyStash(int) -> d
    int findKey(float,int) -> a
    void ensureCapacity(int) -> c
    void resize(int) -> e
    int hash2(int) -> f
    int hash3(int) -> g
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.IntFloatMap$Entries entries() -> b
    com.badlogic.gdx.utils.IntFloatMap$Values values() -> c
    com.badlogic.gdx.utils.IntFloatMap$Keys keys() -> d
com.badlogic.gdx.utils.IntFloatMap$Entries -> com.badlogic.gdx.utils.ah:
    com.badlogic.gdx.utils.IntFloatMap$Entry entry -> h
    com.badlogic.gdx.utils.IntFloatMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.IntFloatMap$Entry -> com.badlogic.gdx.utils.ai:
    int key -> a
    float value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.IntFloatMap$Keys -> com.badlogic.gdx.utils.aj:
    boolean hasNext() -> a
    int next() -> c
    com.badlogic.gdx.utils.IntArray toArray() -> d
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntFloatMap$MapIterator -> com.badlogic.gdx.utils.ak:
    int INDEX_ILLEGAL -> a
    int INDEX_ZERO -> b
    boolean hasNext -> c
    com.badlogic.gdx.utils.IntFloatMap map -> d
    int nextIndex -> e
    int currentIndex -> f
    boolean valid -> g
    void reset() -> b
    void findNextIndex() -> e
    void remove() -> remove
com.badlogic.gdx.utils.IntFloatMap$Values -> com.badlogic.gdx.utils.al:
    boolean hasNext() -> a
    float next() -> c
    com.badlogic.gdx.utils.FloatArray toArray() -> d
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntIntMap -> com.badlogic.gdx.utils.am:
    int PRIME1 -> h
    int PRIME2 -> i
    int PRIME3 -> j
    int EMPTY -> k
    int size -> a
    int[] keyTable -> b
    int[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    int zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> l
    int hashShift -> m
    int mask -> n
    int threshold -> o
    int stashCapacity -> p
    int pushIterations -> q
    com.badlogic.gdx.utils.IntIntMap$Entries entries1 -> r
    com.badlogic.gdx.utils.IntIntMap$Entries entries2 -> s
    com.badlogic.gdx.utils.IntIntMap$Values values1 -> t
    com.badlogic.gdx.utils.IntIntMap$Values values2 -> u
    com.badlogic.gdx.utils.IntIntMap$Keys keys1 -> v
    com.badlogic.gdx.utils.IntIntMap$Keys keys2 -> w
    void put(int,int) -> a
    void putAll(com.badlogic.gdx.utils.IntIntMap) -> a
    void putResize(int,int) -> f
    void push(int,int,int,int,int,int,int,int) -> a
    void putStash(int,int) -> g
    int get(int,int) -> b
    int getStash(int,int) -> h
    int getAndIncrement(int,int,int) -> a
    int getAndIncrementStash(int,int,int) -> b
    int remove(int,int) -> c
    int removeStash(int,int) -> d
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(int) -> b
    boolean containsKey(int) -> c
    boolean containsKeyStash(int) -> e
    int findKey(int,int) -> e
    void ensureCapacity(int) -> d
    void resize(int) -> f
    int hash2(int) -> g
    int hash3(int) -> h
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.IntIntMap$Entries entries() -> b
    com.badlogic.gdx.utils.IntIntMap$Values values() -> c
    com.badlogic.gdx.utils.IntIntMap$Keys keys() -> d
com.badlogic.gdx.utils.IntIntMap$Entries -> com.badlogic.gdx.utils.an:
    com.badlogic.gdx.utils.IntIntMap$Entry entry -> h
    com.badlogic.gdx.utils.IntIntMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.IntIntMap$Entry -> com.badlogic.gdx.utils.ao:
    int key -> a
    int value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.IntIntMap$Keys -> com.badlogic.gdx.utils.ap:
    boolean hasNext() -> a
    int next() -> c
    com.badlogic.gdx.utils.IntArray toArray() -> d
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntIntMap$MapIterator -> com.badlogic.gdx.utils.aq:
    int INDEX_ILLEGAL -> a
    int INDEX_ZERO -> b
    boolean hasNext -> c
    com.badlogic.gdx.utils.IntIntMap map -> d
    int nextIndex -> e
    int currentIndex -> f
    boolean valid -> g
    void reset() -> b
    void findNextIndex() -> e
    void remove() -> remove
com.badlogic.gdx.utils.IntIntMap$Values -> com.badlogic.gdx.utils.ar:
    boolean hasNext() -> a
    int next() -> c
    com.badlogic.gdx.utils.IntArray toArray() -> d
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntMap -> com.badlogic.gdx.utils.as:
    int PRIME1 -> h
    int PRIME2 -> i
    int PRIME3 -> j
    int EMPTY -> k
    int size -> a
    int[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    java.lang.Object zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> l
    int hashShift -> m
    int mask -> n
    int threshold -> o
    int stashCapacity -> p
    int pushIterations -> q
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> r
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> s
    com.badlogic.gdx.utils.IntMap$Values values1 -> t
    com.badlogic.gdx.utils.IntMap$Values values2 -> u
    com.badlogic.gdx.utils.IntMap$Keys keys1 -> v
    com.badlogic.gdx.utils.IntMap$Keys keys2 -> w
    java.lang.Object put(int,java.lang.Object) -> a
    void putAll(com.badlogic.gdx.utils.IntMap) -> a
    void putResize(int,java.lang.Object) -> c
    void push(int,java.lang.Object,int,int,int,int,int,int) -> a
    void putStash(int,java.lang.Object) -> d
    java.lang.Object get(int) -> a
    java.lang.Object get(int,java.lang.Object) -> b
    java.lang.Object getStash(int,java.lang.Object) -> e
    java.lang.Object remove(int) -> b
    java.lang.Object removeStash(int) -> c
    void removeStashIndex(int) -> d
    void clear() -> a
    boolean containsValue(java.lang.Object,boolean) -> a
    boolean containsKey(int) -> e
    boolean containsKeyStash(int) -> g
    int findKey(java.lang.Object,boolean,int) -> a
    void ensureCapacity(int) -> f
    void resize(int) -> h
    int hash2(int) -> i
    int hash3(int) -> j
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.IntMap$Entries entries() -> b
    com.badlogic.gdx.utils.IntMap$Values values() -> c
    com.badlogic.gdx.utils.IntMap$Keys keys() -> d
com.badlogic.gdx.utils.IntMap$Entries -> com.badlogic.gdx.utils.at:
    com.badlogic.gdx.utils.IntMap$Entry entry -> h
    com.badlogic.gdx.utils.IntMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.IntMap$Entry -> com.badlogic.gdx.utils.au:
    int key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.IntMap$Keys -> com.badlogic.gdx.utils.av:
    int next() -> a
    com.badlogic.gdx.utils.IntArray toArray() -> c
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.IntMap$MapIterator -> com.badlogic.gdx.utils.aw:
    int INDEX_ILLEGAL -> a
    int INDEX_ZERO -> b
    boolean hasNext -> c
    com.badlogic.gdx.utils.IntMap map -> d
    int nextIndex -> e
    int currentIndex -> f
    boolean valid -> g
    void reset() -> b
    void findNextIndex() -> d
    void remove() -> remove
com.badlogic.gdx.utils.IntMap$Values -> com.badlogic.gdx.utils.ax:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.Json -> com.badlogic.gdx.utils.ay:
    boolean debug -> a
    com.badlogic.gdx.utils.JsonWriter writer -> b
    java.lang.String typeName -> c
    boolean usePrototypes -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> e
    com.badlogic.gdx.utils.ObjectMap typeToFields -> f
    com.badlogic.gdx.utils.ObjectMap tagToClass -> g
    com.badlogic.gdx.utils.ObjectMap classToTag -> h
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> i
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> j
    boolean ignoreUnknownFields -> k
    void setIgnoreUnknownFields(boolean) -> a
    void setOutputType(com.badlogic.gdx.utils.JsonWriter$OutputType) -> a
    void addClassTag(java.lang.String,java.lang.Class) -> a
    java.lang.Class getClass(java.lang.String) -> a
    java.lang.String getTag(java.lang.Class) -> a
    void setTypeName(java.lang.String) -> b
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> a
    com.badlogic.gdx.utils.Json$Serializer getSerializer(java.lang.Class) -> b
    void setUsePrototypes(boolean) -> b
    void setElementType(java.lang.Class,java.lang.String,java.lang.Class) -> a
    com.badlogic.gdx.utils.ObjectMap cacheFields(java.lang.Class) -> d
    java.lang.String toJson(java.lang.Object) -> a
    java.lang.String toJson(java.lang.Object,java.lang.Class) -> a
    java.lang.String toJson(java.lang.Object,java.lang.Class,java.lang.Class) -> a
    void toJson(java.lang.Object,com.badlogic.gdx.files.FileHandle) -> a
    void toJson(java.lang.Object,java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    void toJson(java.lang.Object,java.lang.Class,java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    void toJson(java.lang.Object,java.io.Writer) -> a
    void toJson(java.lang.Object,java.lang.Class,java.io.Writer) -> a
    void toJson(java.lang.Object,java.lang.Class,java.lang.Class,java.io.Writer) -> a
    void setWriter(java.io.Writer) -> a
    com.badlogic.gdx.utils.JsonWriter getWriter() -> a
    void writeFields(java.lang.Object) -> b
    java.lang.Object[] getDefaultValues(java.lang.Class) -> e
    void writeField(java.lang.Object,java.lang.String) -> a
    void writeField(java.lang.Object,java.lang.String,java.lang.Class) -> a
    void writeField(java.lang.Object,java.lang.String,java.lang.String) -> a
    void writeField(java.lang.Object,java.lang.String,java.lang.String,java.lang.Class) -> a
    void writeValue(java.lang.String,java.lang.Object) -> a
    void writeValue(java.lang.String,java.lang.Object,java.lang.Class) -> a
    void writeValue(java.lang.String,java.lang.Object,java.lang.Class,java.lang.Class) -> a
    void writeValue(java.lang.Object) -> c
    void writeValue(java.lang.Object,java.lang.Class) -> b
    void writeValue(java.lang.Object,java.lang.Class,java.lang.Class) -> b
    void writeObjectStart(java.lang.String) -> c
    void writeObjectStart(java.lang.String,java.lang.Class,java.lang.Class) -> a
    void writeObjectStart() -> b
    void writeObjectStart(java.lang.Class,java.lang.Class) -> a
    void writeObjectEnd() -> c
    void writeArrayStart(java.lang.String) -> d
    void writeArrayStart() -> d
    void writeArrayEnd() -> e
    void writeType(java.lang.Class) -> c
    java.lang.Object fromJson(java.lang.Class,java.io.Reader) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.Class,java.io.Reader) -> a
    java.lang.Object fromJson(java.lang.Class,java.io.InputStream) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.Class,java.io.InputStream) -> a
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object fromJson(java.lang.Class,char[],int,int) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.Class,char[],int,int) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.String) -> a
    java.lang.Object fromJson(java.lang.Class,java.lang.Class,java.lang.String) -> a
    void readField(java.lang.Object,java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void readField(java.lang.Object,java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    void readField(java.lang.Object,java.lang.String,java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void readField(java.lang.Object,java.lang.String,java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.String convertToString(java.lang.Object) -> e
    java.lang.Object newInstance(java.lang.Class) -> f
    java.lang.String prettyPrint(java.lang.Object) -> d
    java.lang.String prettyPrint(java.lang.String) -> e
    java.lang.String prettyPrint(java.lang.Object,int) -> a
    java.lang.String prettyPrint(java.lang.String,int) -> a
com.badlogic.gdx.utils.Json$FieldMetadata -> com.badlogic.gdx.utils.az:
    java.lang.reflect.Field field -> a
    java.lang.Class elementType -> b
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> com.badlogic.gdx.utils.ba:
    void write(com.badlogic.gdx.utils.Json,java.lang.Object,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.utils.Json$Serializable -> com.badlogic.gdx.utils.bb:
    void write(com.badlogic.gdx.utils.Json) -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> com.badlogic.gdx.utils.bc:
    void write(com.badlogic.gdx.utils.Json,java.lang.Object,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.utils.JsonReader -> com.badlogic.gdx.utils.bd:
    byte[] _json_actions -> g
    short[] _json_key_offsets -> h
    char[] _json_trans_keys -> i
    byte[] _json_single_lengths -> j
    byte[] _json_range_lengths -> k
    short[] _json_index_offsets -> l
    byte[] _json_trans_targs -> m
    byte[] _json_trans_actions -> n
    byte[] _json_eof_actions -> o
    int json_start -> a
    int json_first_final -> b
    int json_error -> c
    int json_en_object -> d
    int json_en_array -> e
    int json_en_main -> f
    com.badlogic.gdx.utils.Array elements -> p
    com.badlogic.gdx.utils.JsonValue root -> q
    com.badlogic.gdx.utils.JsonValue current -> r
    com.badlogic.gdx.utils.JsonValue parse(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.InputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> a
    byte[] init__json_actions_0() -> b
    short[] init__json_key_offsets_0() -> c
    char[] init__json_trans_keys_0() -> d
    byte[] init__json_single_lengths_0() -> e
    byte[] init__json_range_lengths_0() -> f
    short[] init__json_index_offsets_0() -> g
    byte[] init__json_trans_targs_0() -> h
    byte[] init__json_trans_actions_0() -> i
    byte[] init__json_eof_actions_0() -> j
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void startObject(java.lang.String) -> b
    void startArray(java.lang.String) -> c
    void pop() -> a
    void string(java.lang.String,java.lang.String) -> a
    void number(java.lang.String,double) -> a
    void number(java.lang.String,long) -> a
    void bool(java.lang.String,boolean) -> a
    java.lang.String unescape(java.lang.String) -> d
com.badlogic.gdx.utils.JsonValue -> com.badlogic.gdx.utils.be:
    java.lang.String name -> a
    com.badlogic.gdx.utils.JsonValue$ValueType type -> b
    java.lang.String stringValue -> c
    java.lang.Boolean booleanValue -> d
    java.lang.Double doubleValue -> e
    long longValue -> f
    com.badlogic.gdx.utils.JsonValue child -> g
    com.badlogic.gdx.utils.JsonValue next -> h
    com.badlogic.gdx.utils.JsonValue prev -> i
    com.badlogic.gdx.utils.JsonValue get(int) -> a
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue require(int) -> b
    com.badlogic.gdx.utils.JsonValue require(java.lang.String) -> b
    com.badlogic.gdx.utils.JsonValue remove(int) -> c
    com.badlogic.gdx.utils.JsonValue remove(java.lang.String) -> c
    int size() -> a
    java.lang.String asString() -> b
    float asFloat() -> c
    double asDouble() -> d
    long asLong() -> e
    int asInt() -> f
    boolean asBoolean() -> g
    com.badlogic.gdx.utils.JsonValue getChild(java.lang.String) -> d
    java.lang.String getString(java.lang.String,java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    double getDouble(java.lang.String,double) -> a
    long getLong(java.lang.String,long) -> a
    int getInt(java.lang.String,int) -> a
    boolean getBoolean(java.lang.String,boolean) -> a
    java.lang.String getString(java.lang.String) -> e
    float getFloat(java.lang.String) -> f
    double getDouble(java.lang.String) -> g
    long getLong(java.lang.String) -> h
    int getInt(java.lang.String) -> i
    boolean getBoolean(java.lang.String) -> j
    java.lang.String getString(int) -> d
    float getFloat(int) -> e
    double getDouble(int) -> f
    long getLong(int) -> g
    int getInt(int) -> h
    boolean getBoolean(int) -> i
    com.badlogic.gdx.utils.JsonValue$ValueType type() -> h
    void setType(com.badlogic.gdx.utils.JsonValue$ValueType) -> a
    boolean isArray() -> i
    boolean isObject() -> j
    boolean isString() -> k
    boolean isNumber() -> l
    boolean isDouble() -> m
    boolean isLong() -> n
    boolean isBoolean() -> o
    boolean isNull() -> p
    boolean isValue() -> q
    java.lang.String name() -> r
    void setName(java.lang.String) -> k
    com.badlogic.gdx.utils.JsonValue child() -> s
    void addChild(com.badlogic.gdx.utils.JsonValue) -> a
    com.badlogic.gdx.utils.JsonValue next() -> t
    void setNext(com.badlogic.gdx.utils.JsonValue) -> b
    com.badlogic.gdx.utils.JsonValue prev() -> u
    void setPrev(com.badlogic.gdx.utils.JsonValue) -> c
    void set(java.lang.String) -> l
    void set(double) -> a
    void set(long) -> a
    void set(boolean) -> a
    java.lang.String toString() -> toString
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> a
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,com.badlogic.gdx.utils.JsonWriter$OutputType,int,int) -> a
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> d
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> a
com.badlogic.gdx.utils.JsonValue$1 -> com.badlogic.gdx.utils.bf:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$ValueType -> com.badlogic.gdx.utils.bg:
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType[] values() -> values
    com.badlogic.gdx.utils.JsonValue$ValueType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.utils.JsonWriter -> com.badlogic.gdx.utils.bh:
    java.io.Writer writer -> a
    com.badlogic.gdx.utils.Array stack -> b
    com.badlogic.gdx.utils.JsonWriter$JsonObject current -> c
    boolean named -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> e
    java.io.Writer getWriter() -> a
    void setOutputType(com.badlogic.gdx.utils.JsonWriter$OutputType) -> a
    com.badlogic.gdx.utils.JsonWriter name(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonWriter object() -> b
    com.badlogic.gdx.utils.JsonWriter array() -> c
    com.badlogic.gdx.utils.JsonWriter value(java.lang.Object) -> a
    com.badlogic.gdx.utils.JsonWriter object(java.lang.String) -> b
    com.badlogic.gdx.utils.JsonWriter array(java.lang.String) -> c
    com.badlogic.gdx.utils.JsonWriter set(java.lang.String,java.lang.Object) -> a
    com.badlogic.gdx.utils.JsonWriter pop() -> d
    void write(char[],int,int) -> write
    void flush() -> flush
    void close() -> close
com.badlogic.gdx.utils.JsonWriter$1 -> com.badlogic.gdx.utils.bi:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$JsonObject -> com.badlogic.gdx.utils.bj:
    boolean array -> a
    boolean needsComma -> b
    com.badlogic.gdx.utils.JsonWriter this$0 -> c
    void close() -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> com.badlogic.gdx.utils.bk:
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    java.util.regex.Pattern minimalValuePattern -> e
    java.util.regex.Pattern minimalNamePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    com.badlogic.gdx.utils.JsonWriter$OutputType[] values() -> values
    com.badlogic.gdx.utils.JsonWriter$OutputType valueOf(java.lang.String) -> valueOf
    java.lang.String quoteValue(java.lang.Object) -> a
    java.lang.String quoteName(java.lang.String) -> a
com.badlogic.gdx.utils.LittleEndianInputStream -> com.badlogic.gdx.utils.bl:
    java.io.DataInputStream din -> a
    void readFully(byte[]) -> readFully
    void readFully(byte[],int,int) -> readFully
    int skipBytes(int) -> skipBytes
    boolean readBoolean() -> readBoolean
    byte readByte() -> readByte
    int readUnsignedByte() -> readUnsignedByte
    short readShort() -> readShort
    int readUnsignedShort() -> readUnsignedShort
    char readChar() -> readChar
    int readInt() -> readInt
    long readLong() -> readLong
    float readFloat() -> readFloat
    double readDouble() -> readDouble
    java.lang.String readLine() -> readLine
    java.lang.String readUTF() -> readUTF
com.badlogic.gdx.utils.Logger -> com.badlogic.gdx.utils.bm:
    int NONE -> a
    int ERROR -> b
    int INFO -> c
    int DEBUG -> d
    java.lang.String tag -> e
    int level -> f
    void debug(java.lang.String) -> a
    void debug(java.lang.String,java.lang.Exception) -> a
    void info(java.lang.String) -> b
    void info(java.lang.String,java.lang.Exception) -> b
    void error(java.lang.String) -> c
    void error(java.lang.String,java.lang.Throwable) -> a
    void setLevel(int) -> a
    int getLevel() -> a
com.badlogic.gdx.utils.LongArray -> com.badlogic.gdx.utils.bn:
    long[] items -> a
    int size -> b
    boolean ordered -> c
    void add(long) -> a
    void addAll(com.badlogic.gdx.utils.LongArray) -> a
    void addAll(com.badlogic.gdx.utils.LongArray,int,int) -> a
    void addAll(long[]) -> a
    void addAll(long[],int,int) -> a
    long get(int) -> a
    void set(int,long) -> a
    void insert(int,long) -> b
    void swap(int,int) -> a
    boolean contains(long) -> b
    int indexOf(long) -> c
    int lastIndexOf(char) -> a
    boolean removeValue(long) -> d
    long removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.LongArray) -> b
    long pop() -> a
    long peek() -> b
    long first() -> c
    void clear() -> d
    void shrink() -> e
    long[] ensureCapacity(int) -> c
    long[] resize(int) -> d
    void sort() -> f
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
    long random() -> i
    long[] toArray() -> j
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.LongMap -> com.badlogic.gdx.utils.bo:
    int PRIME1 -> h
    int PRIME2 -> i
    int PRIME3 -> j
    int EMPTY -> k
    int size -> a
    long[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    java.lang.Object zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> l
    int hashShift -> m
    int mask -> n
    int threshold -> o
    int stashCapacity -> p
    int pushIterations -> q
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> r
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> s
    com.badlogic.gdx.utils.LongMap$Values values1 -> t
    com.badlogic.gdx.utils.LongMap$Values values2 -> u
    com.badlogic.gdx.utils.LongMap$Keys keys1 -> v
    com.badlogic.gdx.utils.LongMap$Keys keys2 -> w
    java.lang.Object put(long,java.lang.Object) -> a
    void putAll(com.badlogic.gdx.utils.LongMap) -> a
    void putResize(long,java.lang.Object) -> c
    void push(long,java.lang.Object,int,long,int,long,int,long) -> a
    void putStash(long,java.lang.Object) -> d
    java.lang.Object get(long) -> a
    java.lang.Object get(long,java.lang.Object) -> b
    java.lang.Object getStash(long,java.lang.Object) -> e
    java.lang.Object remove(long) -> b
    java.lang.Object removeStash(long) -> c
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(java.lang.Object,boolean) -> a
    boolean containsKey(long) -> d
    boolean containsKeyStash(long) -> e
    long findKey(java.lang.Object,boolean,long) -> a
    void ensureCapacity(int) -> b
    void resize(int) -> c
    int hash2(long) -> f
    int hash3(long) -> g
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.LongMap$Entries entries() -> b
    com.badlogic.gdx.utils.LongMap$Values values() -> c
    com.badlogic.gdx.utils.LongMap$Keys keys() -> d
com.badlogic.gdx.utils.LongMap$Entries -> com.badlogic.gdx.utils.bp:
    com.badlogic.gdx.utils.LongMap$Entry entry -> h
    com.badlogic.gdx.utils.LongMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.LongMap$Entry -> com.badlogic.gdx.utils.bq:
    long key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.LongMap$Keys -> com.badlogic.gdx.utils.br:
    long next() -> a
    com.badlogic.gdx.utils.LongArray toArray() -> c
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.LongMap$MapIterator -> com.badlogic.gdx.utils.bs:
    int INDEX_ILLEGAL -> a
    int INDEX_ZERO -> b
    boolean hasNext -> c
    com.badlogic.gdx.utils.LongMap map -> d
    int nextIndex -> e
    int currentIndex -> f
    boolean valid -> g
    void reset() -> b
    void findNextIndex() -> d
    void remove() -> remove
com.badlogic.gdx.utils.LongMap$Values -> com.badlogic.gdx.utils.bt:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.NumberUtils -> com.badlogic.gdx.utils.bu:
    boolean intToFloatColorMask -> a
    int floatToIntBits(float) -> a
    int floatToRawIntBits(float) -> b
    int floatToIntColor(float) -> c
    float intToFloatColor(int) -> a
    float intBitsToFloat(int) -> b
    long doubleToLongBits(double) -> a
    double longBitsToDouble(long) -> a
com.badlogic.gdx.utils.ObjectIntMap -> com.badlogic.gdx.utils.bv:
    int PRIME1 -> f
    int PRIME2 -> g
    int PRIME3 -> h
    int size -> a
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> i
    int hashShift -> j
    int mask -> k
    int threshold -> l
    int stashCapacity -> m
    int pushIterations -> n
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> o
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> p
    com.badlogic.gdx.utils.ObjectIntMap$Values values1 -> q
    com.badlogic.gdx.utils.ObjectIntMap$Values values2 -> r
    com.badlogic.gdx.utils.ObjectIntMap$Keys keys1 -> s
    com.badlogic.gdx.utils.ObjectIntMap$Keys keys2 -> t
    void put(java.lang.Object,int) -> a
    void putAll(com.badlogic.gdx.utils.ObjectIntMap) -> a
    void putResize(java.lang.Object,int) -> e
    void push(java.lang.Object,int,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,int) -> f
    int get(java.lang.Object,int) -> b
    int getStash(java.lang.Object,int) -> g
    int getAndIncrement(java.lang.Object,int,int) -> a
    int getAndIncrementStash(java.lang.Object,int,int) -> b
    int remove(java.lang.Object,int) -> c
    int removeStash(java.lang.Object,int) -> d
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(int) -> b
    boolean containsKey(java.lang.Object) -> a
    boolean containsKeyStash(java.lang.Object) -> b
    java.lang.Object findKey(int) -> c
    void ensureCapacity(int) -> d
    void resize(int) -> e
    int hash2(int) -> f
    int hash3(int) -> g
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectIntMap$Values values() -> c
    com.badlogic.gdx.utils.ObjectIntMap$Keys keys() -> d
com.badlogic.gdx.utils.ObjectIntMap$Entries -> com.badlogic.gdx.utils.bw:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectIntMap$Entry -> com.badlogic.gdx.utils.bx:
    java.lang.Object key -> a
    int value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectIntMap$Keys -> com.badlogic.gdx.utils.by:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> com.badlogic.gdx.utils.bz:
    boolean hasNext -> a
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectIntMap$Values -> com.badlogic.gdx.utils.ca:
    boolean hasNext() -> a
    int next() -> d
    com.badlogic.gdx.utils.IntArray toArray() -> e
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap -> com.badlogic.gdx.utils.cb:
    int PRIME1 -> f
    int PRIME2 -> g
    int PRIME3 -> h
    int size -> a
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> i
    int hashShift -> j
    int mask -> k
    int threshold -> l
    int stashCapacity -> m
    int pushIterations -> n
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> o
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> p
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> q
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> r
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> s
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> t
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    java.lang.Object put_internal(java.lang.Object,java.lang.Object) -> c
    void putAll(com.badlogic.gdx.utils.ObjectMap) -> a
    void putResize(java.lang.Object,java.lang.Object) -> d
    void push(java.lang.Object,java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,java.lang.Object) -> e
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object getStash(java.lang.Object) -> e
    java.lang.Object get(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getStash(java.lang.Object,java.lang.Object) -> f
    java.lang.Object remove(java.lang.Object) -> b
    java.lang.Object removeStash(java.lang.Object) -> c
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsValue(java.lang.Object,boolean) -> a
    boolean containsKey(java.lang.Object) -> d
    boolean containsKeyStash(java.lang.Object) -> f
    java.lang.Object findKey(java.lang.Object,boolean) -> b
    void ensureCapacity(int) -> b
    void resize(int) -> c
    int hash2(int) -> d
    int hash3(int) -> e
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> d
com.badlogic.gdx.utils.ObjectMap$Entries -> com.badlogic.gdx.utils.cc:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectMap$Entry -> com.badlogic.gdx.utils.cd:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectMap$Keys -> com.badlogic.gdx.utils.ce:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$MapIterator -> com.badlogic.gdx.utils.cf:
    boolean hasNext -> b
    com.badlogic.gdx.utils.ObjectMap map -> c
    int nextIndex -> d
    int currentIndex -> e
    boolean valid -> f
    void reset() -> b
    void advance() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectMap$Values -> com.badlogic.gdx.utils.cg:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    void toArray(com.badlogic.gdx.utils.Array) -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.OrderedMap -> com.badlogic.gdx.utils.ch:
    com.badlogic.gdx.utils.Array keys -> f
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    java.lang.Object remove(java.lang.Object) -> b
    void clear() -> a
    com.badlogic.gdx.utils.Array orderedKeys() -> e
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> d
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.OrderedMap$1 -> com.badlogic.gdx.utils.ci:
    com.badlogic.gdx.utils.OrderedMap this$0 -> g
    void advance() -> c
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
com.badlogic.gdx.utils.OrderedMap$2 -> com.badlogic.gdx.utils.cj:
    com.badlogic.gdx.utils.OrderedMap this$0 -> a
    void advance() -> c
    java.lang.Object next() -> next
    void remove() -> remove
com.badlogic.gdx.utils.OrderedMap$3 -> com.badlogic.gdx.utils.ck:
    com.badlogic.gdx.utils.OrderedMap this$0 -> a
    void advance() -> c
    java.lang.Object next() -> next
    void remove() -> remove
com.badlogic.gdx.utils.PauseableThread -> com.badlogic.gdx.utils.cl:
    java.lang.Runnable runnable -> a
    boolean paused -> b
    boolean exit -> c
    void run() -> run
    void onPause() -> a
    void onResume() -> b
    boolean isPaused() -> c
    void stopThread() -> d
com.badlogic.gdx.utils.PerformanceCounter -> com.badlogic.gdx.utils.cm:
    float nano2seconds -> f
    long startTime -> g
    long lastTick -> h
    com.badlogic.gdx.math.FloatCounter time -> a
    com.badlogic.gdx.math.FloatCounter load -> b
    java.lang.String name -> c
    float current -> d
    boolean valid -> e
    void tick() -> a
    void tick(float) -> a
    void start() -> b
    void stop() -> c
    void reset() -> d
    java.lang.String toString() -> toString
    com.badlogic.gdx.utils.StringBuilder toString(com.badlogic.gdx.utils.StringBuilder) -> a
com.badlogic.gdx.utils.PerformanceCounters -> com.badlogic.gdx.utils.cn:
    float nano2seconds -> b
    long lastTick -> c
    com.badlogic.gdx.utils.Array counters -> a
    com.badlogic.gdx.utils.PerformanceCounter add(java.lang.String,int) -> a
    com.badlogic.gdx.utils.PerformanceCounter add(java.lang.String) -> a
    void tick() -> a
    void tick(float) -> a
    com.badlogic.gdx.utils.StringBuilder toString(com.badlogic.gdx.utils.StringBuilder) -> a
com.badlogic.gdx.utils.Pool -> com.badlogic.gdx.utils.co:
    int max -> b
    int peak -> c
    com.badlogic.gdx.utils.Array freeObjects -> a
    java.lang.Object newObject() -> b
    java.lang.Object obtain() -> d
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array) -> a
    void clear() -> e
    int getFree() -> f
com.badlogic.gdx.utils.Pool$Poolable -> com.badlogic.gdx.utils.cp:
    void reset() -> c
com.badlogic.gdx.utils.PooledLinkedList -> com.badlogic.gdx.utils.cq:
    com.badlogic.gdx.utils.PooledLinkedList$Item head -> a
    com.badlogic.gdx.utils.PooledLinkedList$Item tail -> b
    com.badlogic.gdx.utils.PooledLinkedList$Item iter -> c
    com.badlogic.gdx.utils.PooledLinkedList$Item curr -> d
    int size -> e
    com.badlogic.gdx.utils.Pool pool -> f
    void add(java.lang.Object) -> a
    void iter() -> a
    java.lang.Object next() -> b
    void remove() -> c
    void clear() -> d
com.badlogic.gdx.utils.PooledLinkedList$1 -> com.badlogic.gdx.utils.cr:
    com.badlogic.gdx.utils.PooledLinkedList this$0 -> a
    com.badlogic.gdx.utils.PooledLinkedList$Item newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.utils.PooledLinkedList$Item -> com.badlogic.gdx.utils.cs:
    java.lang.Object payload -> a
    com.badlogic.gdx.utils.PooledLinkedList$Item next -> b
    com.badlogic.gdx.utils.PooledLinkedList$Item prev -> c
com.badlogic.gdx.utils.Pools -> com.badlogic.gdx.utils.ct:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> a
    java.lang.Object obtain(java.lang.Class) -> b
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array) -> a
com.badlogic.gdx.utils.Predicate -> com.badlogic.gdx.utils.cu:
    boolean evaluate(java.lang.Object) -> a
com.badlogic.gdx.utils.Predicate$PredicateIterable -> com.badlogic.gdx.utils.cv:
    java.lang.Iterable iterable -> a
    com.badlogic.gdx.utils.Predicate predicate -> b
    com.badlogic.gdx.utils.Predicate$PredicateIterator iterator -> c
    void set(java.lang.Iterable,com.badlogic.gdx.utils.Predicate) -> a
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.Predicate$PredicateIterator -> com.badlogic.gdx.utils.cw:
    java.util.Iterator iterator -> a
    com.badlogic.gdx.utils.Predicate predicate -> b
    boolean end -> c
    boolean peeked -> d
    java.lang.Object next -> e
    void set(java.lang.Iterable,com.badlogic.gdx.utils.Predicate) -> a
    void set(java.util.Iterator,com.badlogic.gdx.utils.Predicate) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.badlogic.gdx.utils.ReflectionPool -> com.badlogic.gdx.utils.cx:
    java.lang.Class type -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.utils.Scaling -> com.badlogic.gdx.utils.cy:
    com.badlogic.gdx.utils.Scaling fit -> a
    com.badlogic.gdx.utils.Scaling fill -> b
    com.badlogic.gdx.utils.Scaling fillX -> c
    com.badlogic.gdx.utils.Scaling fillY -> d
    com.badlogic.gdx.utils.Scaling stretch -> e
    com.badlogic.gdx.utils.Scaling stretchX -> f
    com.badlogic.gdx.utils.Scaling stretchY -> g
    com.badlogic.gdx.utils.Scaling none -> h
    com.badlogic.gdx.math.Vector2 temp -> i
    com.badlogic.gdx.utils.Scaling[] $VALUES -> j
    com.badlogic.gdx.utils.Scaling[] values() -> values
    com.badlogic.gdx.utils.Scaling valueOf(java.lang.String) -> valueOf
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> com.badlogic.gdx.utils.cz:
    int[] $SwitchMap$com$badlogic$gdx$utils$Scaling -> a
com.badlogic.gdx.utils.ScreenUtils -> com.badlogic.gdx.utils.da:
    com.badlogic.gdx.graphics.g2d.TextureRegion getFrameBufferTexture() -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getFrameBufferTexture(int,int,int,int) -> a
    byte[] getFrameBufferPixels(boolean) -> a
    byte[] getFrameBufferPixels(int,int,int,int,boolean) -> a
com.badlogic.gdx.utils.SerializationException -> com.badlogic.gdx.utils.db:
    java.lang.StringBuffer trace -> a
    boolean causedBy(java.lang.Class) -> a
    boolean causedBy(java.lang.Throwable,java.lang.Class) -> a
    java.lang.String getMessage() -> getMessage
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoader -> com.badlogic.gdx.utils.dc:
    boolean isWindows -> a
    boolean isLinux -> b
    boolean isMac -> c
    boolean isIos -> d
    boolean isAndroid -> e
    boolean is64Bit -> f
    java.util.HashSet loadedLibraries -> g
    java.lang.String nativesJar -> h
    java.lang.String crc(java.io.InputStream) -> a
    java.lang.String mapLibraryName(java.lang.String) -> a
    void load(java.lang.String) -> b
    java.io.InputStream readFile(java.lang.String) -> c
    java.io.File extractFile(java.lang.String,java.lang.String) -> a
com.badlogic.gdx.utils.ShortArray -> com.badlogic.gdx.utils.dd:
    short[] items -> a
    int size -> b
    boolean ordered -> c
    void add(short) -> a
    void addAll(com.badlogic.gdx.utils.ShortArray) -> a
    void addAll(com.badlogic.gdx.utils.ShortArray,int,int) -> a
    void addAll(short[]) -> a
    void addAll(short[],int,int) -> a
    short get(int) -> a
    void set(int,short) -> a
    void insert(int,short) -> b
    void swap(int,int) -> a
    boolean contains(short) -> b
    int indexOf(short) -> c
    int lastIndexOf(char) -> a
    boolean removeValue(short) -> d
    short removeIndex(int) -> b
    boolean removeAll(com.badlogic.gdx.utils.ShortArray) -> b
    short pop() -> a
    short peek() -> b
    short first() -> c
    void clear() -> d
    void shrink() -> e
    short[] ensureCapacity(int) -> c
    short[] resize(int) -> d
    void sort() -> f
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
    short random() -> i
    short[] toArray() -> j
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
com.badlogic.gdx.utils.SnapshotArray -> com.badlogic.gdx.utils.de:
    java.lang.Object[] snapshot -> d
    java.lang.Object[] recycled -> e
    int snapshots -> f
    java.lang.Object[] begin() -> k
    void end() -> l
    void modified() -> m
    void set(int,java.lang.Object) -> a
    void insert(int,java.lang.Object) -> b
    void swap(int,int) -> a
    boolean removeValue(java.lang.Object,boolean) -> d
    java.lang.Object removeIndex(int) -> b
    java.lang.Object pop() -> a
    void clear() -> d
    void sort() -> f
    void sort(java.util.Comparator) -> a
    void reverse() -> g
    void shuffle() -> h
    void truncate(int) -> e
com.badlogic.gdx.utils.Sort -> com.badlogic.gdx.utils.df:
    com.badlogic.gdx.utils.Sort instance -> a
    com.badlogic.gdx.utils.TimSort timSort -> b
    com.badlogic.gdx.utils.ComparableTimSort comparableTimSort -> c
    void sort(com.badlogic.gdx.utils.Array) -> a
    void sort(java.lang.Object[]) -> a
    void sort(java.lang.Object[],int,int) -> a
    void sort(com.badlogic.gdx.utils.Array,java.util.Comparator) -> a
    void sort(java.lang.Object[],java.util.Comparator) -> a
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> a
    com.badlogic.gdx.utils.Sort instance() -> a
com.badlogic.gdx.utils.SortedIntList -> com.badlogic.gdx.utils.dg:
    com.badlogic.gdx.utils.SortedIntList$NodePool nodePool -> c
    com.badlogic.gdx.utils.SortedIntList$Iterator iterator -> d
    int size -> a
    com.badlogic.gdx.utils.SortedIntList$Node first -> b
    java.lang.Object insert(int,java.lang.Object) -> a
    java.lang.Object get(int) -> a
    void clear() -> a
    int size() -> b
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.SortedIntList$Iterator -> com.badlogic.gdx.utils.dh:
    com.badlogic.gdx.utils.SortedIntList$Node position -> b
    com.badlogic.gdx.utils.SortedIntList$Node previousPosition -> c
    com.badlogic.gdx.utils.SortedIntList this$0 -> a
    boolean hasNext() -> hasNext
    com.badlogic.gdx.utils.SortedIntList$Node next() -> a
    void remove() -> remove
    com.badlogic.gdx.utils.SortedIntList$Iterator reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.SortedIntList$Node -> com.badlogic.gdx.utils.di:
    com.badlogic.gdx.utils.SortedIntList$Node p -> a
    com.badlogic.gdx.utils.SortedIntList$Node n -> b
    java.lang.Object value -> c
    int index -> d
com.badlogic.gdx.utils.SortedIntList$NodePool -> com.badlogic.gdx.utils.dj:
    com.badlogic.gdx.utils.SortedIntList$Node newObject() -> a
    com.badlogic.gdx.utils.SortedIntList$Node obtain(com.badlogic.gdx.utils.SortedIntList$Node,com.badlogic.gdx.utils.SortedIntList$Node,java.lang.Object,int) -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.utils.StreamUtils -> com.badlogic.gdx.utils.dk:
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream,int) -> a
com.badlogic.gdx.utils.StringBuilder -> com.badlogic.gdx.utils.dl:
    int INITIAL_CAPACITY -> a
    char[] chars -> b
    int length -> c
    char[] digits -> d
    char[] getValue() -> a
    void enlargeBuffer(int) -> j
    void appendNull() -> b
    void append0(char[]) -> a
    void append0(char[],int,int) -> a
    void append0(char) -> a
    void append0(java.lang.String) -> a
    void append0(java.lang.CharSequence,int,int) -> a
    int capacity() -> c
    char charAt(int) -> charAt
    void delete0(int,int) -> a
    void deleteCharAt0(int) -> a
    void ensureCapacity(int) -> b
    void getChars(int,int,char[],int) -> a
    void insert0(int,char[]) -> a
    void insert0(int,char[],int,int) -> a
    void insert0(int,char) -> a
    void insert0(int,java.lang.String) -> a
    void insert0(int,java.lang.CharSequence,int,int) -> a
    int length() -> length
    void move(int,int) -> g
    void replace0(int,int,java.lang.String) -> a
    void reverse0() -> d
    void setCharAt(int,char) -> b
    void setLength(int) -> c
    java.lang.String substring(int) -> d
    java.lang.String substring(int,int) -> b
    java.lang.String toString() -> toString
    java.lang.CharSequence subSequence(int,int) -> subSequence
    int indexOf(java.lang.String) -> b
    int indexOf(java.lang.String,int) -> a
    int lastIndexOf(java.lang.String) -> c
    int lastIndexOf(java.lang.String,int) -> b
    void trimToSize() -> e
    int codePointAt(int) -> e
    int codePointBefore(int) -> f
    int codePointCount(int,int) -> c
    int offsetByCodePoints(int,int) -> d
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> a
    com.badlogic.gdx.utils.StringBuilder append(char) -> b
    com.badlogic.gdx.utils.StringBuilder append(int) -> g
    com.badlogic.gdx.utils.StringBuilder append(long) -> a
    com.badlogic.gdx.utils.StringBuilder append(float) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> d
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> b
    com.badlogic.gdx.utils.StringBuilder append(char[],int,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> a
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder,int,int) -> a
    com.badlogic.gdx.utils.StringBuilder appendCodePoint(int) -> h
    com.badlogic.gdx.utils.StringBuilder delete(int,int) -> e
    com.badlogic.gdx.utils.StringBuilder deleteCharAt(int) -> i
    com.badlogic.gdx.utils.StringBuilder insert(int,boolean) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,char) -> c
    com.badlogic.gdx.utils.StringBuilder insert(int,int) -> f
    com.badlogic.gdx.utils.StringBuilder insert(int,long) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,float) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,double) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,java.lang.Object) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,java.lang.String) -> b
    com.badlogic.gdx.utils.StringBuilder insert(int,char[]) -> b
    com.badlogic.gdx.utils.StringBuilder insert(int,char[],int,int) -> b
    com.badlogic.gdx.utils.StringBuilder insert(int,java.lang.CharSequence) -> a
    com.badlogic.gdx.utils.StringBuilder insert(int,java.lang.CharSequence,int,int) -> b
    com.badlogic.gdx.utils.StringBuilder replace(int,int,java.lang.String) -> b
    com.badlogic.gdx.utils.StringBuilder reverse() -> f
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
com.badlogic.gdx.utils.TimSort -> com.badlogic.gdx.utils.dm:
    int MIN_MERGE -> a
    java.lang.Object[] a -> b
    java.util.Comparator c -> c
    int MIN_GALLOP -> d
    int minGallop -> e
    int INITIAL_TMP_STORAGE_LENGTH -> f
    java.lang.Object[] tmp -> g
    int tmpCount -> h
    int stackSize -> i
    int[] runBase -> j
    int[] runLen -> k
    boolean DEBUG -> l
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> a
    void sort(java.lang.Object[],java.util.Comparator) -> a
    void sort(java.lang.Object[],int,int,java.util.Comparator) -> a
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> b
    void reverseRange(java.lang.Object[],int,int) -> a
    int minRunLength(int) -> a
    void pushRun(int,int) -> a
    void mergeCollapse() -> a
    void mergeForceCollapse() -> b
    void mergeAt(int) -> b
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> b
    void mergeLo(int,int,int,int) -> a
    void mergeHi(int,int,int,int) -> b
    java.lang.Object[] ensureCapacity(int) -> c
    void rangeCheck(int,int,int) -> a
com.badlogic.gdx.utils.TimeUtils -> com.badlogic.gdx.utils.dn:
    long nanoTime() -> a
    long millis() -> b
com.badlogic.gdx.utils.Timer -> com.badlogic.gdx.utils.do:
    com.badlogic.gdx.utils.Array instances -> a
    com.badlogic.gdx.utils.Timer instance -> b
    int CANCELLED -> c
    int FOREVER -> d
    com.badlogic.gdx.utils.Array tasks -> e
    void postTask(com.badlogic.gdx.utils.Timer$Task) -> a
    void scheduleTask(com.badlogic.gdx.utils.Timer$Task,float) -> a
    void scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float) -> a
    void scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> a
    void stop() -> a
    void start() -> b
    void clear() -> c
    long update(long,long) -> a
    void wake() -> d
    void post(com.badlogic.gdx.utils.Timer$Task) -> b
    void schedule(com.badlogic.gdx.utils.Timer$Task,float) -> b
    void schedule(com.badlogic.gdx.utils.Timer$Task,float,float) -> b
    void schedule(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> b
com.badlogic.gdx.utils.Timer$1 -> com.badlogic.gdx.utils.dp:
    void run() -> run
com.badlogic.gdx.utils.Timer$Task -> com.badlogic.gdx.utils.dq:
    long executeTimeMillis -> c
    long intervalMillis -> d
    int repeatCount -> e
    void run() -> run
    void cancel() -> a
    boolean isScheduled() -> b
com.badlogic.gdx.utils.XmlReader -> com.badlogic.gdx.utils.dr:
    com.badlogic.gdx.utils.Array elements -> f
    com.badlogic.gdx.utils.XmlReader$Element root -> g
    com.badlogic.gdx.utils.XmlReader$Element current -> h
    com.badlogic.gdx.utils.StringBuilder textBuffer -> i
    byte[] _xml_actions -> j
    byte[] _xml_key_offsets -> k
    char[] _xml_trans_keys -> l
    byte[] _xml_single_lengths -> m
    byte[] _xml_range_lengths -> n
    short[] _xml_index_offsets -> o
    byte[] _xml_indicies -> p
    byte[] _xml_trans_targs -> q
    byte[] _xml_trans_actions -> r
    int xml_start -> a
    int xml_first_final -> b
    int xml_error -> c
    int xml_en_elementBody -> d
    int xml_en_main -> e
    com.badlogic.gdx.utils.XmlReader$Element parse(java.lang.String) -> a
    com.badlogic.gdx.utils.XmlReader$Element parse(java.io.Reader) -> a
    com.badlogic.gdx.utils.XmlReader$Element parse(java.io.InputStream) -> a
    com.badlogic.gdx.utils.XmlReader$Element parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.XmlReader$Element parse(char[],int,int) -> a
    byte[] init__xml_actions_0() -> b
    byte[] init__xml_key_offsets_0() -> c
    char[] init__xml_trans_keys_0() -> d
    byte[] init__xml_single_lengths_0() -> e
    byte[] init__xml_range_lengths_0() -> f
    short[] init__xml_index_offsets_0() -> g
    byte[] init__xml_indicies_0() -> h
    byte[] init__xml_trans_targs_0() -> i
    byte[] init__xml_trans_actions_0() -> j
    void open(java.lang.String) -> b
    void attribute(java.lang.String,java.lang.String) -> a
    java.lang.String entity(java.lang.String) -> c
    void text(java.lang.String) -> d
    void close() -> a
com.badlogic.gdx.utils.XmlReader$Element -> com.badlogic.gdx.utils.ds:
    java.lang.String name -> a
    com.badlogic.gdx.utils.ObjectMap attributes -> b
    com.badlogic.gdx.utils.Array children -> c
    java.lang.String text -> d
    com.badlogic.gdx.utils.XmlReader$Element parent -> e
    java.lang.String getName() -> a
    com.badlogic.gdx.utils.ObjectMap getAttributes() -> b
    java.lang.String getAttribute(java.lang.String) -> a
    java.lang.String getAttribute(java.lang.String,java.lang.String) -> a
    void setAttribute(java.lang.String,java.lang.String) -> b
    int getChildCount() -> c
    com.badlogic.gdx.utils.XmlReader$Element getChild(int) -> a
    void addChild(com.badlogic.gdx.utils.XmlReader$Element) -> a
    java.lang.String getText() -> d
    void setText(java.lang.String) -> b
    void removeChild(int) -> b
    void removeChild(com.badlogic.gdx.utils.XmlReader$Element) -> b
    void remove() -> e
    com.badlogic.gdx.utils.XmlReader$Element getParent() -> f
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> c
    com.badlogic.gdx.utils.XmlReader$Element getChildByName(java.lang.String) -> d
    com.badlogic.gdx.utils.XmlReader$Element getChildByNameRecursive(java.lang.String) -> e
    com.badlogic.gdx.utils.Array getChildrenByName(java.lang.String) -> f
    com.badlogic.gdx.utils.Array getChildrenByNameRecursively(java.lang.String) -> g
    void getChildrenByNameRecursively(java.lang.String,com.badlogic.gdx.utils.Array) -> a
    float getFloatAttribute(java.lang.String) -> h
    float getFloatAttribute(java.lang.String,float) -> a
    int getIntAttribute(java.lang.String) -> i
    int getIntAttribute(java.lang.String,int) -> a
    boolean getBooleanAttribute(java.lang.String) -> j
    boolean getBooleanAttribute(java.lang.String,boolean) -> a
    java.lang.String get(java.lang.String) -> k
    java.lang.String get(java.lang.String,java.lang.String) -> c
    int getInt(java.lang.String) -> l
    int getInt(java.lang.String,int) -> b
    float getFloat(java.lang.String) -> m
    float getFloat(java.lang.String,float) -> b
    boolean getBoolean(java.lang.String) -> n
    boolean getBoolean(java.lang.String,boolean) -> b
com.badlogic.gdx.utils.XmlWriter -> com.badlogic.gdx.utils.dt:
    java.io.Writer writer -> b
    com.badlogic.gdx.utils.Array stack -> c
    java.lang.String currentElement -> d
    boolean indentNextClose -> e
    int indent -> a
    void indent() -> b
    com.badlogic.gdx.utils.XmlWriter element(java.lang.String) -> a
    com.badlogic.gdx.utils.XmlWriter element(java.lang.String,java.lang.Object) -> a
    boolean startElementContent() -> c
    com.badlogic.gdx.utils.XmlWriter attribute(java.lang.String,java.lang.Object) -> b
    com.badlogic.gdx.utils.XmlWriter text(java.lang.Object) -> a
    com.badlogic.gdx.utils.XmlWriter pop() -> a
    void close() -> close
    void write(char[],int,int) -> write
    void flush() -> flush
com.badlogic.gdx.utils.compression.CRC -> com.badlogic.gdx.utils.a.a:
    int[] Table -> a
    int _value -> b
    void Init() -> a
    void Update(byte[],int,int) -> a
    void Update(byte[]) -> a
    void UpdateByte(int) -> a
    int GetDigest() -> b
com.badlogic.gdx.utils.compression.ICodeProgress -> com.badlogic.gdx.utils.a.b:
    void SetProgress(long,long) -> a
com.badlogic.gdx.utils.compression.Lzma -> com.badlogic.gdx.utils.a.c:
    void compress(java.io.InputStream,java.io.OutputStream) -> a
    void decompress(java.io.InputStream,java.io.OutputStream) -> b
com.badlogic.gdx.utils.compression.Lzma$CommandLine -> com.badlogic.gdx.utils.a.d:
    int kEncode -> a
    int kDecode -> b
    int kBenchmak -> c
    int Command -> d
    int NumBenchmarkPasses -> e
    int DictionarySize -> f
    boolean DictionarySizeIsDefined -> g
    int Lc -> h
    int Lp -> i
    int Pb -> j
    int Fb -> k
    boolean FbIsDefined -> l
    boolean Eos -> m
    int Algorithm -> n
    int MatchFinder -> o
    java.lang.String InFile -> p
    java.lang.String OutFile -> q
com.badlogic.gdx.utils.compression.lz.BinTree -> com.badlogic.gdx.utils.a.a.a:
    int _cyclicBufferPos -> a
    int _cyclicBufferSize -> b
    int _matchMaxLen -> c
    int[] _son -> d
    int[] _hash -> e
    int _cutValue -> f
    int _hashMask -> g
    int _hashSizeSum -> h
    boolean HASH_ARRAY -> i
    int kHash2Size -> j
    int kHash3Size -> k
    int kBT2HashSize -> l
    int kStartMaxLen -> m
    int kHash3Offset -> n
    int kEmptyHashValue -> o
    int kMaxValForNormalize -> p
    int kNumHashDirectBytes -> q
    int kMinMatchCheck -> r
    int kFixHashSize -> s
    int[] CrcTable -> E
    void SetType(int) -> a
    void Init() -> a
    void MovePos() -> b
    boolean Create(int,int,int,int) -> a
    int GetMatches(int[]) -> a
    void Skip(int) -> b
    void NormalizeLinks(int[],int,int) -> a
    void Normalize() -> c
    void SetCutValue(int) -> c
com.badlogic.gdx.utils.compression.lz.InWindow -> com.badlogic.gdx.utils.a.a.b:
    byte[] _bufferBase -> t
    java.io.InputStream _stream -> u
    int _posLimit -> v
    boolean _streamEndWasReached -> w
    int _pointerToLastSafePosition -> x
    int _bufferOffset -> y
    int _blockSize -> z
    int _pos -> A
    int _keepSizeBefore -> B
    int _keepSizeAfter -> C
    int _streamPos -> D
    void MoveBlock() -> d
    void ReadBlock() -> e
    void Free() -> f
    void Create(int,int,int) -> a
    void SetStream(java.io.InputStream) -> a
    void ReleaseStream() -> g
    void Init() -> a
    void MovePos() -> b
    byte GetIndexByte(int) -> d
    int GetMatchLen(int,int,int) -> b
    int GetNumAvailableBytes() -> h
    void ReduceOffsets(int) -> e
com.badlogic.gdx.utils.compression.lz.OutWindow -> com.badlogic.gdx.utils.a.a.c:
    byte[] _buffer -> a
    int _pos -> b
    int _windowSize -> c
    int _streamPos -> d
    java.io.OutputStream _stream -> e
    void Create(int) -> a
    void SetStream(java.io.OutputStream) -> a
    void ReleaseStream() -> a
    void Init(boolean) -> a
    void Flush() -> b
    void CopyBlock(int,int) -> a
    void PutByte(byte) -> a
    byte GetByte(int) -> b
com.badlogic.gdx.utils.compression.lzma.Base -> com.badlogic.gdx.utils.a.b.a:
    int kNumRepDistances -> a
    int kNumStates -> b
    int kNumPosSlotBits -> c
    int kDicLogSizeMin -> d
    int kNumLenToPosStatesBits -> e
    int kNumLenToPosStates -> f
    int kMatchMinLen -> g
    int kNumAlignBits -> h
    int kAlignTableSize -> i
    int kAlignMask -> j
    int kStartPosModelIndex -> k
    int kEndPosModelIndex -> l
    int kNumPosModels -> m
    int kNumFullDistances -> n
    int kNumLitPosStatesBitsEncodingMax -> o
    int kNumLitContextBitsMax -> p
    int kNumPosStatesBitsMax -> q
    int kNumPosStatesMax -> r
    int kNumPosStatesBitsEncodingMax -> s
    int kNumPosStatesEncodingMax -> t
    int kNumLowLenBits -> u
    int kNumMidLenBits -> v
    int kNumHighLenBits -> w
    int kNumLowLenSymbols -> x
    int kNumMidLenSymbols -> y
    int kNumLenSymbols -> z
    int kMatchMaxLen -> A
    int StateInit() -> a
    int StateUpdateChar(int) -> a
    int StateUpdateMatch(int) -> b
    int StateUpdateRep(int) -> c
    int StateUpdateShortRep(int) -> d
    boolean StateIsCharState(int) -> e
    int GetLenToPosState(int) -> f
com.badlogic.gdx.utils.compression.lzma.Decoder -> com.badlogic.gdx.utils.a.b.b:
    com.badlogic.gdx.utils.compression.lz.OutWindow m_OutWindow -> a
    com.badlogic.gdx.utils.compression.rangecoder.Decoder m_RangeDecoder -> b
    short[] m_IsMatchDecoders -> c
    short[] m_IsRepDecoders -> d
    short[] m_IsRepG0Decoders -> e
    short[] m_IsRepG1Decoders -> f
    short[] m_IsRepG2Decoders -> g
    short[] m_IsRep0LongDecoders -> h
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder[] m_PosSlotDecoder -> i
    short[] m_PosDecoders -> j
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder m_PosAlignDecoder -> k
    com.badlogic.gdx.utils.compression.lzma.Decoder$LenDecoder m_LenDecoder -> l
    com.badlogic.gdx.utils.compression.lzma.Decoder$LenDecoder m_RepLenDecoder -> m
    com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder m_LiteralDecoder -> n
    int m_DictionarySize -> o
    int m_DictionarySizeCheck -> p
    int m_PosStateMask -> q
    boolean SetDictionarySize(int) -> a
    boolean SetLcLpPb(int,int,int) -> a
    void Init() -> a
    boolean Code(java.io.InputStream,java.io.OutputStream,long) -> a
    boolean SetDecoderProperties(byte[]) -> a
com.badlogic.gdx.utils.compression.lzma.Decoder$LenDecoder -> com.badlogic.gdx.utils.a.b.c:
    short[] m_Choice -> a
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder[] m_LowCoder -> b
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder[] m_MidCoder -> c
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder m_HighCoder -> d
    int m_NumPosStates -> e
    com.badlogic.gdx.utils.compression.lzma.Decoder this$0 -> f
    void Create(int) -> a
    void Init() -> a
    int Decode(com.badlogic.gdx.utils.compression.rangecoder.Decoder,int) -> a
com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder -> com.badlogic.gdx.utils.a.b.d:
    com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder$Decoder2[] m_Coders -> a
    int m_NumPrevBits -> b
    int m_NumPosBits -> c
    int m_PosMask -> d
    com.badlogic.gdx.utils.compression.lzma.Decoder this$0 -> e
    void Create(int,int) -> a
    void Init() -> a
    com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder$Decoder2 GetDecoder(int,byte) -> a
com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder$Decoder2 -> com.badlogic.gdx.utils.a.b.e:
    short[] m_Decoders -> a
    com.badlogic.gdx.utils.compression.lzma.Decoder$LiteralDecoder this$1 -> b
    void Init() -> a
    byte DecodeNormal(com.badlogic.gdx.utils.compression.rangecoder.Decoder) -> a
    byte DecodeWithMatchByte(com.badlogic.gdx.utils.compression.rangecoder.Decoder,byte) -> a
com.badlogic.gdx.utils.compression.lzma.Encoder -> com.badlogic.gdx.utils.a.b.f:
    int EMatchFinderTypeBT2 -> a
    int EMatchFinderTypeBT4 -> b
    int kIfinityPrice -> c
    byte[] g_FastPos -> d
    int _state -> e
    byte _previousByte -> f
    int[] _repDistances -> g
    int kDefaultDictionaryLogSize -> h
    int kNumFastBytesDefault -> i
    int kNumLenSpecSymbols -> j
    int kNumOpts -> k
    com.badlogic.gdx.utils.compression.lzma.Encoder$Optimal[] _optimum -> l
    com.badlogic.gdx.utils.compression.lz.BinTree _matchFinder -> m
    com.badlogic.gdx.utils.compression.rangecoder.Encoder _rangeEncoder -> n
    short[] _isMatch -> o
    short[] _isRep -> p
    short[] _isRepG0 -> q
    short[] _isRepG1 -> r
    short[] _isRepG2 -> s
    short[] _isRep0Long -> t
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder[] _posSlotEncoder -> u
    short[] _posEncoders -> v
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder _posAlignEncoder -> w
    com.badlogic.gdx.utils.compression.lzma.Encoder$LenPriceTableEncoder _lenEncoder -> x
    com.badlogic.gdx.utils.compression.lzma.Encoder$LenPriceTableEncoder _repMatchLenEncoder -> y
    com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder _literalEncoder -> z
    int[] _matchDistances -> A
    int _numFastBytes -> B
    int _longestMatchLength -> C
    int _numDistancePairs -> D
    int _additionalOffset -> E
    int _optimumEndIndex -> F
    int _optimumCurrentIndex -> G
    boolean _longestMatchWasFound -> H
    int[] _posSlotPrices -> I
    int[] _distancesPrices -> J
    int[] _alignPrices -> K
    int _alignPriceCount -> L
    int _distTableSize -> M
    int _posStateBits -> N
    int _posStateMask -> O
    int _numLiteralPosStateBits -> P
    int _numLiteralContextBits -> Q
    int _dictionarySize -> R
    int _dictionarySizePrev -> S
    int _numFastBytesPrev -> T
    long nowPos64 -> U
    boolean _finished -> V
    java.io.InputStream _inStream -> W
    int _matchFinderType -> X
    boolean _writeEndMark -> Y
    boolean _needReleaseMFStream -> Z
    int[] reps -> aa
    int[] repLens -> ab
    int backRes -> ac
    long[] processedInSize -> ad
    long[] processedOutSize -> ae
    boolean[] finished -> af
    int kPropSize -> ag
    byte[] properties -> ah
    int[] tempPrices -> ai
    int _matchPriceCount -> aj
    int GetPosSlot(int) -> a
    int GetPosSlot2(int) -> b
    void BaseInit() -> a
    void Create() -> b
    void SetWriteEndMarkerMode(boolean) -> a
    void Init() -> c
    int ReadMatchDistances() -> d
    void MovePos(int) -> c
    int GetRepLen1Price(int,int) -> a
    int GetPureRepPrice(int,int,int) -> a
    int GetRepPrice(int,int,int,int) -> a
    int GetPosLenPrice(int,int,int) -> b
    int Backward(int) -> d
    int GetOptimum(int) -> e
    boolean ChangePair(int,int) -> b
    void WriteEndMarker(int) -> f
    void Flush(int) -> g
    void CodeOneBlock(long[],long[],boolean[]) -> a
    void ReleaseMFStream() -> e
    void SetOutStream(java.io.OutputStream) -> a
    void ReleaseOutStream() -> f
    void ReleaseStreams() -> g
    void SetStreams(java.io.InputStream,java.io.OutputStream,long,long) -> a
    void Code(java.io.InputStream,java.io.OutputStream,long,long,com.badlogic.gdx.utils.compression.ICodeProgress) -> a
    void WriteCoderProperties(java.io.OutputStream) -> b
    void FillDistancesPrices() -> h
    void FillAlignPrices() -> i
    boolean SetAlgorithm(int) -> h
    boolean SetDictionarySize(int) -> i
    boolean SetNumFastBytes(int) -> j
    boolean SetMatchFinder(int) -> k
    boolean SetLcLpPb(int,int,int) -> c
    void SetEndMarkerMode(boolean) -> b
com.badlogic.gdx.utils.compression.lzma.Encoder$LenEncoder -> com.badlogic.gdx.utils.a.b.g:
    short[] _choice -> a
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder[] _lowCoder -> b
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder[] _midCoder -> c
    com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder _highCoder -> d
    com.badlogic.gdx.utils.compression.lzma.Encoder this$0 -> e
    void Init(int) -> a
    void Encode(com.badlogic.gdx.utils.compression.rangecoder.Encoder,int,int) -> a
    void SetPrices(int,int,int[],int) -> a
com.badlogic.gdx.utils.compression.lzma.Encoder$LenPriceTableEncoder -> com.badlogic.gdx.utils.a.b.h:
    int[] _prices -> f
    int _tableSize -> g
    int[] _counters -> h
    com.badlogic.gdx.utils.compression.lzma.Encoder this$0 -> i
    void SetTableSize(int) -> b
    int GetPrice(int,int) -> a
    void UpdateTable(int) -> c
    void UpdateTables(int) -> d
    void Encode(com.badlogic.gdx.utils.compression.rangecoder.Encoder,int,int) -> a
com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder -> com.badlogic.gdx.utils.a.b.i:
    com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder$Encoder2[] m_Coders -> a
    int m_NumPrevBits -> b
    int m_NumPosBits -> c
    int m_PosMask -> d
    com.badlogic.gdx.utils.compression.lzma.Encoder this$0 -> e
    void Create(int,int) -> a
    void Init() -> a
    com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder$Encoder2 GetSubCoder(int,byte) -> a
com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder$Encoder2 -> com.badlogic.gdx.utils.a.b.j:
    short[] m_Encoders -> a
    com.badlogic.gdx.utils.compression.lzma.Encoder$LiteralEncoder this$1 -> b
    void Init() -> a
    void Encode(com.badlogic.gdx.utils.compression.rangecoder.Encoder,byte) -> a
    void EncodeMatched(com.badlogic.gdx.utils.compression.rangecoder.Encoder,byte,byte) -> a
    int GetPrice(boolean,byte,byte) -> a
com.badlogic.gdx.utils.compression.lzma.Encoder$Optimal -> com.badlogic.gdx.utils.a.b.k:
    int State -> a
    boolean Prev1IsChar -> b
    boolean Prev2 -> c
    int PosPrev2 -> d
    int BackPrev2 -> e
    int Price -> f
    int PosPrev -> g
    int BackPrev -> h
    int Backs0 -> i
    int Backs1 -> j
    int Backs2 -> k
    int Backs3 -> l
    com.badlogic.gdx.utils.compression.lzma.Encoder this$0 -> m
    void MakeAsChar() -> a
    void MakeAsShortRep() -> b
    boolean IsShortRep() -> c
com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder -> com.badlogic.gdx.utils.a.c.a:
    short[] Models -> a
    int NumBitLevels -> b
    void Init() -> a
    int Decode(com.badlogic.gdx.utils.compression.rangecoder.Decoder) -> a
    int ReverseDecode(com.badlogic.gdx.utils.compression.rangecoder.Decoder) -> b
    int ReverseDecode(short[],int,com.badlogic.gdx.utils.compression.rangecoder.Decoder,int) -> a
com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder -> com.badlogic.gdx.utils.a.c.b:
    short[] Models -> a
    int NumBitLevels -> b
    void Init() -> a
    void Encode(com.badlogic.gdx.utils.compression.rangecoder.Encoder,int) -> a
    void ReverseEncode(com.badlogic.gdx.utils.compression.rangecoder.Encoder,int) -> b
    int GetPrice(int) -> a
    int ReverseGetPrice(int) -> b
    int ReverseGetPrice(short[],int,int,int) -> a
    void ReverseEncode(short[],int,com.badlogic.gdx.utils.compression.rangecoder.Encoder,int,int) -> a
com.badlogic.gdx.utils.compression.rangecoder.Decoder -> com.badlogic.gdx.utils.a.c.c:
    int kTopMask -> a
    int kNumBitModelTotalBits -> b
    int kBitModelTotal -> c
    int kNumMoveBits -> d
    int Range -> e
    int Code -> f
    java.io.InputStream Stream -> g
    void SetStream(java.io.InputStream) -> a
    void ReleaseStream() -> a
    void Init() -> b
    int DecodeDirectBits(int) -> a
    int DecodeBit(short[],int) -> a
    void InitBitModels(short[]) -> a
com.badlogic.gdx.utils.compression.rangecoder.Encoder -> com.badlogic.gdx.utils.a.c.d:
    int kTopMask -> a
    int kNumBitModelTotalBits -> b
    int kBitModelTotal -> c
    int kNumMoveBits -> d
    java.io.OutputStream Stream -> e
    long Low -> f
    int Range -> g
    int _cacheSize -> h
    int _cache -> i
    long _position -> j
    int kNumMoveReducingBits -> k
    int kNumBitPriceShiftBits -> l
    int[] ProbPrices -> m
    void SetStream(java.io.OutputStream) -> a
    void ReleaseStream() -> a
    void Init() -> b
    void FlushData() -> c
    void FlushStream() -> d
    void ShiftLow() -> e
    void EncodeDirectBits(int,int) -> a
    long GetProcessedSizeAdd() -> f
    void InitBitModels(short[]) -> a
    void Encode(short[],int,int) -> a
    int GetPrice(int,int) -> b
    int GetPrice0(int) -> a
    int GetPrice1(int) -> b
com.esotericsoftware.tablelayout.BaseTableLayout -> com.a.a.a:
    int CENTER -> c
    int TOP -> d
    int BOTTOM -> e
    int LEFT -> f
    int RIGHT -> g
    com.esotericsoftware.tablelayout.Toolkit toolkit -> h
    java.lang.Object table -> i
    int columns -> a
    int rows -> b
    java.util.ArrayList cells -> p
    com.esotericsoftware.tablelayout.Cell cellDefaults -> q
    java.util.ArrayList columnDefaults -> r
    com.esotericsoftware.tablelayout.Cell rowDefaults -> s
    boolean sizeInvalid -> t
    float[] columnMinWidth -> u
    float[] rowMinHeight -> v
    float[] columnPrefWidth -> w
    float[] rowPrefHeight -> x
    float tableMinWidth -> y
    float tableMinHeight -> z
    float tablePrefWidth -> A
    float tablePrefHeight -> B
    float[] columnWidth -> C
    float[] rowHeight -> D
    float[] expandWidth -> E
    float[] expandHeight -> F
    float[] columnWeightedWidth -> G
    float[] rowWeightedHeight -> H
    com.esotericsoftware.tablelayout.Value padTop -> j
    com.esotericsoftware.tablelayout.Value padLeft -> k
    com.esotericsoftware.tablelayout.Value padBottom -> l
    com.esotericsoftware.tablelayout.Value padRight -> m
    int align -> n
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug debug -> o
    void invalidate() -> c
    void invalidateHierarchy() -> b
    com.esotericsoftware.tablelayout.Cell add(java.lang.Object) -> a
    com.esotericsoftware.tablelayout.Cell row() -> d
    void endRow() -> a
    com.esotericsoftware.tablelayout.Cell columnDefaults(int) -> a
    void reset() -> e
    void clear() -> f
    com.esotericsoftware.tablelayout.Cell getCell(java.lang.Object) -> b
    java.util.List getCells() -> g
    void setToolkit(com.esotericsoftware.tablelayout.Toolkit) -> a
    java.lang.Object getTable() -> h
    void setTable(java.lang.Object) -> c
    float getMinWidth() -> i
    float getMinHeight() -> j
    float getPrefWidth() -> k
    float getPrefHeight() -> l
    com.esotericsoftware.tablelayout.Cell defaults() -> m
    com.esotericsoftware.tablelayout.BaseTableLayout pad(com.esotericsoftware.tablelayout.Value) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout pad(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout padTop(com.esotericsoftware.tablelayout.Value) -> b
    com.esotericsoftware.tablelayout.BaseTableLayout padLeft(com.esotericsoftware.tablelayout.Value) -> c
    com.esotericsoftware.tablelayout.BaseTableLayout padBottom(com.esotericsoftware.tablelayout.Value) -> d
    com.esotericsoftware.tablelayout.BaseTableLayout padRight(com.esotericsoftware.tablelayout.Value) -> e
    com.esotericsoftware.tablelayout.BaseTableLayout pad(float) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout pad(float,float,float,float) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout padTop(float) -> b
    com.esotericsoftware.tablelayout.BaseTableLayout padLeft(float) -> c
    com.esotericsoftware.tablelayout.BaseTableLayout padBottom(float) -> d
    com.esotericsoftware.tablelayout.BaseTableLayout padRight(float) -> e
    com.esotericsoftware.tablelayout.BaseTableLayout align(int) -> b
    com.esotericsoftware.tablelayout.BaseTableLayout center() -> n
    com.esotericsoftware.tablelayout.BaseTableLayout top() -> o
    com.esotericsoftware.tablelayout.BaseTableLayout left() -> p
    com.esotericsoftware.tablelayout.BaseTableLayout bottom() -> q
    com.esotericsoftware.tablelayout.BaseTableLayout right() -> r
    com.esotericsoftware.tablelayout.BaseTableLayout debug() -> s
    com.esotericsoftware.tablelayout.BaseTableLayout debugTable() -> t
    com.esotericsoftware.tablelayout.BaseTableLayout debugCell() -> u
    com.esotericsoftware.tablelayout.BaseTableLayout debugWidget() -> v
    com.esotericsoftware.tablelayout.BaseTableLayout debug(com.esotericsoftware.tablelayout.BaseTableLayout$Debug) -> a
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug getDebug() -> w
    com.esotericsoftware.tablelayout.Value getPadTopValue() -> x
    float getPadTop() -> y
    com.esotericsoftware.tablelayout.Value getPadLeftValue() -> z
    float getPadLeft() -> A
    com.esotericsoftware.tablelayout.Value getPadBottomValue() -> B
    float getPadBottom() -> C
    com.esotericsoftware.tablelayout.Value getPadRightValue() -> D
    float getPadRight() -> E
    int getAlign() -> F
    int getRow(float) -> f
    float[] ensureSize(float[],int) -> a
    float w(com.esotericsoftware.tablelayout.Value) -> f
    float h(com.esotericsoftware.tablelayout.Value) -> g
    float w(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Cell) -> a
    float h(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Cell) -> b
    void computeSize() -> G
    void layout(float,float,float,float) -> b
com.esotericsoftware.tablelayout.BaseTableLayout$Debug -> com.a.a.b:
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug none -> a
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug all -> b
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug table -> c
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug cell -> d
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug widget -> e
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug[] $VALUES -> f
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug[] values() -> values
    com.esotericsoftware.tablelayout.BaseTableLayout$Debug valueOf(java.lang.String) -> valueOf
com.esotericsoftware.tablelayout.Cell -> com.a.a.c:
    com.esotericsoftware.tablelayout.Value minWidth -> a
    com.esotericsoftware.tablelayout.Value minHeight -> b
    com.esotericsoftware.tablelayout.Value prefWidth -> c
    com.esotericsoftware.tablelayout.Value prefHeight -> d
    com.esotericsoftware.tablelayout.Value maxWidth -> e
    com.esotericsoftware.tablelayout.Value maxHeight -> f
    com.esotericsoftware.tablelayout.Value spaceTop -> g
    com.esotericsoftware.tablelayout.Value spaceLeft -> h
    com.esotericsoftware.tablelayout.Value spaceBottom -> i
    com.esotericsoftware.tablelayout.Value spaceRight -> j
    com.esotericsoftware.tablelayout.Value padTop -> k
    com.esotericsoftware.tablelayout.Value padLeft -> l
    com.esotericsoftware.tablelayout.Value padBottom -> m
    com.esotericsoftware.tablelayout.Value padRight -> n
    java.lang.Float fillX -> o
    java.lang.Float fillY -> p
    java.lang.Integer align -> q
    java.lang.Integer expandX -> r
    java.lang.Integer expandY -> s
    java.lang.Boolean ignore -> t
    java.lang.Integer colspan -> u
    java.lang.Boolean uniformX -> v
    java.lang.Boolean uniformY -> w
    java.lang.Object widget -> x
    float widgetX -> y
    float widgetY -> z
    float widgetWidth -> A
    float widgetHeight -> B
    com.esotericsoftware.tablelayout.BaseTableLayout layout -> K
    boolean endRow -> C
    int column -> D
    int row -> E
    int cellAboveIndex -> F
    float computedPadTop -> G
    float computedPadLeft -> H
    float computedPadBottom -> I
    float computedPadRight -> J
    void set(com.esotericsoftware.tablelayout.Cell) -> a
    void merge(com.esotericsoftware.tablelayout.Cell) -> b
    com.esotericsoftware.tablelayout.Cell setWidget(java.lang.Object) -> a
    java.lang.Object getWidget() -> a
    boolean hasWidget() -> b
    com.esotericsoftware.tablelayout.Cell size(com.esotericsoftware.tablelayout.Value) -> a
    com.esotericsoftware.tablelayout.Cell size(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> a
    com.esotericsoftware.tablelayout.Cell size(float) -> a
    com.esotericsoftware.tablelayout.Cell size(float,float) -> a
    com.esotericsoftware.tablelayout.Cell width(com.esotericsoftware.tablelayout.Value) -> b
    com.esotericsoftware.tablelayout.Cell width(float) -> b
    com.esotericsoftware.tablelayout.Cell height(com.esotericsoftware.tablelayout.Value) -> c
    com.esotericsoftware.tablelayout.Cell height(float) -> c
    com.esotericsoftware.tablelayout.Cell minSize(com.esotericsoftware.tablelayout.Value) -> d
    com.esotericsoftware.tablelayout.Cell minSize(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> b
    com.esotericsoftware.tablelayout.Cell minWidth(com.esotericsoftware.tablelayout.Value) -> e
    com.esotericsoftware.tablelayout.Cell minHeight(com.esotericsoftware.tablelayout.Value) -> f
    com.esotericsoftware.tablelayout.Cell minSize(float) -> d
    com.esotericsoftware.tablelayout.Cell minSize(float,float) -> b
    com.esotericsoftware.tablelayout.Cell minWidth(float) -> e
    com.esotericsoftware.tablelayout.Cell minHeight(float) -> f
    com.esotericsoftware.tablelayout.Cell prefSize(com.esotericsoftware.tablelayout.Value) -> g
    com.esotericsoftware.tablelayout.Cell prefSize(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> c
    com.esotericsoftware.tablelayout.Cell prefWidth(com.esotericsoftware.tablelayout.Value) -> h
    com.esotericsoftware.tablelayout.Cell prefHeight(com.esotericsoftware.tablelayout.Value) -> i
    com.esotericsoftware.tablelayout.Cell prefSize(float,float) -> c
    com.esotericsoftware.tablelayout.Cell prefSize(float) -> g
    com.esotericsoftware.tablelayout.Cell prefWidth(float) -> h
    com.esotericsoftware.tablelayout.Cell prefHeight(float) -> i
    com.esotericsoftware.tablelayout.Cell maxSize(com.esotericsoftware.tablelayout.Value) -> j
    com.esotericsoftware.tablelayout.Cell maxSize(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> d
    com.esotericsoftware.tablelayout.Cell maxWidth(com.esotericsoftware.tablelayout.Value) -> k
    com.esotericsoftware.tablelayout.Cell maxHeight(com.esotericsoftware.tablelayout.Value) -> l
    com.esotericsoftware.tablelayout.Cell maxSize(float) -> j
    com.esotericsoftware.tablelayout.Cell maxSize(float,float) -> d
    com.esotericsoftware.tablelayout.Cell maxWidth(float) -> k
    com.esotericsoftware.tablelayout.Cell maxHeight(float) -> l
    com.esotericsoftware.tablelayout.Cell space(com.esotericsoftware.tablelayout.Value) -> m
    com.esotericsoftware.tablelayout.Cell space(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> a
    com.esotericsoftware.tablelayout.Cell spaceTop(com.esotericsoftware.tablelayout.Value) -> n
    com.esotericsoftware.tablelayout.Cell spaceLeft(com.esotericsoftware.tablelayout.Value) -> o
    com.esotericsoftware.tablelayout.Cell spaceBottom(com.esotericsoftware.tablelayout.Value) -> p
    com.esotericsoftware.tablelayout.Cell spaceRight(com.esotericsoftware.tablelayout.Value) -> q
    com.esotericsoftware.tablelayout.Cell space(float) -> m
    com.esotericsoftware.tablelayout.Cell space(float,float,float,float) -> a
    com.esotericsoftware.tablelayout.Cell spaceTop(float) -> n
    com.esotericsoftware.tablelayout.Cell spaceLeft(float) -> o
    com.esotericsoftware.tablelayout.Cell spaceBottom(float) -> p
    com.esotericsoftware.tablelayout.Cell spaceRight(float) -> q
    com.esotericsoftware.tablelayout.Cell pad(com.esotericsoftware.tablelayout.Value) -> r
    com.esotericsoftware.tablelayout.Cell pad(com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value,com.esotericsoftware.tablelayout.Value) -> b
    com.esotericsoftware.tablelayout.Cell padTop(com.esotericsoftware.tablelayout.Value) -> s
    com.esotericsoftware.tablelayout.Cell padLeft(com.esotericsoftware.tablelayout.Value) -> t
    com.esotericsoftware.tablelayout.Cell padBottom(com.esotericsoftware.tablelayout.Value) -> u
    com.esotericsoftware.tablelayout.Cell padRight(com.esotericsoftware.tablelayout.Value) -> v
    com.esotericsoftware.tablelayout.Cell pad(float) -> r
    com.esotericsoftware.tablelayout.Cell pad(float,float,float,float) -> b
    com.esotericsoftware.tablelayout.Cell padTop(float) -> s
    com.esotericsoftware.tablelayout.Cell padLeft(float) -> t
    com.esotericsoftware.tablelayout.Cell padBottom(float) -> u
    com.esotericsoftware.tablelayout.Cell padRight(float) -> v
    com.esotericsoftware.tablelayout.Cell fill() -> c
    com.esotericsoftware.tablelayout.Cell fillX() -> d
    com.esotericsoftware.tablelayout.Cell fillY() -> e
    com.esotericsoftware.tablelayout.Cell fill(java.lang.Float,java.lang.Float) -> a
    com.esotericsoftware.tablelayout.Cell fill(boolean,boolean) -> a
    com.esotericsoftware.tablelayout.Cell fill(boolean) -> a
    com.esotericsoftware.tablelayout.Cell align(java.lang.Integer) -> a
    com.esotericsoftware.tablelayout.Cell center() -> f
    com.esotericsoftware.tablelayout.Cell top() -> g
    com.esotericsoftware.tablelayout.Cell left() -> h
    com.esotericsoftware.tablelayout.Cell bottom() -> i
    com.esotericsoftware.tablelayout.Cell right() -> j
    com.esotericsoftware.tablelayout.Cell expand() -> k
    com.esotericsoftware.tablelayout.Cell expandX() -> l
    com.esotericsoftware.tablelayout.Cell expandY() -> m
    com.esotericsoftware.tablelayout.Cell expand(java.lang.Integer,java.lang.Integer) -> a
    com.esotericsoftware.tablelayout.Cell expand(boolean,boolean) -> b
    com.esotericsoftware.tablelayout.Cell ignore(java.lang.Boolean) -> a
    com.esotericsoftware.tablelayout.Cell ignore() -> n
    boolean getIgnore() -> o
    com.esotericsoftware.tablelayout.Cell colspan(java.lang.Integer) -> b
    com.esotericsoftware.tablelayout.Cell uniform() -> p
    com.esotericsoftware.tablelayout.Cell uniformX() -> q
    com.esotericsoftware.tablelayout.Cell uniformY() -> r
    com.esotericsoftware.tablelayout.Cell uniform(java.lang.Boolean,java.lang.Boolean) -> a
    float getWidgetX() -> s
    void setWidgetX(float) -> w
    float getWidgetY() -> t
    void setWidgetY(float) -> x
    float getWidgetWidth() -> u
    void setWidgetWidth(float) -> y
    float getWidgetHeight() -> v
    void setWidgetHeight(float) -> z
    int getColumn() -> w
    int getRow() -> x
    com.esotericsoftware.tablelayout.Value getMinWidthValue() -> y
    float getMinWidth() -> z
    com.esotericsoftware.tablelayout.Value getMinHeightValue() -> A
    float getMinHeight() -> B
    com.esotericsoftware.tablelayout.Value getPrefWidthValue() -> C
    float getPrefWidth() -> D
    com.esotericsoftware.tablelayout.Value getPrefHeightValue() -> E
    float getPrefHeight() -> F
    com.esotericsoftware.tablelayout.Value getMaxWidthValue() -> G
    float getMaxWidth() -> H
    com.esotericsoftware.tablelayout.Value getMaxHeightValue() -> I
    float getMaxHeight() -> J
    com.esotericsoftware.tablelayout.Value getSpaceTopValue() -> K
    float getSpaceTop() -> L
    com.esotericsoftware.tablelayout.Value getSpaceLeftValue() -> M
    float getSpaceLeft() -> N
    com.esotericsoftware.tablelayout.Value getSpaceBottomValue() -> O
    float getSpaceBottom() -> P
    com.esotericsoftware.tablelayout.Value getSpaceRightValue() -> Q
    float getSpaceRight() -> R
    com.esotericsoftware.tablelayout.Value getPadTopValue() -> S
    float getPadTop() -> T
    com.esotericsoftware.tablelayout.Value getPadLeftValue() -> U
    float getPadLeft() -> V
    com.esotericsoftware.tablelayout.Value getPadBottomValue() -> W
    float getPadBottom() -> X
    com.esotericsoftware.tablelayout.Value getPadRightValue() -> Y
    float getPadRight() -> Z
    java.lang.Float getFillX() -> aa
    java.lang.Float getFillY() -> ab
    java.lang.Integer getAlign() -> ac
    java.lang.Integer getExpandX() -> ad
    java.lang.Integer getExpandY() -> ae
    java.lang.Integer getColspan() -> af
    java.lang.Boolean getUniformX() -> ag
    java.lang.Boolean getUniformY() -> ah
    boolean isEndRow() -> ai
    float getComputedPadTop() -> aj
    float getComputedPadLeft() -> ak
    float getComputedPadBottom() -> al
    float getComputedPadRight() -> am
    com.esotericsoftware.tablelayout.Cell row() -> an
    com.esotericsoftware.tablelayout.BaseTableLayout getLayout() -> ao
    com.esotericsoftware.tablelayout.Cell defaults(com.esotericsoftware.tablelayout.BaseTableLayout) -> a
com.esotericsoftware.tablelayout.Toolkit -> com.a.a.d:
    com.esotericsoftware.tablelayout.Toolkit instance -> b
    void addChild(java.lang.Object,java.lang.Object) -> b
    void removeChild(java.lang.Object,java.lang.Object) -> a
    float getMinWidth(java.lang.Object) -> h
    float getMinHeight(java.lang.Object) -> g
    float getPrefWidth(java.lang.Object) -> f
    float getPrefHeight(java.lang.Object) -> e
    float getMaxWidth(java.lang.Object) -> d
    float getMaxHeight(java.lang.Object) -> c
    float getWidth(java.lang.Object) -> b
    float getHeight(java.lang.Object) -> a
    void clearDebugRectangles(com.esotericsoftware.tablelayout.BaseTableLayout) -> a
    void addDebugRectangle(com.esotericsoftware.tablelayout.BaseTableLayout,com.esotericsoftware.tablelayout.BaseTableLayout$Debug,float,float,float,float) -> a
    void setWidget(com.esotericsoftware.tablelayout.BaseTableLayout,com.esotericsoftware.tablelayout.Cell,java.lang.Object) -> a
    float width(float) -> a
    float height(float) -> b
com.esotericsoftware.tablelayout.Value -> com.a.a.e:
    com.esotericsoftware.tablelayout.Value zero -> a
    com.esotericsoftware.tablelayout.Value minWidth -> b
    com.esotericsoftware.tablelayout.Value minHeight -> c
    com.esotericsoftware.tablelayout.Value prefWidth -> d
    com.esotericsoftware.tablelayout.Value prefHeight -> e
    com.esotericsoftware.tablelayout.Value maxWidth -> f
    com.esotericsoftware.tablelayout.Value maxHeight -> g
    float get(java.lang.Object) -> a
    float get(com.esotericsoftware.tablelayout.Cell) -> a
    float width(java.lang.Object) -> b
    float height(java.lang.Object) -> c
    float width(com.esotericsoftware.tablelayout.Cell) -> b
    float height(com.esotericsoftware.tablelayout.Cell) -> c
    com.esotericsoftware.tablelayout.Value percentWidth(float) -> a
    com.esotericsoftware.tablelayout.Value percentHeight(float) -> b
    com.esotericsoftware.tablelayout.Value percentWidth(float,java.lang.Object) -> a
    com.esotericsoftware.tablelayout.Value percentHeight(float,java.lang.Object) -> b
com.esotericsoftware.tablelayout.Value$1 -> com.a.a.f:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$10 -> com.a.a.g:
    java.lang.Object val$widget -> h
    float val$percent -> i
    float get(com.esotericsoftware.tablelayout.Cell) -> a
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$11 -> com.a.a.h:
    java.lang.Object val$widget -> h
    float val$percent -> i
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$2 -> com.a.a.i:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$3 -> com.a.a.j:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$4 -> com.a.a.k:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$5 -> com.a.a.l:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$6 -> com.a.a.m:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$7 -> com.a.a.n:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$8 -> com.a.a.o:
    float val$percent -> h
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$9 -> com.a.a.p:
    float val$percent -> h
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$CellValue -> com.a.a.q:
    float get(java.lang.Object) -> a
com.esotericsoftware.tablelayout.Value$FixedValue -> com.a.a.r:
    float value -> h
    void set(float) -> c
    float get(java.lang.Object) -> a
    float get(com.esotericsoftware.tablelayout.Cell) -> a
com.esotericsoftware.tablelayout.Value$TableValue -> com.a.a.s:
    float get(com.esotericsoftware.tablelayout.Cell) -> a
hevs.androiddemoselector.AboutDialog -> hevs.androiddemoselector.AboutDialog:
    android.content.Context mContext -> s
    void setContext(android.content.Context) -> a
    void onCreate(android.os.Bundle) -> onCreate
    java.lang.String readRawTextFile(int) -> b
hevs.androiddemoselector.BuildConfig -> hevs.androiddemoselector.a:
    boolean DEBUG -> a
hevs.androiddemoselector.DemoSelectorActivity -> hevs.androiddemoselector.DemoSelectorActivity:
    java.util.LinkedHashMap demoList -> a
    void onCreate(android.os.Bundle) -> onCreate
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
    void onClick(android.view.View) -> onClick
hevs.androiddemoselector.GDXEventHandler -> hevs.androiddemoselector.b:
    android.content.Context c -> a
    void showAboutBox() -> a
    void showToast() -> b
hevs.androiddemoselector.GameActivity -> hevs.androiddemoselector.GameActivity:
    void onCreate(android.os.Bundle) -> onCreate
hevs.androiddemoselector.R -> hevs.androiddemoselector.c:
hevs.androiddemoselector.R$attr -> hevs.androiddemoselector.d:
hevs.androiddemoselector.R$drawable -> hevs.androiddemoselector.e:
    int ic_launcher -> ic_launcher
    int icone_android -> icone_android
hevs.androiddemoselector.R$id -> hevs.androiddemoselector.f:
    int btQuit -> btQuit
    int info_text -> info_text
    int legal_text -> legal_text
    int progressBar1 -> progressBar1
hevs.androiddemoselector.R$layout -> hevs.androiddemoselector.g:
    int about -> about
    int list_activity -> list_activity
    int mylayout -> mylayout
hevs.androiddemoselector.R$raw -> hevs.androiddemoselector.h:
    int info -> info
    int legal -> legal
hevs.androiddemoselector.R$string -> hevs.androiddemoselector.i:
    int app_name -> app_name
    int btn_quit_title -> btn_quit_title
    int selector_header_title -> selector_header_title
hevs.androiddemoselector.R$style -> hevs.androiddemoselector.j:
    int AppBaseTheme -> AppBaseTheme
    int AppTheme -> AppTheme
hevs.gdx2d.components.audio.MusicPlayer -> hevs.gdx2d.components.audio.MusicPlayer:
    com.badlogic.gdx.audio.Music s -> a
    float volume -> b
    boolean isPlaying() -> a
    void setVolume(float) -> a
    void play() -> b
    void stop() -> c
    void dispose() -> e
    void loop() -> d
    void finalize() -> finalize
hevs.gdx2d.components.audio.SoundPlayer -> hevs.gdx2d.components.audio.SoundPlayer:
    com.badlogic.gdx.audio.Sound s -> a
    float volume -> b
    void setVolume(float) -> a
    void play() -> a
    void stop() -> b
    void loop() -> c
    void dispose() -> e
hevs.gdx2d.components.bitmaps.BitmapImage -> hevs.gdx2d.components.bitmaps.BitmapImage:
    com.badlogic.gdx.graphics.Texture image -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion tRegion -> b
    com.badlogic.gdx.graphics.Texture getImage() -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> b
    void mirrorLeftRight() -> c
    void mirrorUpDown() -> d
    void dispose() -> e
    void finalize() -> finalize
hevs.gdx2d.components.colors.ColorUtils -> hevs.gdx2d.components.colors.ColorUtils:
    com.badlogic.gdx.graphics.Color hsvToColor(float,float,float) -> a
    int hsvToRgb(float,float,float) -> b
    int rgbToInt(float,float,float) -> c
    com.badlogic.gdx.graphics.Color intToColor(int) -> a
hevs.gdx2d.components.colors.PaletteGenerator -> hevs.gdx2d.components.colors.PaletteGenerator:
    java.util.Random random -> a
    com.badlogic.gdx.graphics.Color RandomMix(com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,float) -> a
hevs.gdx2d.components.geometry.Point -> hevs.gdx2d.components.geometry.Point:
    int x -> a
    int y -> b
hevs.gdx2d.components.geometry.Vector2D -> hevs.gdx2d.components.geometry.Vector2D:
    float x -> a
    float y -> b
    double distanceTo(hevs.gdx2d.components.geometry.Vector2D) -> a
    double norm() -> a
    java.lang.String toString() -> toString
hevs.gdx2d.components.graphics.Polygon -> hevs.gdx2d.components.graphics.Polygon:
    float[] vertices -> b
    float[] triangulatedVertices -> c
    java.util.LinkedList vectorList -> a
    com.badlogic.gdx.math.EarClippingTriangulator ect -> d
    java.util.List earClippedVertices -> e
    com.badlogic.gdx.math.Vector2[] gdxpoints -> f
    float[] getVertices() -> a
    float[] getEarClippedVertices() -> b
    boolean contains(hevs.gdx2d.components.geometry.Vector2D) -> a
hevs.gdx2d.components.physics.AbstractPhysicsObject -> hevs.gdx2d.components.physics.AbstractPhysicsObject:
    java.lang.String name -> a
    com.badlogic.gdx.physics.box2d.Body body -> b
    com.badlogic.gdx.physics.box2d.Fixture f -> c
    com.badlogic.gdx.physics.box2d.BodyDef bodyDef -> d
    void createObject(com.badlogic.gdx.physics.box2d.Shape$Type,java.lang.String,com.badlogic.gdx.math.Vector2,int,int,float,float,float,float,boolean) -> a
    void createFixture(com.badlogic.gdx.physics.box2d.Shape,float,float,float) -> a
    void destroy() -> a
    void enableCollisionListener() -> b
    void collision(hevs.gdx2d.components.physics.AbstractPhysicsObject,float) -> a
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
hevs.gdx2d.components.physics.PhysicsBox -> hevs.gdx2d.components.physics.PhysicsBox:
hevs.gdx2d.components.physics.PhysicsCircle -> hevs.gdx2d.components.physics.PhysicsCircle:
hevs.gdx2d.components.physics.PhysicsStaticBox -> hevs.gdx2d.components.physics.PhysicsStaticBox:
hevs.gdx2d.components.physics.utils.PhysicsConstants -> hevs.gdx2d.components.physics.utils.PhysicsConstants:
    float STEP_SIZE -> a
    int VELOCITY_IT -> b
    int POSITION_IT -> c
hevs.gdx2d.components.physics.utils.PhysicsScreenBoundaries -> hevs.gdx2d.components.physics.utils.PhysicsScreenBoundaries:
hevs.gdx2d.components.physics.utils.PhysicsWorld -> hevs.gdx2d.components.physics.utils.PhysicsWorld:
    com.badlogic.gdx.physics.box2d.World instance -> a
    float accumulator -> b
    float step -> c
    com.badlogic.gdx.physics.box2d.World getInstance() -> a
    void updatePhysics(float) -> a
    void dispose() -> b
hevs.gdx2d.demos.accelerometer.DemoAccelerometer -> hevs.gdx2d.demos.accelerometer.DemoAccelerometer:
    hevs.gdx2d.components.bitmaps.BitmapImage compassBitmap -> a
    float smoothedValue -> b
    double SMOOTHING -> c
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onInit() -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.complex_shapes.DemoComplexShapes -> hevs.gdx2d.demos.complex_shapes.DemoComplexShapes:
    int N_SHAPES -> e
    int screenWidth -> f
    int screenHeight -> g
    int maxRadius -> h
    float angle -> j
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape shape_type -> k
    double counter -> l
    double dir -> m
    hevs.gdx2d.components.bitmaps.BitmapImage imageBmp -> n
    java.util.Random rrand -> a
    java.util.Vector colors -> b
    java.util.Vector shapes -> c
    java.util.Vector directions -> d
    int[] $SWITCH_TABLE$hevs$gdx2d$demos$complex_shapes$DemoComplexShapes$type_shape -> o
    void fillPalette() -> b
    void destroyObjects(int) -> a
    void generateObjects(int) -> b
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onKeyDown(int) -> c
    void onClick(int,int,int) -> a
    void main(java.lang.String[]) -> a
    int[] $SWITCH_TABLE$hevs$gdx2d$demos$complex_shapes$DemoComplexShapes$type_shape() -> c
hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape -> hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape:
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape CIRCLE -> a
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape IMAGE -> b
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape RECT -> c
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape[] ENUM$VALUES -> d
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape[] values() -> values
    hevs.gdx2d.demos.complex_shapes.DemoComplexShapes$type_shape valueOf(java.lang.String) -> valueOf
hevs.gdx2d.demos.complex_shapes.DrawableShape -> hevs.gdx2d.demos.complex_shapes.DrawableShape:
    java.util.Random rnd -> g
    int width -> a
    int height -> b
    int x -> c
    int y -> d
    float offset -> e
    com.badlogic.gdx.graphics.Color c -> f
hevs.gdx2d.demos.gestures.DemoGesture -> hevs.gdx2d.demos.gestures.DemoGesture:
    hevs.gdx2d.components.bitmaps.BitmapImage image -> a
    com.badlogic.gdx.graphics.OrthographicCamera cam -> b
    float initialScale -> c
    void onZoom(float,float) -> a
    void onClick(int,int,int) -> a
    void onPan(float,float,float,float) -> a
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.image_drawing.DemoMirrorImage -> hevs.gdx2d.demos.image_drawing.DemoMirrorImage:
    float counter -> a
    hevs.gdx2d.components.bitmaps.BitmapImage imgBitmap -> b
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.image_drawing.DemoRotatingImage -> hevs.gdx2d.demos.image_drawing.DemoRotatingImage:
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.image_drawing.DemoSimpleImage -> hevs.gdx2d.demos.image_drawing.DemoSimpleImage:
    float counter -> a
    hevs.gdx2d.components.bitmaps.BitmapImage imgBitmap -> b
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> b
hevs.gdx2d.demos.music.DemoMusicPlay -> hevs.gdx2d.demos.music.DemoMusicPlay:
    hevs.gdx2d.components.audio.MusicPlayer f -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onDispose() -> m_
    void onInit() -> a
    void onClick(int,int,int) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.DemoPhysicsBalls -> hevs.gdx2d.demos.physics.DemoPhysicsBalls:
    java.util.concurrent.ConcurrentLinkedQueue list -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer debugRenderer -> c
    hevs.gdx2d.components.bitmaps.BitmapImage img -> d
    int BOX_VELOCITY_ITERATIONS -> e
    int BOX_POSITION_ITERATIONS -> f
    boolean hasAccelerometers -> g
    double smoothedValue -> h
    double SMOOTHING -> j
    void onInit() -> a
    void addBall(int,int) -> a
    void onClick(int,int,int) -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onGameLogicUpdate() -> l_
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.DemoPhysicsMouse -> hevs.gdx2d.demos.physics.DemoPhysicsMouse:
    com.badlogic.gdx.physics.box2d.World world -> a
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer debugRenderer -> b
    com.badlogic.gdx.physics.box2d.Body hitBody -> c
    com.badlogic.gdx.physics.box2d.Body groundBody -> d
    com.badlogic.gdx.physics.box2d.joints.MouseJoint mouseJoint -> e
    com.badlogic.gdx.math.Vector2 testPoint -> f
    com.badlogic.gdx.physics.box2d.QueryCallback callback -> g
    com.badlogic.gdx.math.Vector2 target -> h
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onDrag(int,int) -> a_
    void onRelease(int,int,int) -> b
    void onClick(int,int,int) -> a
    void onDispose() -> m_
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.DemoPhysicsMouse$1 -> hevs.gdx2d.demos.physics.DemoPhysicsMouse$1:
    hevs.gdx2d.demos.physics.DemoPhysicsMouse this$0 -> a
    boolean reportFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
hevs.gdx2d.demos.physics.DemoSimplePhysics -> hevs.gdx2d.demos.physics.DemoSimplePhysics:
    com.badlogic.gdx.physics.box2d.World world -> a
    hevs.gdx2d.components.physics.PhysicsBox box -> b
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer debugRenderer -> c
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.collisions.BumpyBall -> hevs.gdx2d.demos.physics.collisions.BumpyBall:
    float lastCollision -> d
    void collision(hevs.gdx2d.components.physics.AbstractPhysicsObject,float) -> a
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.physics.collisions.DemoCollisionListener -> hevs.gdx2d.demos.physics.collisions.DemoCollisionListener:
    com.badlogic.gdx.physics.box2d.World world -> a
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer dbgRenderer -> b
    int time -> c
    hevs.gdx2d.demos.physics.collisions.BumpyBall b1 -> d
    hevs.gdx2d.demos.physics.collisions.BumpyBall b2 -> e
    hevs.gdx2d.demos.physics.collisions.BumpyBall b3 -> f
    hevs.gdx2d.demos.physics.collisions.BumpyBall b4 -> g
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.particle.DemoParticlePhysics -> hevs.gdx2d.demos.physics.particle.DemoParticlePhysics:
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer dbgRenderer -> a
    com.badlogic.gdx.physics.box2d.World w -> b
    boolean mouseActive -> c
    int CREATION_RATE -> d
    int MAX_AGE -> e
    com.badlogic.gdx.math.Vector2 position -> f
    java.util.Random rand -> g
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void createParticles() -> d
    void onDrag(int,int) -> a_
    void onClick(int,int,int) -> a
    void onRelease(int,int,int) -> b
    void onKeyDown(int) -> c
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.particle.Particle -> hevs.gdx2d.demos.physics.particle.Particle:
    hevs.gdx2d.components.bitmaps.BitmapImage img -> d
    int age -> e
    int maxAge -> f
    boolean shouldbeDestroyed() -> c
    void step() -> d
    void render(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.physics.rocket.DemoPhysicsRocket -> hevs.gdx2d.demos.physics.rocket.DemoPhysicsRocket:
    com.badlogic.gdx.physics.box2d.Box2DDebugRenderer dbgRenderer -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    hevs.gdx2d.demos.physics.rocket.Spaceship ship -> c
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onKeyUp(int) -> a_
    void onKeyDown(int) -> c
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.physics.rocket.Sky -> hevs.gdx2d.demos.physics.rocket.Sky:
    hevs.gdx2d.components.bitmaps.BitmapImage image -> a
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.physics.rocket.Spaceship -> hevs.gdx2d.demos.physics.rocket.Spaceship:
    hevs.gdx2d.components.physics.PhysicsBox box -> a
    boolean thrustLeft -> b
    boolean thrustRight -> c
    int thrustUp -> d
    hevs.gdx2d.components.bitmaps.BitmapImage shipImage -> e
    hevs.gdx2d.components.bitmaps.BitmapImage flameImage -> f
    float RAD2DEG -> g
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.scrolling.DemoScrolling -> hevs.gdx2d.demos.scrolling.DemoScrolling:
    java.util.Vector toDraw -> a
    double zoom -> b
    int travelSpeed -> c
    boolean scrolling -> d
    void onInit() -> a
    void onClick(int,int,int) -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.scrolling.objects.Brick -> hevs.gdx2d.demos.scrolling.objects.Brick:
    int posx -> a
    int posy -> b
    hevs.gdx2d.components.bitmaps.BitmapImage img -> c
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.scrolling.objects.Cloud -> hevs.gdx2d.demos.scrolling.objects.Cloud:
    hevs.gdx2d.components.bitmaps.BitmapImage cloudImage -> a
    int x -> b
    int y -> c
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.scrolling.objects.Coin -> hevs.gdx2d.demos.scrolling.objects.Coin:
    int posx -> a
    int posy -> b
    float scale -> c
    float direction -> d
    hevs.gdx2d.components.bitmaps.BitmapImage img -> e
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.scrolling.objects.Pipe -> hevs.gdx2d.demos.scrolling.objects.Pipe:
    int posx -> a
    int posy -> b
    hevs.gdx2d.components.bitmaps.BitmapImage img -> c
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.scrolling.objects.Sky -> hevs.gdx2d.demos.scrolling.objects.Sky:
    com.badlogic.gdx.graphics.Pixmap p -> a
    com.badlogic.gdx.graphics.Texture t -> b
    int width -> c
    int height -> d
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.simple.DemoSimpleAnimation -> hevs.gdx2d.demos.simple.DemoSimpleAnimation:
    int radius -> a
    int speed -> b
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.simple.DemoSimpleShapes -> hevs.gdx2d.demos.simple.DemoSimpleShapes:
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void main(java.lang.String[]) -> a
hevs.gdx2d.demos.tween.Ball -> hevs.gdx2d.demos.tween.Ball:
    float posx -> a
    float posy -> b
    hevs.gdx2d.components.bitmaps.BitmapImage img -> c
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.demos.tween.BallAccessor -> hevs.gdx2d.demos.tween.BallAccessor:
    int POSITION_X -> a
    int POSITION_Y -> b
    int POSITION_XY -> c
    boolean $assertionsDisabled -> d
    int getValues(hevs.gdx2d.demos.tween.Ball,int,float[]) -> a
    void setValues(hevs.gdx2d.demos.tween.Ball,int,float[]) -> b
    int getValues(java.lang.Object,int,float[]) -> a
    void setValues(java.lang.Object,int,float[]) -> b
hevs.gdx2d.demos.tween.DemoTween -> hevs.gdx2d.demos.tween.DemoTween:
    aurelienribon.tweenengine.TweenManager tm -> a
    hevs.gdx2d.demos.tween.Ball ball1 -> b
    hevs.gdx2d.demos.tween.Ball ball2 -> c
    hevs.gdx2d.demos.tween.Ball ball3 -> d
    int height -> e
    int width -> f
    void onInit() -> a
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onDispose() -> m_
    void main(java.lang.String[]) -> a
hevs.gdx2d.lib.Game2D -> hevs.gdx2d.lib.Game2D:
    hevs.gdx2d.lib.PortableApplication app -> a
    hevs.gdx2d.lib.GdxGraphics g -> b
    com.badlogic.gdx.graphics.OrthographicCamera camera -> c
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> d
    int angle -> e
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> f
    java.util.Timer t -> g
    int LOGIC_UPDATES_PER_SECOND -> h
    int logicRefreshFps -> i
    hevs.gdx2d.lib.interfaces.AndroidResolver resolver -> j
    void setLogicRefreshRate(int) -> a
    void create() -> a
    void render() -> b
    void resize(int,int) -> a
    void pause() -> c
    void resume() -> d
    void dispose() -> e
hevs.gdx2d.lib.Game2D$1 -> hevs.gdx2d.lib.Game2D$1:
    hevs.gdx2d.lib.Game2D this$0 -> a
    boolean zoom(float,float) -> b
    boolean touchDown(float,float,int,int) -> a
    boolean tap(float,float,int,int) -> b
    boolean pinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    boolean pan(float,float,float,float) -> a
    boolean longPress(float,float) -> a
    boolean fling(float,float,int) -> a
hevs.gdx2d.lib.Game2D$2 -> hevs.gdx2d.lib.Game2D$2:
    hevs.gdx2d.lib.Game2D this$0 -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean scrolled(int) -> c
    boolean mouseMoved(int,int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean keyDown(int) -> a
hevs.gdx2d.lib.Game2D$3 -> hevs.gdx2d.lib.Game2D$3:
    hevs.gdx2d.lib.Game2D this$0 -> a
    void run() -> run
hevs.gdx2d.lib.Game2D$4 -> hevs.gdx2d.lib.Game2D$4:
    hevs.gdx2d.lib.Game2D this$0 -> a
    void run() -> run
hevs.gdx2d.lib.GdxGraphics -> hevs.gdx2d.lib.GdxGraphics:
    com.badlogic.gdx.graphics.OrthographicCamera camera -> a
    com.badlogic.gdx.graphics.OrthographicCamera fixedcamera -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> c
    com.badlogic.gdx.graphics.Color currentColor -> d
    com.badlogic.gdx.graphics.Color backGroundColor -> e
    com.badlogic.gdx.graphics.g2d.SpriteBatch spriteBatch -> f
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> g
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    com.badlogic.gdx.graphics.Texture logoTex -> i
    com.badlogic.gdx.graphics.Texture circleTex -> j
    void dispose() -> e
    void drawFPS() -> a
    void drawSchoolLogo() -> b
    void drawSchoolLogoUpperRight() -> c
    void drawSchoolLogoUpperRight(boolean) -> a
    void setPenWidth(float) -> a
    int getScreenHeight() -> d
    int getScreenWidth() -> f
    void drawRectangle(float,float,float,float,float) -> a
    void clear() -> g
    void clear(com.badlogic.gdx.graphics.Color) -> a
    void setColor(com.badlogic.gdx.graphics.Color) -> b
    void setPixel(float,float) -> a
    void setPixel(float,float,com.badlogic.gdx.graphics.Color) -> a
    void clearPixel(float,float) -> b
    void drawLine(float,float,float,float) -> a
    void drawLine(float,float,float,float,com.badlogic.gdx.graphics.Color) -> a
    void drawFilledRectangle(float,float,float,float,float) -> b
    void drawFilledRectangle(float,float,float,float,float,com.badlogic.gdx.graphics.Color) -> a
    void drawCircle(float,float,float,com.badlogic.gdx.graphics.Color) -> a
    void drawCircle(float,float,float) -> a
    void drawFilledCircle(float,float,float,com.badlogic.gdx.graphics.Color) -> b
    void drawString(float,float,java.lang.String) -> a
    void drawString(float,float,java.lang.String,com.badlogic.gdx.graphics.Color,float) -> a
    void drawBackground(hevs.gdx2d.components.bitmaps.BitmapImage,float,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.Texture,float,float) -> a
    void drawTexture(com.badlogic.gdx.graphics.Texture,int,int,boolean) -> a
    void drawPicture(float,float,hevs.gdx2d.components.bitmaps.BitmapImage) -> a
    void drawTransformedPicture(float,float,float,float,hevs.gdx2d.components.bitmaps.BitmapImage) -> a
    void drawTransformedPicture(float,float,float,float,float,hevs.gdx2d.components.bitmaps.BitmapImage) -> a
    void drawTransformedPicture(float,float,float,float,float,float,hevs.gdx2d.components.bitmaps.BitmapImage) -> a
    void drawPolygon(hevs.gdx2d.components.graphics.Polygon) -> a
    void drawFilledPolygon(hevs.gdx2d.components.graphics.Polygon,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.OrthographicCamera getCamera() -> h
    void moveCamera(float,float) -> c
    void resetCamera() -> i
    void scroll(float,float) -> d
    void zoom(float) -> b
hevs.gdx2d.lib.PortableApplication -> hevs.gdx2d.lib.PortableApplication:
    boolean onAndroid -> i
    hevs.gdx2d.lib.Game2D theGame -> a
    void setTitle(java.lang.String) -> a
    int getWindowHeight() -> e
    int getWindowWidth() -> f
    void onGameLogicUpdate() -> l_
    void onClick(int,int,int) -> a
    void onDrag(int,int) -> a_
    void onRelease(int,int,int) -> b
    void onKeyDown(int) -> c
    void onKeyUp(int) -> a_
    void onZoom(float,float) -> a
    void onTap(float,float,int,int) -> a
    void onPinch(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> a
    void onPan(float,float,float,float) -> a
    void onLongPress(float,float) -> b
    void onFling(float,float,int) -> a
    void onDispose() -> m_
    void onPause() -> g
    void onResume() -> h
hevs.gdx2d.lib.Version -> hevs.gdx2d.lib.Version:
    java.lang.String version -> a
hevs.gdx2d.lib.interfaces.AndroidResolver -> hevs.gdx2d.lib.interfaces.AndroidResolver:
    void showAboutBox() -> a
    void showToast() -> b
hevs.gdx2d.lib.interfaces.DrawableObject -> hevs.gdx2d.lib.interfaces.DrawableObject:
    void draw(hevs.gdx2d.lib.GdxGraphics) -> a
hevs.gdx2d.lib.interfaces.GameInterface -> hevs.gdx2d.lib.interfaces.GameInterface:
    void onInit() -> a
    void onPause() -> g
    void onDispose() -> m_
    void onResume() -> h
    void onGraphicRender(hevs.gdx2d.lib.GdxGraphics) -> a
    void onGameLogicUpdate() -> l_
hevs.gdx2d.lib.interfaces.KeyboardInterface -> hevs.gdx2d.lib.interfaces.KeyboardInterface:
    void onKeyDown(int) -> c
    void onKeyUp(int) -> a_
hevs.gdx2d.lib.interfaces.TouchInterface -> hevs.gdx2d.lib.interfaces.TouchInterface:
    void onClick(int,int,int) -> a
    void onDrag(int,int) -> a_
    void onRelease(int,int,int) -> b
hevs.gdx2d.lib.perf_tests.Benchmarker -> hevs.gdx2d.lib.perf_tests.Benchmarker:
    void main(java.lang.String[]) -> a
hevs.gdx2d.lib.utils.GraphicTimer -> hevs.gdx2d.lib.utils.GraphicTimer:
    long t1 -> a
    void sync(int) -> a
hevs.gdx2d.lib.utils.Logger -> hevs.gdx2d.lib.utils.Logger:
    int NONE -> a
    int ERROR -> b
    int INFO -> c
    int DEBUG -> d
    void log(java.lang.String) -> a
    void setLogLevel(int) -> a
hevs.gdx2d.lib.utils.Utils -> hevs.gdx2d.lib.utils.Utils:
    void callCheck(java.lang.String,java.lang.String) -> a
    void callCheckExcludeGraphicRender() -> a
shaders.DiffuseShader -> c.a:
    com.badlogic.gdx.graphics.glutils.ShaderProgram createShadowShader() -> a
shaders.Gaussian -> c.b:
    com.badlogic.gdx.graphics.glutils.ShaderProgram createBlurShader(int,int) -> a
shaders.LightShader -> c.c:
    com.badlogic.gdx.graphics.glutils.ShaderProgram createLightShader() -> a
shaders.ShadowShader -> c.d:
    com.badlogic.gdx.graphics.glutils.ShaderProgram createShadowShader() -> a
shaders.WithoutShadowShader -> c.e:
    com.badlogic.gdx.graphics.glutils.ShaderProgram createShadowShader() -> a
